\documentclass[Afour,sageh,times]{sagej}

\usepackage{moreverb,url}
\usepackage{setspace}
\usepackage[colorlinks,bookmarksopen,bookmarksnumbered,citecolor=red,urlcolor=red]{hyperref}

\newcommand\BibTeX{{\rmfamily B\kern-.05em \textsc{i\kern-.025em b}\kern-.08em
     T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\newtheorem{thm}{Theorem}[section]
\newtheorem{cor}[thm]{Corollary}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{asmp}[thm]{Assumption}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{problem}{Problem}
\newtheorem{exmp}{Example}
%\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition}
%\theoremstyle{remark}
\newtheorem{rem}[thm]{Remark}
%\numberwithin{equation}{section}
% MATH -----------------------------------------------------------
\newcounter{mycounter}
\newenvironment{noindlist}
 {\begin{list}{\alph{mycounter})~~}{\usecounter{mycounter} \labelsep=0em \labelwidth=0em \leftmargin=0em \itemindent=0em}}
 {\end{list}}
%\renewcommand{\themycounter}{\alph{noindlist}}
\newcommand{\norm}[1]{\left\Vert#1\right\Vert}
\newcommand{\abs}[1]{\left\vert#1\right\vert}
\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\Real}{\mathbb R}
\newcommand{\eps}{\varepsilon}
\newcommand{\To}{\longrightarrow}
\newcommand{\BX}{\mathbf{B}(X)}
\newcommand{\A}{\mathcal{A}}
\newcommand\T{\rule{0pt}{2.9ex}}
\newcommand\B{\rule[-1.4ex]{0pt}{0pt}}
\newcommand{\ltl}{ {\it LTL}$_{-\bigcirc}$ }
\renewcommand{\topfraction}{0.98}
\renewcommand{\textfraction}{0.01}
\renewcommand{\floatpagefraction}{0.97}
\newcommand{\clause}[1]{\mathsf{cls}(#1)}
\newcommand{\cp}[2]{\ccalC_{#1}^{#2}}
\newcommand{\lk}[2]{\ell_{#1}^{(#2)}}
\newcommand{\auto}[1]{\ccalA_{\textup{#1}}}
\newcommand{\autop}{\ccalA_{\phi}}
\newcommand{\vertex}[1]{v_{\textup{#1}}}
\newcommand{\ag}[2]{\langle#1,#2\rangle}
\newcommand{\simplies}{\DOTSB\Longrightarrow}
\usepackage{stmaryrd}
% The following packages can be found on http:\\www.ctan.org
\usepackage{graphicx} % for pdf, bitmapped graphics files
%% \graphicspath{{figures/}}
\usepackage{bbm}
\usepackage{bm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{epstopdf}

\usepackage[noend,ruled,linesnumbered,resetcount]{algorithm2e}
\SetKwComment{Comment}{$\triangleright$\ } {}
\usepackage{multirow}
\usepackage{rotating}
\usepackage{subfigure}
\usepackage{color}
\usepackage{mysymbol}
\usepackage{url}
\usepackage{ltlfonts}
%\usepackage{caption}
%\usepackage[skip=0.5\baselineskip]{caption}
\usepackage{tabularx,ragged2e,booktabs}
\usepackage[normalem]{ulem}
\usepackage[utf8x]{inputenc}
\usepackage{multirow}
\renewcommand{\ttdefault}{pcr} % selects Courier font
\renewcommand{\ap}[3]{\mathcal{\pi}_{{#1},{#2}}^{#3}}
\newcommand{\aap}[4]{\mathcal{\pi}_{{#1},{#2}}^{#3,#4}}
\newcommand{\Qb}{\mathcal{Q}_{B}}
\newcommand{\qb}{q_{{B}}}
\newcommand{\vect}[1]{\boldsymbol{\mathbf{#1}}}
\newcommand{\wf}{\mathcal{W}_{\text{free}}}
\newcommand{\w}{\mathcal{W}}
\newcommand{\te}[1]{\mathcal{#1}_T}
\newcommand{\x}[1]{\vect{x}^{\text{#1}}}
\newcommand{\q}[2]{{q}_{#1}^{\text{#2}}}
\newcommand{\pn}{\ccalQ_P^{\text{near}}}
\newcommand{\RNum}[1]{\uppercase\expandafter{\romannumeral #1\relax}}
\newcommand{\wn}{\mathcal{W}^{N}}
\newcommand{\state}[1]{(\vect{x}^{#1}, q_B^{#1})}
\newcommand{\statex}[1]{\vect{x}^{#1}}
\newcommand{\stateb}[1]{q_B^{#1}}
\newcommand{\pre}{\text{pre}}
\newcommand{\suf}{\text{suf}}
\newcommand{\ball}[1]{B_{n,!#1}}
\newcommand{\llabel}[1]{L(\vect{x}^{#1})}
\newcommand{\node}[1]{V_{n}^{\text{#1}}}
\newcommand{\colorblue}[1]{\textcolor{blue}{#1}}
\newcommand{\colorred}[1]{\textcolor{red}{#1}}
\newcommand{\ba}{\texttt{int}(\mathcal{B}_{\delta(\vect{x}^0)}(\vect{x}^0))}
\newcommand{\baa}{\mathcal{B}_{\delta(\vect{x}^0)}(\vect{x}^0)}
\newcommand*\diff{\mathop{}\mathrm{d}}
\newcommand{\rrts}{pRRT$^* $}
\newcommand{\rrt}{pRRT}
\newcommand{\grrt}{\ccalG^{\text{TL-RRT}}}
\newcommand{\xx}{\overline{\bbx_{i}\bbx_{i}'}}
\newcommand{\domanda}[1]{\subsubsection*{#1}}
\usepackage[hang,flushmargin]{footmisc}
\makeatletter
\newcommand{\algorithmendnote}[2][\footnotesize]{%
  \let\old@algocf@finish\@algocf@finish% Store algorithm finish macro
  \def\@algocf@finish{\old@algocf@finish% Update finish macro to insert "endnote"
    \leavevmode\rlap{\begin{minipage}{\linewidth}
    #1#2
    \end{minipage}}%
  }%
}
\makeatother

\makeatletter
\newcommand{\pushright}[1]{\ifmeasuring@#1\else\omit\hfill$\displaystyle#1$\fi\ignorespaces}
\newcommand{\pushleft}[1]{\ifmeasuring@#1\else\omit$\displaystyle#1$\hfill\fi\ignorespaces}
\makeatother

\makeatletter
  \setbox0\hbox{$\xdef\scriptratio{\strip@pt\dimexpr
    \numexpr(\sf@size*65536)/\f@size sp}$}
\newcommand{\scriptveryshortarrow}[1][3pt]{{%
    \hbox{\rule[\scriptratio\dimexpr\fontdimen22\textfont2-.2pt\relax]
               {\scriptratio\dimexpr#1\relax}{\scriptratio\dimexpr.4pt\relax}}%
   \mkern-4mu\hbox{\let\f@size\sf@size\usefont{U}{lasy}{m}{n}\symbol{41}}}}

\makeatother

\newenvironment{cexmp}
{\addtocounter{exmp}{-1}\begin{exmp}}
  {\end{exmp}}

  \setcounter{secnumdepth}{3}
  % \hypersetup{draft}
  \usepackage{etoolbox}
\makeatletter
\patchcmd\@combinedblfloats{\box\@outputbox}{\unvbox\@outputbox}{}{\errmessage{\noexpand patch failed}}
\makeatother

\usepackage{graphicx,calc}
\newlength\myheight
\newlength\mydepth
\settototalheight\myheight{Xygp}
\settodepth\mydepth{Xygp}
\setlength\fboxsep{0pt}
\newcommand*\inlinegraphics[1]{%
  \settototalheight\myheight{Xygp}%
  \settodepth\mydepth{Xygp}%
  \raisebox{-0.7\mydepth}{\includegraphics[height=\myheight]{#1}}%
}


\begin{document}

\runninghead{Luo and Zavlanos}

\author{Xusheng Luo\affilnum{1} and Michael M. Zavlanos\affilnum{1}}

\affiliation{\affilnum{1} Department of Mechanical Engineering and Materials Science, Duke University, Durham, NC 27708, USA}

\corrauth{Xusheng Luo, Department of Mechanical Engineering and Materials Science, Duke University, Durham, NC 27708, USA}

\email{xusheng.luo@duke.edu}

\title{Temporal Logic Task Allocation and Motion Planning in Multi-Robot Systems}

\begin{abstract}
  In this paper we consider the problem of optimally allocating tasks, expressed as a global Linear Temporal Logic (LTL) specification, to teams of mobile robots. Each robot is capable of one task and each task may require multiple robots. Our goal is to design a set of collision-free paths that are capable of executing the assigned tasks.
    To obtain a scalable solution to this complex assignment problem, we propose an approximate method that first synthesizes a high-level plan  that exploits the structure of a relaxed version of the Nondeterministic Buchi Automaton (NBA) that captures the LTL specification and then convert the plan into executable paths by tackling a sequence of generalized multi-robot path planning instances. Specifically, we first prune the NBA and relax it by removing all negative atomic propositions in the NBA. Then, we decompose the relaxed NBA into simpler sub-NBA. The sequences of edges in these sub-NBA give rise to sequences of subtasks that the robots need to accomplish in order to satisfy the relaxed NBA. We capture these temporal relations between subtasks using partial orders and formulate a Mixed Integer Linear Problem (MILP) to allocate subtasks to robots that are subject to these partial order constraints. Next, after obtaining a high-level plan, we return back to the original NBA so as to satisfy the global LTL task. The relaxation is corrected and the high-level plan is implemented to take the collision into account, both of which are achieved by solving a sequence of generalized multi-robot path planning. Finally, we provide theoretic analysis on the correctness of the results and present numerical simulations that show our method can generate plans with lower cost, much faster than existing methods.
\end{abstract}

\keywords{Linear temporal logic, robotics, task allocation, multi-agent path planning}
\maketitle
\section{Introduction}
Control synthesis for robots under Linear Temporal Logic (LTL) tasks has received considerable attention recently~\cite{smith2011optimal,chen2012formal,kantaros2015intermittent,vasile2013sampling,kantaros2017sampling,kantaros2018sampling,kantaros2018text,kantaros2018temporal,kantaros2018distributedOpt,wolff2014optimization,shoukry2017linear}. If optimality is not required, then model checking theory~\cite{baier2008principles} can be used to find feasible paths~\cite{smith2011optimal,chen2012formal,kantaros2015intermittent}. On the other hand, if optimality is of interest, optimal control synthesis methods can be used to find optimal robot plans that either draw from sampling-based planning methods in robotics~\cite{vasile2013sampling,kantaros2017sampling,kantaros2018sampling,kantaros2018text,kantaros2018temporal,kantaros2018distributedOpt}, or formulate the LTL planning problem as an optimization problem~\cite{wolff2014optimization,shoukry2017linear} using existing solvers.


In this paper, we consider global LTL tasks that require robots of different types to visit different locations in space. The specific robot to visit a location is immaterial as long as it is a robot of the desired type. Satisfaction of such LTL tasks requires the solution of Multi-Robot Task Allocation (MRTA) problems, that also respect temporal constraints between tasks. Such problems can not be solved using existing model checkers or control synthesis methods as those discussed above. MRTA problems for simple point-to-point navigation tasks have been long studied in the robotics literature~\cite{korsah2013comprehensive,nunes2017taxonomy,gini2017multi}. A popular approach to solve these problems is using market-based methods~\cite{zavlanos2007distributed,zavlanos2008distributed,zavlanos2008dynamic,michael2008distributed}, although Mixed Integer Linear Programming (MILP) formulations have also been proposed~\cite{gombolay2013fast} due to the similarity of the MRTA problem with the vehicle routing problem~\cite{bredstrom2008combined}. In this paper, we propose a new MILP formulation of the LTL-MRTA  problem. The tasks that are assigned to the robots are extracted from the Nondeterministic Buchi Automaton (NBA) and satisfy a partial order relation capturing the temporal constraints imposed by the LTL.


To the best of our knowledge, the most relevant temporal logic task allocation methods are presented in \cite{schillinger2018decomposition,schillinger2018simultaneous,faruq2018simultaneous,sahin2017provably,sahin2017synchronous,sahin2019multi,sahin2019multirobot,karaman2011linear}. Specifically, the methods in~\cite{schillinger2018decomposition,schillinger2018simultaneous,faruq2018simultaneous} automatically decompose the LTL formula into independent tasks that can be fulfilled by different robots. However, these methods can not address cooperative tasks that require the collaboration of several robots. To overcome this limitation,~\cite{sahin2017provably,sahin2017synchronous,sahin2019multi,sahin2019multirobot} employ the counting linear temporal logic (cLTL+/cLTL) to capture constraints on the number of robots that must be present at different regions. All \cite{sahin2017provably,sahin2017synchronous,sahin2019multi,sahin2019multirobot} propose  an Integer Linear Programming (ILP) formulation inspired by Bounded Model Checking techniques~\cite{biere2006linear}. However, these methods only focus on feasibility of the resulting paths. Furthermore, cLTL+/cLTL cannot specify such tasks where two different regions need to be visited by the same set of robots sequentially, as demonstrated in Section~\ref{sec:sim}. Similarly,~\cite{karaman2011linear} generalizes the vehicle routing problem  using a mission specification and formulates an MILP to provide an optimal plan. However, all vehicles are homogeneous.

\section{Preliminaries}\label{sec:preliminaries}
\subsection{Linear temporal logic}\label{sec:ltl}
%% In this part, we describe Linear Temporal Logic (LTL) by presenting its syntax and semantics. Also, we briefly review preliminaries of automata-based LTL model checking.

Linear temporal logic~\cite{baier2008principles} is composed of a set of atomic propositions $\mathcal{AP}$, the boolean operators, conjunction $\wedge$ and negation $\neg$, and temporal operators, next $\bigcirc$ and until $\mathcal{U}$. LTL formulas over $\mathcal{AP}$ follow the grammar $\phi:=\top~|~\pi~|~\phi_1\wedge\phi_2~|~\phi_1\vee\phi_2~|~\neg\phi~|~\bigcirc\phi~|~\phi_1~\mathcal{U}~\phi_2$, where $\top$ is unconditionally true.   Other temporal operators, e.g., \textit{eventually} $\lozenge$, \textit{always} $\square$, can be derived from $\mathcal{U}$, where $\Diamond \phi = \top \mathcal{U} \phi$ means $\phi$ will be satisfied sometime in the future, and $\square \phi = \neg \Diamond \neg \phi$ means $\phi$ is always satisfied from now on. %% In this paper, we restrict our attention to LTL that excludes the ``next'' temporal operator, denoted by LTL$_{-X}$ in \cite{kloetzer2008fully}, since the property of asymptotic optimality requires the path generated by the planning algorithm to completely coincide with the optimal path, whereas the ``next'' operator violates the continuity of the underlying path.

An infinite \textit{word} $w$ over the alphabet $2^{\mathcal{AP}}$ is defined as an infinite sequence  $w=\sigma_0\sigma_1\ldots\in (2^{\mathcal{AP}})^{\omega}$, where $\omega$ denotes an infinite repetition and $\sigma_k\in2^{\mathcal{AP}}$, $\forall k\in\mathbb{N}$. The language $\texttt{Words}(\phi)=\left\{w|w\models\phi\right\}$ is defined as the set of words that satisfy the LTL formula $\phi$, where $\models\subseteq (2^{\mathcal{AP}})^{\omega}\times\phi$ is the satisfaction relation. An LTL $\phi$ can be translated into a NBA  defined as follows \cite{vardi1986automata}:
\begin{defn}[(NBA)]\label{def:nba}
  A \textit{Nondeterministic B$\ddot{\text{u}}$chi Automaton} $B$ is defined as a tuple $B=\left(\ccalQ_{B}, \ccalQ_{B}^0,\Sigma,\rightarrow_B,\mathcal{Q}_B^F\right)$, where $\ccalQ_{B}$ is the set of states; $\ccalQ_{B}^0\subseteq\ccalQ_{B}$ is a set of initial states; $\Sigma=2^{\mathcal{AP}}$ is an alphabet;  $\rightarrow_{B}\subseteq\ccalQ_{B}\times \Sigma\times\ccalQ_{B}$ is the transition relation;
%% For a transition $(q_B,\pi,q'_B)\in\rightarrow_{B}$, $\pi\in \Sigma$ is called a state label if $q_B=q'_B$, otherwise a transition label;
and $\ccalQ_B^F\subseteq\ccalQ_{B}$ is a set of accepting states.
\end{defn}

An \textit{infinite run} $\rho_B$ of $B$ over an infinite word $w=\sigma_0\sigma_1\sigma_2\dots$, $\sigma_k\in\Sigma$, $\forall k\in\mathbb{N}$, is a sequence $\rho_B=q_B^0q_B^1q_B^2\dots$ such that $q_B^0\in\ccalQ_B^0$ and $(q_B^{k},\sigma_k,q_B^{k+1})\in\rightarrow_{B}$, $\forall k\in\mathbb{N}$.
%% , where we call $\pi_k$ a \textit{state label} if $q_B^k=q_B^{k+1}$, otherwise a \textit{transition label} if $q_B^k \not= q_B^{k+1}$.
An infinite run $\rho_B$ is called \textit{accepting} if $\texttt{Inf}(\rho_B)\cap\ccalQ_B^F\neq\varnothing$, where $\texttt{Inf}(\rho_B)$ represents the set of states that appear in $\rho_B$ infinitely often. An accepting run can be written in the prefix-suffix structure such that the prefix part (connecting an initial state to an  accepting state) is traversed only once and the suffix part, which is a cycle around the accepting state, is traversed infinitely often.
The words $\sigma$ that produce an accepting run of $B$ constitute the accepted language of $B$, denoted by $\ccalL_B$. Then~\cite{baier2008principles} proves that the accepted language of $B$ is equivalent to the words of $\phi$, i.e., $\ccalL_B=\texttt{Words}(\phi)$.

\subsection{Partial orders}\label{sec:partial}
A finite partially ordered set or poset $P = (X, <_P )$  is a pair consisting of a finite base set $X$ and a binary relation $<_P \subseteq X \times X$ that is reflexive, antisymmetric, and transitive. Let  $x, y \in X$ be two distinct elements, we write $x <_P y$ if $(x,y) \in <_P$, while $x$ and $y$ are incomparable, written $x \|_P y$. Moreover, $x$ is covered by $y$ or $y$ covers $x$, denoted by $x \prec_P y$, if $x<_P  y$ and there is no $z \in X$ such that $x  <_P  z <_P y$. Anantichain is a subset of a poset such that any two distinct elements in this subset are incomparable. The width of a poset is the cardinality of a maximum antichain. %% Similarly, the height of a poset is defined as the maximum cardinality of a chain.

A linear order $L_X=(X, <_L)$ is a poset such that $x <_L y$, $x = y$ or $y <_L x$ holds for any pair of  $x, y \in X$. A linear extension  $L_P = (X, <_L)$ of a poset $P$ is a linear order such that $x <_L y$ if $x <_P y$. That is, a linear order that preserves the partial order. A poset can be seen as a generative model for its linear extensions.
We define $\ccalL_P$ as the set of all linear extensions of $P$. Note that a poset and its linear extensions share the same base set. Given a collection of linear orders $\Xi$, the poset cover problem focuses on reconstructing a single poset $P$ or a set of posets $P = \{P_1,\ldots,,P_k\}$ such that $L_P = \Xi$ or $\cup_{i\in[k]}L_{P_i} = \Xi$. As shown in~\cite{heath2013poset} the poset cover problem is NP-complete. Furthermore, the partial cover problem focuses on finding a poset $P$ such that $\ccalL_P$ contains the maximal number of linear orders in $\Xi$, i.e., $\ccalL_P \subseteq \Xi$ and   $\nexists P'$ s.t. $\ccalL_{P'} \subseteq \Xi$ and $|\ccalL_{P'}| > |\ccalL_{P}|$.~\cite{heath2013poset} shows that the partial cover problem can be solved in polynomial time.

\section{Problem Definition}\label{sec:problem}
 \subsection{Problem Definition}

 Consider a discrete environment filled with regions and obtacles, where each region or obstacles can span multiple free cells in the environment. We define $l\in \mathbb{N}^+$ disjoint or partially overlapping labeled regions of interest in free space and denote by $\mathcal{L}=\{\ell_k\}_{k=1}^{l}$ the set that collects these labeled regions. Furthermore, we represented the environment by a graph $E = (S, \to_E)$ where $S$ is the finite set of vertices corresponding to free cells and $\to_{E} \subseteq S \times S$ captures the adjacency relation.

 We consider a team of heterogeneous robots with different capabilities that work in the environment. Given a collection of $n$ robots belonging to $m$ types, we assume that every robot belongs to exactly one type. Moreover, let $\mathcal{K}_j, j\in[m]$ where $[m]$ is the shorthand notation for  $\{1,\ldots,m\}$, denote the set that  collects all robots of type $j$, so that $\sum_{j\in [m]} |\ccalK_j| = n$ and $\ccalK_{j} \cap \ccalK_{j'} = \emptyset$ if $j \not= j'$, where $|\cdot|$ is the cardinality of a set. Finally, we define $[r,j]$ to represent robot $r$ of type $j$, where $r\in \ccalK_j, j\in [m]$. To capture the mobility of robot $[r,j]$ in the environment, we define the { transition system} as follows:

\begin{defn}[(TS)]\label{def:ts}
  A { Transition System} for robot $[r,j]$, denoted by TS$_{r,j}$, is a tuple TS$_{r,j} = \{S, s_{r,j}^0, \to, \Pi_{r,j}, L_{r,j}\}$ where: (a) $S$ is the set of locations of robot $[r,j]$, and we denote by $s_{r,j}^t \in S$ its location at time $t$; (b) $s_{r,j}^0$ is the initial location; (c) $\to \subseteq \to_{E} \cup_{s\in S} \{(s,s)\} $ is the transition relation, that is, the robot can be allowed to remain idle or transition between adjacent cells; (d) $\Pi_{r,j} = \cup_{k\in [l]}\{p_{r,j}^k\} \cup \{\epsilon\}$ where the atomic proposition $p_{r,j}^{k}$ is true if robot $[r,j]$ is at labeled region $\ell_k$, and $\epsilon$ means empty label; (e) and $L_{r,j}: S \to 2^{\Pi_{r,j}} $ is the labeling function that returns the set of atomic propositions that are satisfied at location $s_{r,j}^t$.
\end{defn}

Given the definition of a TS, we define the {product transition system}, which captures all possible combinations of robot behaviors captured by their respective TS$_{[r,j]}$, as follows:
\begin{defn}[(PTS)]\label{def:pts}
  Given $n$ transition systems TS$_{r,j} = \{S, s_{r,j}^0, \to, \Pi_{r,j}, L_{r,j}\}$, the product transition system $\text{PTS}$ is a tuple $\text{PTS} = (S^n, s^0, \to, \Pi, L)$ where (a) $S^n = S\times \cdots \times S$ is the finite set of collective locations. We let $s^t = (s_{1,1}^t, \ldots, s_{|\ccalK_1|,1}^t, \ldots, s_{1,m}^t, \ldots, s_{|\ccalK_m|, m}^t) \in S^n$ collect all robot locations at time $t$, which requires that no more than one robots occupy the same free cell; (b) $s^0$ is the initial locations of robots; (c) $\to \subseteq S^n \times S^n$ is the transition relation. Specifically, $(s^t, s^{t+1}) \in \to$ if $s^t_{r,j}\rightarrow_{r,j} s^{t+1}_{r,j}$ for all $r\in \ccalK_j, \forall \,j \in [m]$ and there do not exist any two robots $[r,j]$ and $[r',j']$ such that $s^{t+1}_{r,j} = s^{t}_{r',j'}$ and $s^{t+1}_{r',j'} = s^{t}_{r,j}$. In words, each robot follows its transition relation and no two robots switch their locations; (d) $\Pi = \cup_{i\in[|\ccalK_j|], j\in [m], k\in [l]}\{\pi_{i,j}^k\} \cup \{\epsilon\}$, where the atomic proposition $\ap{i}{j}{k}$ is true if at least $i$ robots of type $j$, denoted by $\ag{i}{j}$, are at labeled region $\ell_k$ at time $t$, i.e., $\ap{i}{j}{k} \Leftrightarrow |\{r\in \ccalK_j: L_{r,j}(s_{r,j}^t) = p_{r,j}^k \}| \geq i$, where $|\cdot|$ is the cardinality of a set; (e) and $L: S^n \to 2^{\Pi}$ is the labeling function that returns the set of atomic propositions satisfied by all robots at time $t$.
\end{defn}

In this paper, we consider MRTA problems where the tasks are globally described by  a fragment of LTL formulas called \ltl that excludes the operator ``next''. Since formulas such as  $\bigcirc \ap{i}{j}{k}$ enforces $\ap{i}{j}{k}$ to be true at the next immediate step, which equivalently requires $\langle i,j \rangle$ to stay next to or at region $\ell_k$ at the current step. This requirement  is time-critical and can be easily violated if robots are allowed to stutter~\cite{sahin2019multirobot}. Moreover, we consider tasks where the same group of robots of certain types  need to visit different regions in sequence, e.g., to deliver objects between those locations. To capture such tasks, we  define {\it induced} atomic propositions over $\Pi$ (see Definition~\ref{def:pts})  as follows.


\begin{defn}[(Induced atomic propositions)]
   For each atomic proposition $\ap{i}{j}{k} \in \Pi$, we associate an infinite set of  {induced} atomic propositions $\{\ap{i}{j}{k,\chi}\}_{\chi\in \mathbb{N}}$, where $\chi$ is a {\it connector} that binds the truth of  atomic propositions with the same $i$ and $j$. Specifically, when $\chi=0$, $\ap{i}{j}{k,\chi}$ is reduced to $\ap{i}{j}{k}$, whose truth is state-dependent. On the other hand, if $\chi \neq 0$, the truth of $\ap{i}{j}{k,\chi}$ is state-and-path-dependent, and it additionally depends on other induced atomic propositions that share the same $i,j$ and $\chi$. That is, both $\ap{i}{j}{k,\chi}$ and $\ap{i'}{j'}{k',\chi'}$, with $\chi\not=0$, are true if the same group of $i$ robots of type $j$ visit regions $\ell_k$ and $\ell_{k'}$. Furthermore, the truth of the negative atomic proposition  $\neg \ap{i}{j}{k,\chi}$ is equivalent to its basic counterpart $\neg \ap{i}{j}{k}$, irrespective of  $\chi$. That is, less than $\ag{i}{j}$ are at location $\ell_k$.
 \end{defn}

We collect all basic and induced atomic propositions in the set $\Sigma$.  For the rest of this work, we omit the superscript $\chi$ when $\chi=0$. Next, we define the notion of {\it valid} temporal logic tasks.
 \begin{defn}[(Valid temporal logic task)]\label{defn:valid}
A temporal logic task specified by a\ltl formula is valid if atomic propositions with the same non-zero connector $\chi$ involves the same number of robots of the same robot type.
 \end{defn}

 \begin{figure}[!t]
    \centering
    \includegraphics[width=0.7\linewidth]{gridworld.pdf}
    \caption{Illustration of the environment and initial robot configurations for the emergencey response tasks.}\label{fig:workspace}
\end{figure}
\begin{exmp}[(Emergencey response)]\label{exmp:1}
  Consider an emergencey response scenario (see Fig.~\ref{fig:workspace}) where 3 robots of type 1 (indicated by \inlinegraphics{star.pdf}) and 2 robots of type 2 (indicated by \inlinegraphics{bluedot.pdf}) are located at region $\ell_1$, $\ell_2$ is an office building where personnel got injured, $\ell_4$ is the damaged road that leads to the open area $\ell_3$. We consider the following two rescue tasks: {\it (i)} \label{task:i} 2 robots of type 1 visit building $\ell_2$ to transport injured personnel to safe open area, and 1 robot of type 2 should visit $\ell_4$ to clear the road before robots of type 1 reach the safe area. {\it (ii)} \label{task:ii} 1 robot of type 1 travel between the building $\ell_2$ and the open area $\ell_3$ back and forth to transport valuable equipments. The considered tasks is complex compared to the conventional task allocation  in the sense that temporal terms exist like ``before'' and ``back and forth''.
\end{exmp}


 \begin{cexmp} [(Valid and invalid formulas)]
Observe that in Fig.~\ref{fig:workspace}, the satisfied atomic propsitions in $\Sigma$ are $\ap{3}{1}{1}$ and $\ap{2}{2}{1}$.   The valid formulas to specify the tasks \hyperref[task:i]{\it (i)} and \hyperref[task:ii]{\it (ii)} are: $\Diamond \Large((\ap{2}{1}{2,1}\wedge \neg \ap{2}{1}{3}) \wedge  \Diamond \ap{2}{1}{3,1}\Large)  \wedge \Diamond \ap{1}{2}{4} \wedge \neg \ap{2}{1}{3} \,\mathcal{U}\, \ap{1}{2}{4}$ and $\square \Diamond (\ap{1}{1}{2,1} \wedge \Diamond \ap{1}{1}{3,1})$, respectively. However, formulas $\Diamond (\ap{1}{1}{2,1} \wedge \Diamond \ap{2}{1}{3,1})$ and $\Diamond (\ap{2}{2}{2,1} \wedge \Diamond \ap{2}{1}{3,1})$ are two invalid formulas due to different number of robots and robot types, respectively.
 \end{cexmp}

 A $h$-length path $\tau = s^0 \ldots s^h$ that captures the collective behavior of the team is such that $s^{t-1}\to s^{t}, \forall t\in[h]$, which is {\it collision-free} since all robots do not collide with obstacles or each other according to Definition~\ref{def:ts}.  Given a valid\ltl formula $\phi$, a collision-free path $\tau$ that satisfies $\phi$ can be written in a prefix-suffix structure $\tau=\tau^{\text{pre}}[\tau^{\text{suf}}]^\omega$, where the prefix part  $\tau^{\text{pre}}=s^0 \dots s^{h_1}$ is executed once followed by the indefinite execution of the suffix part $\tau^{\text{suf}}=s^{h_1} \dots s^{h_1+h_2} s^{h_1+h_2+1}$, where $s^{h_1+h_2+1}=s^{h_1}$ \cite{baier2008principles}. We say a path $\tau$ satisfies $\phi$ if {\it (i)} the trace, defined as $\texttt{trace}(\tau):=L(s^0)\dots L(s^{h_1})[L(s^{h_1})\dots L(s^{h_1+h_2+1})]^{\omega}$  belongs to $\texttt{Words}(\phi_0)$, where $\phi_0$ is obtained by replacing all induced atomic propositions in $\phi$ with their counterparts with zero connector; {\it (ii)} it is the same $\ag{i}{j}$ that satisfy the induced atomic proposition $\ap{i}{j}{k,\chi}$ in $\phi$ with the same non-zero connector $\chi$. Not only do the satisfaction conditions take into account the collective labeling of the paths, as in {\it (i)}, but differentiate exactly which robots participate, as in {\it (ii)}. When there is no atomic proposition in $\phi$ with non-zero connector, the satisfaction condition only considers {\it (i)}, which is identical to the conventional case in Section~\ref{sec:ltl}. Now, let $\tau_{r,j} = s_{r,j}^0, s_{r,j}^1, \ldots, s_{r,j}^h$ denote a collision-free path of length $h$ for robot $[r,j]$. We define the cost of $\tau_{r,j}$  as $J(\tau_{r,j}) = \sum_{t=0}^{h-1} d(s_{r,j}^{t}, s_{r,j}^{t+1})$, where $d: S\times S \to \mathbb{R}^+\cup\{0\}$ maps a pair of free cells to the distance between them. Therefore, the cost of paths $\tau$ that combines all robot paths $\tau_{r,j}$ of length $h$ can be defined as
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}
  J(\tau) = \sum_{{r \in \ccalK_j, j \in [m]}} J(\tau_{r,j}),
\end{align}
\endgroup
For  plans written in prefix-suffix form, we get
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}\label{eq:cost}
J(\tau) = \beta J(\tau^{\text{pre}}) + (1-\beta) J(\tau^{\text{suf}}),
\end{align}
\endgroup
where $\beta\in [0,1]$ is a user-specified parameter.


Given a \ltl formula $\phi$, to find a (sub-)optimal satisfying path, we operate on the corresponding NBA $\autop = (\ccalV, \ccalE)$, which can  be constructed using the tools, such as LTL2BA developed in~\cite{gastin2001fast}; see also Fig.~\ref{fig:nba_iii} for tasks~\hyperref[task:i]{\it (i)} and~\hyperref[task:ii]{\it (ii)}. Note that the NBA in Definition~\ref{def:nba} is essentially a graph. In what follows, we refer to the NBA by the graph $\autop$ for notational convenience. For a transition $(q_B, \gamma, q'_B)\to_B$ in the NBA $\autop$, we assume that the propositional formula $\gamma$ is  in {\it disjunctive normal form} (DNF), i.e,
$ \gamma = \bigvee_{p\in \ccalP} \bigwedge_{q\in \ccalQ_p} (\neg)\ap{i}{j}{k,\chi}$, where the negation operator can only precede the atomic propositions. Note that any propositional formula has an equivalent formula in DNF~\cite{baier2008principles}. We call  $\ccalC_p^{\gamma}=\bigwedge_{q\in \ccalQ_p}(\neg) \ap{i}{j}{k,\chi}$ the $p$-th {\it clause} of $\gamma$ that includes a set $\ccalQ_p$ of positive and negative {\it literals} and each positive literal is an atomic proposition $\ap{i}{j}{k,\chi}\in \Sigma$. Let $\mathsf{cls}(\gamma)$ denote the set of clauses $\ccalC_p^{\gamma}$ in $\gamma$, and let $\mathsf{lits}^+(\ccalC_p^{\gamma})$ and $\mathsf{lits}^-(\ccalC_p^{\gamma})$ be the {\it positive subformula} and {\it negative  subformula}, respectively,  of all positive literals and all negative literals in the clause $\ccalC_p^\gamma$, which, by default, are $\top$ if the corresponding literals do not exist. Furthermore, we call the propositional formula $\gamma$ a {\it vertex label} if $q_B=q'_B$, otherwise, an {\it edge label}. In what follows, we do not consider self-loops when we refer to edges in $\autop$, since self-loops can be captured by vertices.   With a slight abuse of notation, let {$\gamma: \ccalV \to  2^\Sigma $} and {$\gamma: \ccalV \times \ccalV \to 2^\Sigma$} be the functions that map a vertex and edge in the NBA to its vertex label and edge label, respectively.
 \begin{figure}[!t]
   \centering
   \subfigure[NBA for the task {\it (i)}]{
     \label{fig:nba_i}
     \includegraphics[width=0.8\linewidth]{nba_i.pdf}}
   \subfigure[NBA for the task {\it (ii)}]{
     \label{fig:nba_ii}
     \includegraphics[width=0.6\linewidth]{nba_ii.pdf}}
   \caption{NBA for the tasks \hyperref[task:i]{\it (i)} and \hyperref[task:ii]{\it (ii)}.}
   \label{fig:nba_iii}
 \end{figure}

 \begin{cexmp}[(Key observations on the NBA)]
   The NBA corresponding to tasks \hyperref[task:i]{\it (i)} and \hyperref[task:i]{\it (ii)} are shown in Fig.~\ref{fig:nba_iii}. The vertex label is placed in the square bracket next to each vertex. In Fig.~\ref{fig:nba_i}, $\vertex{init}$ is the initial vertex and $v_6$ is the accepting vertex. Observe that all vertices have self-loops except the initial vertex $\vertex{init}$. Furthermore, each accepting run contains the initial vertex $\vertex{init}$ and the accepting vertex $v_6$. In each accepting run, the satisfaction of the label of an edge implies the satisfaction of the label, if exists, of its end vertex. For instance, the label $\ap{2}{1}{2,1} \wedge \neg\ap{2}{1}{3}$ of the edge $(v_1, v_2)$ implies the label $\neg\ap{2}{1}{3}$ of vertex $v_2$, and  the label of the edge  $(\vertex{init}, v_2)$ implies the label of  its end vertex $v_1$. This is because once the transition over the edge succeeds, the label of its end vertex should be satisfied at the next time instant, otherwise, the progression along the run is stuck.
   The same observation also applies to NBA in Fig.~\ref{fig:nba_ii} where vertex $\vertex{init}$ is both an initial and accepting vertex and $v_3$ is another accepting vertex. All vertices have self-loops except the accepting vertex $v_3$. The accepting run $\vertex{init}, v_2, v_3, (v_1, v_2, v_3)^\omega$ includes one pair of initial and accepting vertices, $(\vertex{init}, v_3)$, and the accepting run $\vertex{init}, v_2, v_1, \vertex{init}^\omega$ includes one pair of initial and accepting vertices, $(\vertex{init}, \vertex{init})$. Note that we view $\vertex{init}$'s different, one as the intial vertex and the other as the accepting vertex. Furthermore, the label $\ap{1}{1}{2,1}\wedge \ap{1}{1}{3,1}$ of the edge $(v_2, \vertex{init})$ is the same as that of its end vertex $\vertex{init}$, so are the edge $(v_1, \vertex{init})$ and its end vertex $\vertex{init}$. It is noteworthy that, even though the accepting vertex $v_3$ does not have a self-loop, the satisfaction of the label $\ap{1}{1}{2,1}$ of its incoming edge $(v_2, v_3)$ implies the label $\top$ of its outgoing edge $(v_3, v_1)$. Without this implication, the progression will be stuck at $v_3$ since the label $\ap{1}{1}{2,1} \wedge \ap{1}{1}{3,1}$ of edge $(v_3, \vertex{init})$ is infeasible.
 \end{cexmp}

 Inspired by key observations on the NBA in the Example~\ref{exmp:1}, in what follows, we first introduce the notion of implication and compatibility between two propositional formulas and based on this, we define the restricted set of accepting runs in a NBA that are in the prefix-suffix structure.
 \begin{defn}[(Implication and strong implication)]\label{defn:implication}
Given two propositional formulas $\gamma$ and $\gamma'$, we say that formula  $\gamma$ implies $\gamma'$, denoted by $\gamma \simplies \gamma'$, if for each clause $\ccalC_{p}^{\gamma} \in \clause{\gamma}$, there exists a clause $\ccalC_{p'}^{\gamma'} \in \clause{\gamma'}$ such that  $\ccalC_{p'}^{\gamma'}$ is a subformula of $\ccalC_{p}^{\gamma}$, that is, all literals appearing in $\ccalC_{p'}^{\gamma'}$ also appear in $\ccalC_{p}^{\gamma}$. By default, $\top$ is a subformula of any clause. Furthermore, formula $\gamma$ strongly implies $\gamma'$, denoted by $\gamma \simplies_s  \gamma'$, if $\gamma$ implies $\gamma'$, and for each clause $\ccalC_{p'}^{\gamma'} \in \clause{\gamma'}$, there exists a clause $\ccalC_{p}^{\gamma} \in \clause{\gamma}$ such that  $\ccalC_{p'}^{\gamma'}$ is a subformula of $\ccalC_{p}^{\gamma}$.
 \end{defn}

 Intuitively, given two propositional formulas $\gamma$ and $\gamma'$ such that $\gamma \simplies \gamma'$, robot locations that satisfy $\gamma$ lead to the satisfaction of $\gamma'$. %% In what follows, we define the compatibility between the label $\gamma$ of an edge  and the  label $\gamma'$ of its end vertex. Given a propositional formula $\gamma$, we denote by $\overline{\gamma}$ the formula  after replacing all negative literals that appear in $\gamma$ with $\top$.

  %% \begin{defn}[(Compatibility)]\label{defn:compatibility}
  %%   Given the label $\gamma$ of an edge and the  label $\gamma'$ of its end vertex, we say that formula  $\gamma$ is compatible with  $\gamma'$, denoted by $\gamma \bowtie \gamma'$, if {\it (a)} If $\overline{\gamma} \neq \top$ and $\overline{\gamma'}= \top$, then for the positive subformula $\mathsf{lits}^+(\ccalC_p^\gamma)$ of each clause $\ccalC_p^\gamma \in \mathsf{cls}(\gamma)$, there exists a clause $\ccalC_{p'}^{\gamma'} \in \gamma'$ whose negative subformula $\mathsf{lits}^-(\ccalC_{p'}^{\gamma'})$  does  not contradict this positive subformula.  The contradiction is defined in terms of a positive literal and its negative version, that is, $\ap{i}{j}{k,\chi}$  contradicts  $\neg\ap{i'}{j}{k}$ if $i' \leq i$; {\it (b)} The reverse is also true. If $\overline{\gamma} = \top$ and $\overline{\gamma'}\neq \top$, then for the positive subformula $\mathsf{lits}^+(\ccalC_{p'}^{\gamma'})$ of each clause $\ccalC_{p'}^{\gamma'} \in \mathsf{cls}(\gamma')$, there exists a clause $\ccalC_{p}^{\gamma} \in \gamma$ whose negative subformula $\mathsf{lits}^-(\ccalC_{p}^{\gamma})$  does not contradict this positive subformula; {\it (c)} If $\overline{\gamma} \neq \top$ and $\overline{\gamma'} \neq \top$, then for each clause $\ccalC_p^\gamma \in \mathsf{cls}(\gamma)$ and for each clause $\ccalC_{p'}^{\gamma'} \in \mathsf{cls}(\gamma')$, the negative subformula of the former clause does not contradict the postive subformula of the latter, and simimlarly, the negative subformula of the latter clause does not contradict the postive subformula of the former.
  %% \end{defn}
  %% In words, for each realization of the edge label $\gamma$, we can always find one realization for the vertex label $\gamma'$ without negating the label $\gamma'$, and vice versa. Intuitively, the edge label $\gamma$ should not be contradictary with the end vertex label $\gamma'$ since they need to be satisfied at two consecutive time instants, otherwise, the progression most likely gets stuck at the end vertex. Intuitively, if robot locations satisfy the edge label, they should be capable of satisfying the vertex label at the next time instant, by means of moving or remaining idle.

  %% In words, if the edge label $\gamma$ is compatible with the end vertex label $\gamma'$, $\gamma$ imposes constraints on $\gamma'$. That is,  $\gamma'$ is allowed to have positive subformulas only when $\gamma$ has positive subformulas, and for each clause in the edge label $\gamma$, the end vertex label $\gamma'$ does not contradict it.

\begin{defn}[(Restricted accepting runs)]\label{defn:run}
  Given a NBA $\autop$ that corresponds to a \ltl formula, we define the  restricted accepting run as any accepting run, in the prefix-suffix structure of $v_0, \ldots, \vertex{prior}, \vertex{accept} (\vertex{next}, \ldots, \vertex{prior}', \vertex{accept})^\omega$ (see Fig.~\ref{fig:lasso}), that meets the following conditions:
  \begin{noindlist}
    \setlength\itemsep{0em}
  \item \label{cond:a} There does not exist a  second  different vertex between any two identical vertices  in the representation  $v_0, \ldots, \vertex{prior}, \vertex{accept}$. That is, the prefix part does not return to a vertex after leaving it. Similarly, there does not exist a second different vertex  between any two identical vertices in the representation $\vertex{next}, \ldots, \vertex{prior}', \vertex{accept}$, either;
  \item \label{cond:b} There only exist one initial vertex $v_0$ and one  accepting vertex $\vertex{accept}$ in the accepting run (they can appear multiple times in a row), but different accepting runs can have different pairs of initial and accepting vertices;
 \item \label{cond:c} In the prefix part of the accepting run, only initial and accepting vertice can be allowed to have no self-loops, that is, their vertex labels  can be $\bot$, and in the suffix part,  only the accepting vertex can be allowed to have no self-loop;
 \item  \label{cond:d} For any two consecutive vertices $v_1$, $v_2$ in the accepting run, if $v_1 \neq v_2$, $v_2\neq \vertex{accept}$ and $v_2$ has a self-loop, then the edge label $\gamma(v_1, v_2)$ strongly implies    the end vertex label $\gamma(v_2)$, i.e., $\gamma(v_1, v_2) \simplies_s \gamma(v_2)$;
 \item \label{cond:e} For any three consecutive vertices $v_1, v_2$ and $v_3$ in the acceting run, if $v_2$ has a self-loop and $v_2$ is neither $v_0$ and nor $\vertex{accept}$, then either $v_1 = v_2$ or $v_2 = v_3$, that is, the label of this vertex should be satisfied at least once;
  \item \label{cond:f} For   the accepting vertex $\vertex{accept}$ in the accepting run, if $\vertex{prior} \ne \vertex{accept}$ and $\vertex{accept} \neq \vertex{next}$ (this can happen when $\vertex{accept}$  does not have a self-loop), where $\vertex{prior}$ is the vertex right before $\vertex{accept}$ in the prefix part and $\vertex{next}$ is the vertex right after $\vertex{accept}$ in the suffix part,  then, the label of the edge $(\vertex{prior}, \vertex{accept})$ implies the label of the edge $(\vertex{accept}, \vertex{next})$, i.e., $\gamma(\vertex{prior}, \vertex{accept}) \simplies  \gamma(\vertex{accept}, \vertex{next})$. At the same time, the label $\gamma(\vertex{prior}, \vertex{accept})$ implies the label of the edge $(\vertex{prior}', \vertex{accept})$ where $\vertex{prior}'$ is the vertex right before $\vertex{accept}$ in the suffix part, i.e., $\gamma(\vertex{prior}, \vertex{accept}) \simplies  \gamma(\vertex{prior}', \vertex{accept})$. Meanwhile, the label $\gamma(\vertex{prior}, \vertex{accept})$ implies the label of the vertex $\vertex{prior}'$, i.e., $\gamma(\vertex{prior}, \vertex{accept}) \simplies \gamma(\vertex{prior}')$. Note that $\vertex{prior}$ and $\vertex{prior}'$ can be different.
  \end{noindlist}

  %% (d)\label{cond:d}  If the accepting vertex $\vertex{accept}$ in the accepting run does not have a self-loop, then, the label of the edge $(\vertex{prior}', \vertex{accept})$ where $\vertex{prior}'$ is the vertex right before $\vertex{accept}$ in the prefix part, implies the label of the edge $(\vertex{accept}, \vertex{next})$ where $\vertex{next}$ is a vertex right after $\vertex{accept}$ in the suffix part, i.e., $\gamma(\vertex{prior}', \vertex{accept}) \simplies  \gamma(\vertex{accept}, \vertex{next})$.
  %% the establishment of ``$\simplies$'' also requires that, for any clause of  $\gamma(\vertex{accept}, \vertex{next})$,  all literals with non-zero connectors appearing in this clause appear in a single clause of $\gamma(\vertex{prior}, \vertex{accept})$.   Meanwhile, $\gamma(\vertex{prior}', \vertex{accept})$ also implies the label of vertex $\vertex{next}$, i.e., $\gamma(\vertex{prior}', \vertex{accept}) \simplies  \gamma(\vertex{next})$. At the same time, the label $\gamma(\vertex{prior}', \vertex{accept})$ implies the label of the edge $(\vertex{prior}, \vertex{accept})$ where $\vertex{prior}$ is the vertex right before $\vertex{accept}$ in the suffix part, i.e., $\gamma(\vertex{prior}', \vertex{accept}) \simplies  \gamma(\vertex{prior}, \vertex{accept})$. Note that $\vertex{prior}$ and $\vertex{prior}'$ can be different; see Fig.~\ref{fig:lasso}.
 \end{defn}

\begin{figure}[t]
  \centering
  \includegraphics[width=0.7\linewidth]{lasso.pdf}
  \caption{Graphical depiction of prefix-suffix structure when $\vertex{accept}$ does not have a self-loop, which resembles a lasso. The shaded blue line and the orange loop represent the prefix and suffix part, respectively. The arrow indicates the progression direction. The gray circles indicate the self-loops.}
  \label{fig:lasso}
\end{figure}

The set of restricted accepting runs is not restrictive, since these  conditions in Definition~\ref{defn:run} can be met by many accepting runs in the NBA for temporal logic tasks in the robotics application, such as coverage, sequencing, recurrent sequencing and so on.
      For condition~\hyperref[cond:a]{\it a)}, the cycle segment is redundant if the run traverses back after leaving it. In Section~\ref{sec:solution} and~\ref{sec:solution2mrta}, we remove such cases from our solutions.
      For condition~\hyperref[cond:b]{\it b)}, the definition of the accepting run in Section~\ref{sec:ltl} is based on a pair of initial and accepting vertices. In Section~\ref{sec:app}, we will extract the sub-NBA from the NBA $\autop$ for each pair of iniital and accepting vertices, reducing the complexity of the sub-NBA.

      For condition~\hyperref[cond:c]{\it c)}, if a vertex does not have a self-loop, then one of its incoming edge labels  and one of outgoing edge labels  should be enabled at two consecutive time instants. For instance, observing edges $(v_2, v_3)$ and $(v_3, v_2)$, subformula $\ap{1}{1}{2,1}$ should be satisfied right after $\ap{1}{1}{3,1}$, which means a robot  should visit region $\ell_2$ at the next instant while staying at $\ell_3$ right now. These subtasks can be represented by LTL subformula $\Diamond(\ap{1}{1}{3,1} \wedge  \bigcirc \ap{1}{1}{2,1})$. This temporal property is not in align with the semantics of temporal operators like $\ccalU$, $\Diamond$ and $\square$. Based on condition \hyperref[cond:c]{\it c)}, we will remove some vertices without self-loops from the NBA in Section~\ref{sec:prune}, further reducing its complexity.

      Moreover, condition \hyperref[cond:d]{\it d)} is similar to~\hyperref[cond:c]{\it (c)} in the sense that  the satisfaction of the edge label $\gamma(v_1, v_2)$ should faciliate the satisfaction of the end vertex label $\gamma(v_2)$, since the end vertex label need to be satisfied immediately after the edge label. Furthermore, in Section~\ref{sec:app} and~\ref{sec:solution}, we will first consider a relaxed NBA where all negative literals are ignored, and then re-consider negative literals in Section~\ref{sec:solution2mrta}. The condition \hyperref[cond:d]{\it d)} ensures that the plan obtained by only considering the positive subformulas can be modified to accomadate the ignored negative subformula by preventing the mutual exclusions between positive and negative subformulas.

      Condition~\hyperref[cond:e]{\it e)} implies that the label (if not $\bot$) of each vertex (except $v_0$ and $\vertex{accept}$) that appears in the accepting run should be satisfied at least once, which can be easily met by condition~\hyperref[cond:d]{\it d)} if robots remain idle after satisfying the incoming edge labels. This occurs frequently since it takes time to satisfy the outgoing edge labels in the robotics applications  such as coverage, and the progression should remain at vertices until  outgoing edges are enabled. We exclude $v_0$ and $\vertex{accept}$ since the initial robot locations can satisfy some outgoing edges of $v_0$ and $\vertex{accept}$ directly when dealing with the prefix and suffix parts separately. Based on this, in Section~\ref{sec:solution}, we synthesize a high-level plan that enables every vertex label in a path that connects $v_0$ and $\vertex{accept}$.

      Finally, prefix and suffix parts of an accepting run can be addressed separately based on condition~\hyperref[cond:f]{\it f)}, since  $\gamma(\vertex{prior}, \vertex{accept}) \simplies  \gamma(\vertex{accept}, \vertex{next})$  ensures that in Section~\ref{sec:suf} the final robot locations of the satisfying path for  the prefix part can transition seamlessly to the suffix part of the accepting run. Otherwise, the progression may get stuck since these two edge labels need to be satisfied at two consecutive time instants. Also, since the suffix part of a satisfying path is a loop, robots need to return to the initial locations of the suffix part, which are also  finial locations of the prefix part, after finishing one round of the suffix part, the implications $\gamma(\vertex{prior}, \vertex{accept}) \simplies  \gamma(\vertex{prior}', \vertex{accept})$ and $\gamma(\vertex{prior}, \vertex{accept}) \simplies \gamma(\vertex{prior}')$ mean that the initial locations of the suffix part satisfies the labels $ \gamma(\vertex{prior}')$ and $\gamma(\vertex{prior}', \vertex{accept})$, which ensures that robots can travel back to initial locations of the suffix part  to make trajectories loops and at the same time, drive the transition in the NBA $\autop$ back to the accepting vertex to make the suffix part of the accepting run  a loop.



%% \begin{cexmp}[(Accepting runs)]
%%   In Fig.~\ref{fig:nba_i}, all accepting runs that connect $v_{\text{init}}$ and $v_6$ meet the four conditions~\hyperref[cond:b]{\it b)}, \hyperref[cond:c]{\it c)}, \hyperref[cond:d]{\it d)} and \hyperref[cond:f]{\it f)} in Definition~\ref{defn:run}. In particular, there is only one pair of initial and accepting vertices in $\autop$, and only the initial vertex $\vertex{init}$ which appears in the prefix part of any accepting run does not have a self-loop. Therefore, conditions \hyperref[cond:b]{(b)} and \hyperref[cond:c]{\it c)} hold.  The vertex labels are  $\top$ after replacement. Condition \hyperref[cond:c]{\it c)} in Definition~\ref{defn:compatibility} is met since there exists a  negative subfomrula in every vertex label does not contradict every positive subformulas in its incoming edge label, thus, condition \hyperref[cond:d]{\it d)} is met. Since the only accepting vertex $v_6$ has a self-loop with label $\top$, condition \hyperref[cond:f]{\it f)} is met. As for condition \hyperref[cond:e]{\it e)} in Definition~\ref{defn:run}, it can be easily met since for each vertex, the satisfaction of the incoming edge labels leads to the satisfaction of the vertex label.

%%   In Fig.~\ref{fig:nba_ii}, there are two pairs of initial and accepting vertices, $(\vertex{init}, \vertex{init})$ and $(\vertex{init}, v_3)$. When considering the pair $(\vertex{init}, \vertex{init})$,  $v_3$ should be excluded base on condition \hyperref[cond:b]{(b)}. All accepting runs consist of vertices $\vertex{init}, v_1$ and $v_2$ meet conditions \hyperref[cond:c]{\it c)}, \hyperref[cond:d]{\it d)} and \hyperref[cond:f]{\it f)}. Since vertices $\vertex{init}, v_1$ and $v_2$ have self-loops, condition \hyperref[cond:c]{\it c)} holds. Since there is no negative subformulas in the NBA, condition \hyperref[cond:d]{\it d)}  holds. Furthermore, both $\vertex{prior}$ and $\vertex{prior}'$ can be $v_1$ or $v_2$. Since $\gamma(v_1, \vertex{init})=\gamma(v_2, \vertex{init}) = \ap{1}{1}{2,1} \wedge \ap{1}{1}{3,1}$, $\gamma(\vertex{prior}, \vertex{init}) \simplies  \gamma(\vertex{prior}', \vertex{init})$. Both $\gamma(v_1)$ and $\gamma(v_2)$ are $\top$, thus, $\gamma(\vertex{prior}, \vertex{init}) \simplies  \gamma(\vertex{prior}')$. Furthermore, $\vertex{next}$ can be $v_1, v_2$ or $\vertex{init}$ and thus, $\gamma(\vertex{accept}, \vertex{next})$ is $\ap{1}{1}{2,1}, \top$ or $\ap{1}{1}{2,1} \wedge \ap{1}{1}{3,1}$, all of  which are implied by $\gamma(\vertex{prior}, \vertex{init})$. Therefore, condition \hyperref[cond:f]{\it f)} is met.  Since for vertices $\vertex{init}, v_1$ and $v_2$, the satisfaction of incoming edge labels leads to the satisfaction of the vertex labels, condition \hyperref[cond:e]{\it e)} can be easily  met.



%%   Considering the accepting runs related to the pair $(\vertex{init}, v_3)$, we treat all $\vertex{init}$ appearing in the run  as  the initial vertex, thus condition \hyperref[cond:b]{(b)} is met. Condition \hyperref[cond:c]{\it c)}, \hyperref[cond:d]{\it d)} and \hyperref[cond:e]{\it e)} are met as before. In order to meet the condition \hyperref[cond:f]{\it f)},  the accepting run  should not include edges $(v_3, v_2)$ and $(v_3, \vertex{init})$ in their suffix parts, since the only incoming edge label $\ap{1}{1}{2,1}$ of $v_3$ does not imply these two edge labels.   Observe that when in an accepting run, $v_2$ acts as both $\vertex{prior}$ and $\vertex{prior}'$ and $v_1$ acts as $\vertex{next}$, we have that $\gamma(v_2, v_3) \simplies \gamma(v_3, v_1)$, $\gamma(v_2, v_3) \simplies \gamma(v_2)$ and apparently $\gamma(v_2, v_3) \simplies \gamma(v_2, v_3)$. Hence, condition \hyperref[cond:f]{\it f)} is met.  Note that these excluded  accepting runs from the restricted set that pass edges $(v_3, v_2)$ or $(v_3, \vertex{init})$  are not able to provide physical solutions since the label $\ap{1}{1}{2,1} \wedge \ap{1}{1}{3,1}$ of edge $(v_3, \vertex{init})$ is infeasbile and the label of edge $(v_3, v_2)$ requires the same robot visit region $\ell_3$ at the next time instant starting from $\ell_2$. Based on Fig.~\ref{fig:workspace}, this is impractical. Therefore, the restricted set of accepting runs does not lose any  meaningful accepting runs.


%% \end{cexmp}
We highlight that the definition of the restricted set of accepting runs only takes into account the structrue of the  NBA and logical relations. Whether an accepting run within the restricted set is realizable by the physical environment is beyond the scope of the definition.
Next, we make an assumption regarding the satisfaction of edge labels and vertex labels in an accepting run incurred by a satisfying path.
\begin{asmp}[(Same robots satisfying the same clause)]\label{asmp:same}
  Given a discrete environment $E$, the initial robot configurations and the specification $\phi$, if a satisfying path incurs a restricted accepting run, then we assume that (a)\label{asmp:a} every time the label of a vertex is satisfied, it is always the same clause in the vertex label that is satisfied; (b)\label{asmp:b} the satisfied clause in an edge label  implies the  satisfied clause in the label of its end vertex if the end veretex is not the accepting vertex and (c)\label{asmp:c} it is the same fleet of robots that satisfy the  postivie subformula of the clause in the vertex label  and the positive formula of the clause in its incoming edge label.
\end{asmp}

Assumption~\ref{asmp:same} can be easily met by restricted accepting run. Specifically, by condition~\hyperref[cond:a]{\it a)} in the Definition~\ref{defn:run}, each vertex in a restrcited accepting run can only be visited within a consecutive time period.  Once locations of a fleet of robots satisfy a  vertex label, they can remain idle to maintain the satisfaction of the same clause in the label, meeting the condition~\hyperref[asmp:a]{(a)}. Furthermore, by condition~\hyperref[cond:d]{\it d)} in the Definition~\ref{defn:run}, the label of an edge implies the label of its end vertex if the end vertex is not the accepting vertex. Thus, once locations of a fleet of  robots satisfy an edge label, they can remain idle at the next time instant, leading to the satisfaction of the clause in the vertex label that the satisfied clause in the edge label implies. Thus, conditions~\hyperref[asmp:b]{(b)} and~\hyperref[asmp:c]{(c)} are met. Finally, based on  the restricted accepting runs and Assumption~\ref{asmp:same}, the problem addressed in this paper is defined as follows.



\begin{problem}\label{prob:1}
Considering a team of $n$ robots of $m$ types that work in a discrete environment with labeled regions and obstacles, and a valid \ltl specification $\phi$ for which the  set of restricted accepting runs is non-empty. Furthermore, assuming a satisfying path exists that incurs a restricted  accepting run  and meets the Assumption~\ref{asmp:same}, plan a collision-free path for each robot such that $\phi$ is satisfied and the sum of the path costs in~\eqref{eq:cost} is minimized.
\end{problem}

We refer to Problem~\ref{prob:1} as multi-robot task allocation under LTL specifications, in short, LTL-MRTA, which is a single-task robot and multi-robot task (ST-MR) problem, where a robot is capable of one task and a task may require multiple robots. Since the ST-MR problem is NP-hard~\cite{korsah2013comprehensive,nunes2017taxonomy}, so is the LTL-MRTA problem. Consequently, an exact method will be impractical for large-scale applications. In what follows, we propose an approximate method to solve LTL-MRTA efficiently.

\begin{rem}
The proposed method in Section~\ref{sec:app} and~\ref{sec:solution2mrta} is not limited to  LTL$_{-\bigcirc}$ formulas. It can also be applied to  formulas that include ``next'' operator but have non-empty restricted set of accepting runs, such as $\Diamond(\ap{1}{1}{2,1} \wedge \bigcirc (\ap{1}{1}{2,1} \,\ccalU\, \ap{1}{2}{2}))$ and $\Diamond (\ap{1}{1}{2}  \wedge \bigcirc \Diamond \ap{1}{2}{2})$.
\end{rem}

\subsection{Outline of the LTL-MRTA Algorithm}
%% { \begin{algorithm}[t]
%%       \caption{Outline of the LTL-MRTA Algorithm}
%%       \LinesNumbered
%%       \label{alg:frame}
%%       \KwIn {workspace $\ccalW$,  robot team $\{\ccalK_j\}$\\ \quad \quad \quad
%%        \ltl formula $\phi$}
%%       Translate $\phi$ into a NBA $B_o$ \label{frame:nba}\Comment*[r]{\ref{sec:prune}}
%%       Prune $B_o$ and do replacing to get $B_r$ \label{frame:prune}\Comment*[r]{\ref{sec:prune}}
%%       Sort pairs of initial and accepting vertices in ascending order by the total length\label{frame:sort} \Comment*[r]{\ref{sec:pregraph}}
%%       \For{each pair in the sorted order}{
%%         \Comment*[r]{Find robot prefix paths}
%%         Extract the sub-NBA $B_s$\ and prune $B_s$ \label{frame:sub-NBA}\Comment*[r]{\ref{sec:pregraph}}
%%         Extract subtasks from $B_s$ and infer the poset with the largest width \label{frame:poset}\Comment*[r]{\ref{sec:poset}}
%%         Build the MILP graph; see also Alg.~\ref{alg:milpgraph} \label{frame:milpgraph}\Comment*[r]{\ref{sec:graph}}
%%         Formulate the MILP and solve it \label{frame:milp} \Comment*[r]{\ref{sec:milp}}
%%         Extract high-level plans  \label{frame:path} \Comment*[r]{\ref{sec:path}}
%%         Identify the accepting run in $B_r$ \label{frame:run} \Comment*[r]{\ref{sec:run}}
%%         Solve generalized  multi-robot path planning to obtain executable paths\label{frame:mapp} \Comment*[r]{\ref{sec:mapp}-\ref{sec:solution2mapp}}
%%         \Comment*[r]{Find robot suffix paths
%%         }
%%         Repeat lines~\ref{frame:sub-NBA}-\ref{frame:mapp} \label{frame:suffix} \Comment*[r]{\ref{sec:suf}}
%%       }
%% Select the plan with the lowest cost according to~\eqref{eq:cost} \label{frame:cost}
%%  \end{algorithm}}
 \begin{figure*}[!t]
   \centering
\includegraphics[width=\linewidth]{overview.pdf}
   \caption{Schematic overview of the proposed method.  The first 5 boxes correspond to the relaxation stage and the last two constitute the correction stage.}
\label{fig:overview}
 \end{figure*}
     {The schematic overview of our proposed  method is shown in Fig.~\ref{fig:overview}, which consists of relaxation and correction stages.  The adoption of this relaxation-and-correction scheme comes from the observation that MILP formulation is a well-studied approach in the literatute of task allocation and  vehicle routing problems and there are also powerful  multi-robot path planning methods in the existing work. To leverage the formulation of MILP, we first ignore the negative literals in the NBA $\autop$ and the collision avoidance among robots. In this way, temporal relations among subtasks can be better exploited  and existing work on vehicle routing problems can inspire scalable techniques to solve the allocation of subtasks; and then the negative literals and collision avoidance is considered in the low-level executable path generation by leveraging the state-of-art multi-robot plath planning techniques.

       Specifically, the first stage is referred to as the {\it relaxation} stage, which produces a high-level plan that abstracts out negative literals appearing in the NBA and low-level collision avoidance among robots; see also the first 5 blocks inside the orange box in~Fig.~\ref{fig:overview}. To this end, we first prune the NBA by deleting infeasible transitions and remove  the negative atomic propositions in the NBA corresponding to the formula $\phi$ so that the satisfaction of the transitions (referred to also as subtasks) in the relaxed NBA requires multi-robots to visit certain regions; see Section~\ref{sec:prune}. Then we extract a sub-NBA, corresponding to a pair of initial and accepting states, from the relaxed NBA that covers at many transitions as possible; see Section~\ref{sec:pregraph}, Next, by associating each transition in the sub-NBA with a subtask, we extract a set of subtasks from the sub-NBA and infer the temporal relation by mining a set of posets; see Section~\ref{sec:poset}. What follow are the construction of the routing graph that captures the regions that robots need to visit to satisfy the subtasks and the temporal order of the visitation; see Sections~\ref{sec:graph}, and the formulation of a MILP based on the vehicle routing problem; see Section~\ref{sec:milp}. In this way, a high-level plan  provides a sequence of regions that each robot needs to visit in order; see Section~\ref{sec:path}. Next, as shown in the last 2 blocks inside the green box in Fig.~\ref{fig:overview}, the {\it correction} stage follows  where the high-level plan is adjusted and concretized to be low-level executable paths by solving a sequence of generalized multi-robot path planning problems that account for the collision avoidance and the satisfaction of the  original specification; see Section~\ref{sec:solution2mrta}.

   \red{On the other hand, similar to~\cite{sahin2019multi}, we adopt a hierarchical approach which first searches for an abstract high-level plan that indicates the sequence of regions that robots should visit in a proper order and then implementing the plan by finding low-level paths between consecutive regions in the plan. However, our work differs from~\cite{sahin2019multi} in the way how the high-level plans  and   executable paths are generated. More significantly,~\cite{sahin2019multi} stops with a feasible plan while we end up with a plan with better quality.}


\section{Extracting Subtasks and Infer the Temporal Order from the NBA}\label{sec:app}
     In this section, our goal is to extract a set of subtasks from the NBA that corresponds to the specification and then infer the temporal order, sequential or simultaneous, among these subtasks, which corresponds to blocks 1 and 2 in Fig.~\ref{fig:overview}.
\subsection{{Pruning and relaxation of the NBA}}\label{sec:prune}

We begin with pruning and relaxing the NBA $\autop$. Given a NBA $\autop$, the following initial steps are taken to prune $\autop$ by simplifying transitions and removing infeasible transitions. Since in Section~\ref{sec:subtask} we will introduce the notion of subtasks based on edges in the NBA, pruning can reduce the number of subtasks that need to be considered.
We denote by $\autop^-$ the resulting NBA. In particular, for every vertex label or edge label $\gamma$ in $\autop$:
%\begin{noindlist}
\paragraph{1) Mutual exclusion in $\mathsf{lits}^+(\cp{p}{\gamma})$:}\label{prune:exclusion1} We delete the clause $\cp{p}{\gamma} \in \mathsf{cls}(\gamma)$ (replacing it with $\bot$) if there exist two positive literals $\ap{i}{j}{k,\chi}, \ap{i}{j}{k',\chi} \in \mathsf{lits}^+(\cp{p}{\gamma})$ such that $k\not= k'$ and $\chi\not=0$, since the same group of robots cannot be at different regions at the same time.
 \paragraph{2) Mutual exclusion in $\mathsf{lits}^+(\cp{p}{\gamma})$  and $\mathsf{lits}^-(\cp{p}{\gamma})$:} \label{prune:exclusion2} We delete the clause $\cp{p}{\gamma} \in \mathsf{cls}(\gamma)$ (replacing it with $\bot$) if there exist a positive literal $\ap{i}{j}{k,\chi} \in \mathsf{lits}^+(\cp{p}{\gamma})$ and a negative literal $\neg \ap{i'}{j}{k} \in \mathsf{lits}^-(\cp{p}{\gamma})$ such that $i' \leq i$ since they are mutually  exclusive.
 \paragraph{3) Absorption in $\mathsf{lits}^+(\cp{p}{\gamma})$:} \label{prune:absorption1} For each clause $\cp{p}{\gamma} \in \clause{\gamma}$, we delete the positive literal $\ap{i}{j}{k,\chi} \in \mathsf{lits}^+(\cp{p}{\gamma})$ (replacing it with $\top$), if another $\ap{i'}{j}{k,\chi'} \in \mathsf{lits}^+(\cp{p}{\gamma})$ exists such that $i' \geq i$ and $\chi=0$, since if $\ag{i'}{j}$ are at region $\ell_k$, that is, $\ap{i'}{j}{k,\chi'}$ is true, so is  $\ap{i}{j}{k,\chi}$.%% \endnote{\blue{Action is not taken when $\chi\not=0$.}}
 \paragraph{4) Absorption in $\mathsf{lits}^-(\cp{p}{\gamma})$:} \label{prune:absorption2} Similarly, we delete the negative literal $\neg \ap{i}{j}{k} \in \mathsf{lits}^-(\cp{p}{\gamma})$ (replacing it with $\top$), if another $\neg \ap{i'}{j}{k} \in \mathsf{lits}^-(\cp{p}{\gamma})$ exists such that $i' < i$.
        %% \blue{\subsubsection{Violation of team size} \label{prune:2}  For each clause $\cp{p}{\gamma} \in \clause{\gamma}$, let $\ap{i_m}{j}{k,\chi}$ denote the literal in $\mathsf{lits}^+(\cp{p}{\gamma})$ that directs the largest number of robots, denoted by $i_m(j,k)$, of type $j$ to visit region $\ell_k$ for given $j$ and $k$, compared to all other positive literals in $\mathsf{lits}^+(\cp{p}{\gamma})$ for the same $j$ and $k$. We delete the clause $\cp{p}{\gamma}$ (replacing it with $\bot$) if the required number of robots of the same type exceeds the team size, i.e., if there exists $j\in[m]$ such that $ \sum_{k\in[l]}   i_m(j,k) > |\ccalK_{j}|$.}
       \paragraph{5) Violation of team size:} \label{prune:violation1}  For each clause $\cp{p}{\gamma} \in \clause{\gamma}$, let $\mathsf{lits}^+(j')$ denote literals in $\mathsf{lits}^+(\cp{p}{\gamma})$ that involve robots of type $j'$, i.e., $\mathsf{lits}^+(j') = \{\ap{i}{j}{k,\chi} \in \mathsf{lits}^+(\ccalC_p^\gamma): j = j'\}$. We delete the clause $\cp{p}{\gamma}$ (replacing it with $\bot$) if the required total number of robots of the same type exceeds the provided number, i.e., if there exists $j\in[m]$ such that $ \sum_{\ap{i}{j}{k,\chi}\in\mathsf{lits}^+(j)}   i > |\ccalK_{j}|$.
       \paragraph{6) Violation of region size:} \label{prune:violation2} Similarly, for each clause $\cp{p}{\gamma} \in \clause{\gamma}$, let $\mathsf{lits}^+(k)$ denote literals in $\mathsf{lits}^+(\cp{p}{\gamma})$ that involve region $\ell_{k}$. We delete the clause $\cp{p}{\gamma}$ (replacing it with $\bot$) if the required total number of robots  visiting region $\ell_{k}$ exceeds the number of free cells it covers, i.e., if there exists $k\in[l]$ such that $ \sum_{\ap{i}{j}{k,\chi}\in\mathsf{lits}^+(k)}   i > |\ell_k|$.
       \paragraph{7) Infeasible transitions:} \label{prune:infeasible} We delete all edges associated with $\bot$ label, that is, they cannot be enabled.  We also delete all vertices without self-loops except the initial and accepting vertices, which is justified by condition \hyperref[cond:c]{\it c)} in Definition~\ref{defn:run}. Furthermore, by condition~\hyperref[cond:d]{\it d)}, we delete any edge if its edge label does not strongly implies (according to Definition~\ref{defn:implication}) its end vertex label if the end vertex is not the accepting vertex. Finally, we delete every vertex, except the initial vertex, that cannot be reached by other vertices.
%\end{noindlist}

       It is worthy of noting that  this pruning process does not compromise any feasible solutions  to Problem~\ref{prob:1}, as shown in Proposition~\ref{prop:prune} in Section~\ref{sec:correctness}. Given the pruned NBA $\autop^-$, we further relax it by replacing each negative literal in vertex or edge labels with $\top$. Let $\auto{relax}$ denote the relaxed NBA. Note that $\auto{relax}$ is graphically equivalent to $\autop^-$, thus, there is one-to-one correspondence between labels in $\auto{relax}$ and $\autop^-$. For the rest of the paper, given a concept in any NBA, e.g., $\auto{relax}$,  that is obtained from $\autop^-$, we denote by $(\cdot)_\phi$ its counterpart in $\autop^-$. For instant, for a vertex or edge label $\gamma$ in $\auto{relax}$, we denote by $\gamma_\phi$ the corresponding label in $\autop^-$ (including the negative literals). When the specification $\phi$ does not involve negative atomic propositions, we have that $\auto{relax} = \autop^-$.       Furthermore, proposition~\ref{prop:inclusion} states that the language accepted by $\autop^-$ is included in the language accepted by $\auto{relax}$, so we do not remove feasible solutions to Problem~\ref{prob:1}, either. In other words, $\auto{relax}$ is an over-approximation of $\autop^-$. This is why the correction stage in Section~\ref{sec:solution2mrta} is reguired to modify the solution obtained from $\auto{relax}$ in order to satisfy $\autop^-$.

\begin{figure}
  \centering
  \subfigure[$\auto{relax}$ for task {\it (i)}]{
    \includegraphics[width=0.5\linewidth]{nba_i_relax.pdf}\label{fig:nba_i_relax}}
   \subfigure[$\auto{relax}$ for task {\it (ii)}]{
    \includegraphics[width=0.35\linewidth]{nba_ii_prune.pdf}\label{fig:nba_ii_prune}}
   \caption{The relaxed NBA $\auto{relax}$ for tasks~\hyperref[task:i]{\it (i)} and~\hyperref[task:ii]{\it (ii)}.}
   \label{fig:relax}
\end{figure}


\begin{cexmp}[(Pruning and relaxation of the NBA $\autop$)]
   The pruned NBA $\autop^-$ of the NBA  for the task \hyperref[task:i]{\it (i)} is the same as its orignal NBA in Fig.~\ref{fig:nba_i}. The relaxed NBA $\auto{relax}$ is shown in Fig.~\ref{fig:nba_i_relax}. The pruned NBA $\autop^-$ for the task \hyperref[task:ii]{\it (ii)} is the same as the relaxed NBA $\auto{relax}$ which is shown in Fig.~\ref{fig:nba_ii_prune}. Particularly, $\auto{relax}$  is obtained from $\autop$ in Fig.~\ref{fig:nba_ii} by removing edges $(v_1, \vertex{init}), (v_2, \vertex{init}),  (v_3, \vertex{init})$ and replacing $\gamma(\vertex{init})$ with $\bot$.
\end{cexmp}



  \subsection{Extraction of sub-NBA \upshape  $\auto{subtask}$ {\it from} $\auto{relax}$}\label{sec:pregraph}
  In  this section, we first introduce the notion of subtasks, and then exploit the structure of these high-level plans by decomposing the graph $\auto{relax}$ into sub-NBA such that each sub-NBA corresponds to one pair of sorted initial and accepting vertices (see also block 1 in Fig.~\ref{fig:overview}), and  extracting subtasks and their temporal order  from these sub-NBA in the next Section~\ref{sec:poset}.
\subsubsection{Subtasks:}\label{sec:subtask}
Consider an edge $e = (v_1, v_2) $  and its starting vertex $v_1$ in the NBA $\auto{}$, which can be $\autop^-$ or $\auto{relax}$.  Assume that the current vertex of $\auto{}$ is $v_1$. To transition to $v_2$, certain robots need to simultaneously reach certain regions to make $\gamma(v_1, v_2)$ true, while maintaining  $\gamma(v_1)$ true en route. We assume that the transition to $v_2$ occurs immediately once $\gamma(v_1, v_2)$ becomes true. Based on this interpretation, we formally define the subtask below.
\begin{defn}[(Subtask)]\label{defn:subtask}
 {A subtask is equivalent to an edge $(v_1, v_2)$ in the NBA $\auto{}$.}
\end{defn}

The goal of this subtask is to generate a transition leading to vertex $v_2$. Informally speaking, an edge $e$ in $\auto{}$ captures a subtask that specifies a set of \textit{target regions} that should be visited by robots of certain types. Subtasks can be viewed as generalized reach-avoid tasks where  specific types of robots are driven to desired target regions (the "reach" part of the task) while satisfying the vertex label along the way (the "avoid" part of the task. Avoidance here is defined in a more general way compared to the conventional definition that requires robots to stay away from given regions in space). Note that it is the label of the starting vertex $v_1$ and the label of the edge $(v_1, v_2)$ that define the subtask.
Next we give  the notion of equivalent subtasks.
\begin{defn}[(Equivalent subtasks)]\label{defn:eq}
 Subtasks $(v_1, v_2)$ and $(v'_1, v'_2)$ in a NBA $\auto{}$ are equivalent, denoted by $(v_1, v_2) \sim (v'_1, v'_2)$, if $\gamma(v_1) = \gamma(v'_1)$, $\gamma(v_1, v_2)=\gamma(v_1', v'_2)$ and they  are not in the same path that connects a pair of initial and accepting vertices.
\end{defn}

 The last condition in Definition~\ref{defn:eq} is necessary since two subtasks in the same path mark different progress towards task completion, even if they have identical labels.
\begin{cexmp}[(Subtasks)]
  The relaxed NBA  $\auto{relax}$ captures high-level plans that are composed of subtasks that need to be satisfied in specific orders to reach the accepting vertex. For instance, the path $\vertex{init}, v_1, v_4, v_3, v_6$ in Fig.~\ref{fig:nba_i_relax} represents a high-level plan where first $\langle1,2\rangle$ visit region $\ell_4$, then $\langle2,1\rangle$ visits region $\ell_2$ and finally the same two robots of type 1 visit region $\ell_3$. By the interpretation of task \hyperref[task:i]{\it (i)}, the temporal order between these subtasks specifies that the time when $\langle1,2\rangle$ visits region $\ell_4$ is independent from the time when $\langle2,1\rangle$ visit region $\ell_2$, and that $\langle1,2\rangle$ visiting region $\ell_4$ and $\langle2,1\rangle$  visiting region $\ell_2$ should occur prior to $\langle2,1\rangle$ visiting region $\ell_3$.
\end{cexmp}

In the rest of Section~\ref{sec:app} and in Section~\ref{sec:solution}, we focus on the relaxed NBA $\auto{relax}$ and design high-level plans that ignore collision avoidance between robots and only specify the sequence of regions that the robots should visit and the corresponding timing. Efforts to exploit the high-level plans embedded in the NBA can be found in~\cite{xluo_CDC19,camacho2017non,camacho2019ltl}. For example,~\cite{xluo_CDC19} extracts subtasks from a NBA that can be used to synthesize plans fast for new LTL formulas. On the other hand,~\cite{camacho2017non} converts temporal planning problems to standard planning problems by defining actions based on the transitions in the NBA. Finally,~\cite{camacho2019ltl} converts formal languages to reward machines that capture the structure of the task to be used for reinforcement learning.




%% \subsubsection{Revisit of the prefix-suffix structure of accepting runs}\label{sec:presuf}
%% \blue{Recall in Section~\ref{sec:ltl} that the prefix part connects an initial vertex $v_0$ to an accepting vertex $\vertex{accept}$, and the suffix part connects the accepting vertex $\vertex{accept}$ to itself. In what follows, assisted by Fig.~\ref{fig:lasso}, we discuss the prefix-suffix structure of accepting runs in the NBA $\auto{relax}$ in two cases based on the presence or absence of the vertex label of  $\vertex{accept}$.
%%   \domanda{(i) Presence of \upshape$\gamma(\vertex{accept})$}\label{sec:presence} If the robots reach locations that drive the transition in NBA $\auto{relax}$ to the accepting vertex $\vertex{accept}$ with $\gamma(\vertex{accept})\neq\bot$ and remain idle thereafter, the suffix part of the accepting run of $\auto{relax}$ only contains $\vertex{accept}$; see Fig.~\ref{fig:lasso}.
%%   \domanda{(ii) Absence of \upshape $\gamma(\vertex{accept})$}\label{sec:absence} For the suffix part, not only do the transitions in the NBA $\auto{relax}$ occur along a cycle around $\vertex{accept}$, but also robots need to travel back to some locations to make their trajectories loops, thus, synchronizing and restarting the inifite execution. Let $v_{\text{prior}}$ and $v_{\text{next}}$ denote the vertices that right before and after $v_{\text{acccept}}$ in a cycle around $\vertex{accept}$, and $v'_{\text{prior}}$ denote the vertex right before $\vertex{accept}$ in the prefix part; see also Fig.~\ref{fig:lasso}. If  the edge label $\gamma(\vertex{accept}, v_{\text{next}})$ in $\auto{relax}$ is not $\top$, then robots need to satisfy $\gamma(\vertex{accept}, v_{\text{next}})$ immediately after the satisfcatoin of the edge label $\gamma(v'_{\text{prior}}, \vertex{accept})$ (due to $\gamma(\vertex{accept}) = \bot$) and further satisfy the vertex label $\gamma(v_{\text{next}})$ at the next time instant. Thus, if these two edges are addressed separately such that one is considered when designing the prefix plan and  the other is considered  when desinging the suffix plan, it is possible that robots can not visit regions that satisfy $\gamma(\vertex{accept}, v_{\text{next}})$ immediately after the satisfaction of $\gamma(v'_{\text{prior}}, \vertex{accept})$ and further $\gamma(v_{\text{next}})$ at the next time instant. That is, the termination of the prefix part cannot successfully transition to the activation of the suffix part.  The same issue occurs to the case where one round of cycle ends up at $\vertex{accept}$ and the the satisfaction of $\gamma(v_{\text{prior}}, \vertex{accept})$ might not lead to the satisfaction of $\gamma(\vertex{accept}, v_{\text{next}})$. To overcome this issue, we extend the prefix plan and let the last part of the prefix plan drive the transition one step further to $v_{\text{next}}$ and the final locations of the prefix plan satisfy its vertex label $\gamma(v_{\text{next}})$; see also the shaded prefix plan in Fig.~\ref{fig:lasso}, In this way, the prefix part and the cycle partially overlap.}

%%   %% first need to satisfy $\gamma(\vertex{accept}, v_{\text{next}})$ immediately after the satisfcatoin of the edge label $\gamma(v_{\text{prior}}, \vertex{accept})$ (due to $\gamma(\vertex{accept}) = \bot$) when they are about to finish one round along the cycle, and what's more, they also need to travel back to initial locations of the suffix part, i.e., final locations of the prefix part that drives the transition to the accepting state $\vertex{accept}$, to close the trajectory loop and synchronize. However, the issue is that it is possible that robots can not visit regions that satisfy $\gamma(\vertex{accept}, v_{\text{next}})$ immediately after the satisfaction of $\gamma(v_{\text{prior}}, \vertex{accept})$ if they are addressed . Even so, travelling back to initial locations might violate the vertex label $\gamma(v_{\text{next}})$. To overcome this issue, we extend the prefix plan and let the last part of the prefix plan drive the transition one step further to $v_{\text{next}}$ and the final locations of the prefix plan satisfy its vertex label $\gamma(v_{\text{next}})$; see also the shaded prefix plan in Fig.~\ref{fig:lasso}, so that the edge label $\gamma(\vertex{accept}, v_{\text{next}})$ is satisfied while robots head towards their initial locations.

  \subsubsection{Sorting the pairs of initial and accepting vertices by path length:}\label{sec:sort}  As stated in the condition \hyperref[cond:b]{\it b)} of Definition~\ref{defn:run}, each restricted accepting run  contains  one pair of initial and accepting vertices. In what follows, we sort the pairs of initial and accepting vertices in terms of the shortest length of the accepting run.  Then in Section~\ref{sub-NBA:1} we extract sub-NBA for each pair by following the order. It is beneficial to deal with sub-NBA at one time other than the whole NBA $\auto{relax}$ due to the reduced complexity.
  \paragraph{(i) Computation of the shortest simple path:} Given a pair of initial vertex $v_0$ and accepting vertex $\vertex{accept}$ in $\auto{relax}$, we first compute the number of edges/subtasks in the shortest simple path from  $v_0$ to $\vertex{accept}$ where a simple path does not contain any  repeating vertices, echoing with the condition~\hyperref[cond:a]{\it a)} in the Definition~\ref{defn:run} that no cycle exists in the prefix-suffix representation.
  To this end, we remove all other initial vertices and accepting vertices from $\auto{relax}$. This will not affect those restricted  accepting runs that contain $v_0$ and $\vertex{accept}$ due to condition \hyperref[cond:b]{\it b)}  in Definition~\ref{defn:run}.  Then, for the initial vertex $v_0$, we continue depending on whether it has a self-loop:
\paragraph{\quad (a) if $v_0$ does not have a self-loop, i.e., $\gamma(v_0)=\bot$:}\label{sec:initial} In this case, for each outgoing edge of $v_0$ in $\auto{relax}$ with label $\gamma$,  we remove it  if the initial robot locations do not satisfy the corresponding edge label $\gamma_\phi$ (including the negative literals) in $\autop^-$. We highlight that the satisfaction check should be conducted in the NBA $\autop^-$, since if initial robot locations can not enable an edge of $v_0$ in $\autop^-$ at the beginning, there is no point in considering this edge in any NBA that is obtained from $\autop^-$.
\paragraph{\quad (b) if $v_0$ has a self-loop, i.e., $\gamma(v_0)\neq\bot$:} We check whether the initial robot locations satisfy $\gamma_\phi(v_0)$. If yes, we do nothing; otherwise, this case is the  same as case~\hyperref[sec:initial]{\it (i)} and thus, we remove the self-loop of $v_0$ and
remove any of its  outgoing edges  from $\auto{relax}$ if the initial robot locations do not satisfy the corresponding edge label $\gamma_\phi$ in $\autop^-$. Next, the shortest simple path connecting $v_0$ and $\vertex{accept}$ can be found using Dijkstra's algorithm.  Note that if a vertex is both an initial and accepting vertex, we view it differently, one as the initial vertex and one as the accepting vertex, although it appears twice in the shortest simple path.
\paragraph{(ii) Computation of the shortest simple cycle:} Next, we compute the number of edges in the shortest simple cycle around the given accepting vertex $v_\text{accept}$ in $\auto{relax}$, where in a simple cycle, repeating vertices only appear at the first and last. Note that this $\auto{relax}$ is a copy of the original one that is obtained directly from $\autop^-$, thus, operations when finding the simple shortest path will not affect this $\auto{relax}$. If $\vertex{accept}$ in $\auto{relax}$ has a self-loop, the length of the shortest simple cycle is 0. Otherwise, similar to finding the shortest simple path, we first remove all other accepting vertices from~$\auto{relax}$ and then remove all initial vertices (including $v_0$) if they do no have self-loops. This will not affect those restricted accepting runs that contain $v_0$ and $\vertex{accept}$  due to conditions \hyperref[cond:b]{\it b)} and \hyperref[cond:c]{\it c)} in Definition~\ref{defn:run}.
  In this way, the only vertex that does not have a self-loop is the accepting vertex $\vertex{accept}$.

  By default, if no simple path or cycle exists, the length is infinite. After obtaining the shortest simple path and cycle, we assign their total length to the given pair of initial and accepting vertices.  Finally,  we sort all pairs of initial and accepting vertices in an ascending order in terms of the total length. We prefer the pair with the shorter length since it contains fewer subtasks to be completed.}
%% \begin{figure}[!t]
%%   \centering
%%   \subfigure[$\gamma(\vertex{accept}) \neq \bot$]{
%%       \label{fig:presence}
%%       \includegraphics[width=0.3\linewidth]{presence.pdf}}
%%   \subfigure[$\gamma(\vertex{accept}) = \bot$]{
%%       \label{fig:absence}
%%       \includegraphics[width=0.6\linewidth]{absence_presuf.pdf}}
%%   \caption{Fig.~\ref{fig:presence} depicts the sub-NBA for the prefix and suffix parts with the presence of $\gamma(\vertex{accept})$ and Fig.~\ref{fig:absence} depicts the sub-NBA for the prefix and suffix parts, respectively, with the absence of $\gamma(\vertex{accept})$.}
%%   \label{fig:presuf}
%% \end{figure}


  \subsubsection{Extraction of the sub-NBA \upshape $\auto{subtask}$:}\label{sub-NBA:1}
We iterate over the sorted pairs of initial and accepting vertices. Given a pair of vertices  $v_0$ and $v_\text{accept}$ whose total length is not infinite,  we extract one sub-NBA for the prefix and one for the suffix part, respectively, from  the NBA $\auto{relax}$.  Here, we discuss the prefix sub-NBA. The suffix sub-NBA is similar and will be  discussed in Section~\ref{sec:suf}.

Given the pair of vertices $v_0$ and $\vertex{accept}$, we follow the same procedures as those when computing the shortest simple path in Section~\ref{sec:sort}, including removing the self-loop of $v_0$ and its outgoing edges from $\auto{relax}$ if the initial robot locations do not satisfy them and further removing all other initial and accepting vertices. Then, we remove all outgoing edges from $\vertex{accept}$ if $\vertex{accept} \not=v_0$, because we focus on the prefix part. Next, let $\ccalV_{\text{s}}$ denote the set that contains all remaining vertices in $ \auto{relax}$ that belong to a path that connects $v_0$ and $\vertex{accept}$, then we construct a sub-NBA $\auto{subtask}=(\ccalV_{\text{s}}, \ccalE_\text{s})$ from $\auto{relax}$ which includes all edges between vertices in $\ccalV_{\text{s}}$; see also Fig.~\ref{fig:prefix}. We highlight that if there exists a run that connects $v_0$ and $\vertex{accept}$ in $\auto{relax}$, and can also be incured by robot paths, then this run will exist in the sub-NBA $\auto{subtask}$, as shown in Proposition~\ref{prop:nonempty} in Section~\ref{sec:correctness}.

%% Based on the vertex label  $\gamma(\vertex{accept})$, we operate on $\auto{subtask}$ in two manners.

\begin{figure}
  \centering
  \subfigure[$\gamma(v_0)\neq \bot$ is satisfied by initial robot locations]{
    \includegraphics[width=0.4\linewidth]{prefix_self_loop.pdf}\label{fig:prefix_self_loop}}
  \hspace{0.2em}
  \subfigure[$v_0= \vertex{accept}$ and $\gamma(v_0)$ is not satisfied by  initial robot locations]{
    \includegraphics[width=0.4\linewidth]{prefix_no_self_loop.pdf}\label{fig:prefix_no_self_loop}}
  \caption{$\auto{relax}$ for the prefix part. The component inside the gray box is included when the accepting vertex $\vertex{accept}$ has a self-loop, i.e., $\gamma(\vertex{accept})\neq \bot$.}\label{fig:prefix}
\end{figure}

When the accepting vertex $\vertex{accept}$ has a self-loop, we solve the prefix and suffix part at the same time, since if robot configurations satisfy the vertex label $\gamma(\vertex{accept})$ and remain idle, the progression will stay at $\vertex{accept}$ forever.
In particular, we add a vertex $v'_{\text{accept}}$ with label $\top$ and an edge $(\vertex{accept}, v'_{\text{accept}})$ with label $\top$ to $\auto{subtask}$, so that the edge $(\vertex{accept}, v'_{\text{accept}})$ will be treated as a subtask in Section~\ref{sec:app} and its vertex label $\gamma(\vertex{accept})$ will be enabled when designing high-level and low-level plans in Section~\ref{sec:solution2mrta}; see also Fig.~\ref{fig:prefix_self_loop}.  Note that when $v_0 = \vertex{accept}$ in $\auto{relax}$, that is, when the initial vertex is also the accepting vertex, we remove the self-loop of $v_0$ (acting as the initial vertex) when the initial robot locations do not satisfy its label, but this will not affect the self-loop of $\vertex{accept}$ (acting as the accepting vertex) since  we view $v_0$ and $\vertex{accept}$ differently. Furthermore, we only connect $v'_{\text{accept}}$ to $\vertex{accept}$ that acts as the accepting vertex; see Fig.~\ref{fig:prefix_no_self_loop}.
%% \domanda{\it (ii) Absence of \upshape$\gamma(\vertex{accept})$} This case corresponds to case~\hyperref[sec:absence]{\it (ii)}. If $\gamma(\vertex{accept})$ does not exist, we connect $\vertex{accept}$ to $v_{\text{next}}$ that immediately follow $\vertex{accept}$ in $\auto{relax}$, and build a sub-NBA $\auto{relax}$ for each selection of $v_{\text{next}}$. We sort the set of vertices $v_{\text{next}}$ in an ascending order according to the length of the propositional formula $\gamma(\vertex{accept}, v_{\text{next}})$. The length of formula $\top$ is 0 by default. Intuitively, the shorter the formula is, the easier it can be satisfied. As discussded in~case~\hyperref[sec:absence]{\it (ii)}, the vertex label of $v_{\text{next}}$ should be satisfied at last (it has a vertex label since we remove all vertices without lables except initial and accepting vertices in step~\hyperref[prune:3]{{\it 6)}} in Section~\ref{sec:prune}). Similar to~\hyperref[i:presence]{{\it i)}}, we add a new vertex $v'_{\text{next}}$ with label $\top$ and a new edge $(v_{\text{next}}, v'_{\text{next}})$ with label $\top$  to $\auto{subtask}$; see also the left figure in Fig.~\ref{fig:absence}.

     \begin{figure}
       \centering
       \subfigure[$\auto{subtask}$ for task~{\it (i)}]{
         \includegraphics[width=0.4\linewidth]{nba_i_subtask.pdf}\label{fig:nba_i_subtask}}
       \hspace{2em}
       \subfigure[$\auto{subtask}$ for task~{\it (ii)}]{
         \includegraphics[width=0.2\linewidth]{nba_ii_subtask.pdf}\label{fig:nba_ii_subtask}}
       \caption{Sub-NBA $\auto{subtask}$ for the prefix part of tasks~\hyperref[task:i]{\it (i)} and~\hyperref[task:i]{\it (ii)}.}
       \label{fig:auto_subtask}
     \end{figure}

     \begin{cexmp}
       The sub-NBA $\auto{subtask}$ for the prefix part of tasks~\hyperref[task:i]{\it (i)} and~\hyperref[task:i]{\it (ii)} are shown in~Fig.~\ref{fig:auto_subtask}. For task~\hyperref[task:i]{\it (i)}, given the pair $\vertex{init}$ and $v_6$ in the relaxed NBA $\auto{relax}$ in Fig.~\ref{fig:nba_i_relax}, the total length is $3+0=3$ (edges $(\vertex{init}, v_3), (\vertex{init}, v_4), (\vertex{init}, v_5)$ were removed). The NBA $\auto{subtask}$, shown in  Fig.~\ref{fig:nba_i_subtask} is obtained by removing edges $(\vertex{init}, v_3), (\vertex{init}, v_4), (\vertex{init}, v_5), (v_5, v_3),  (v_5, v_6)$ and vertex $v_5$ from $\auto{relax}$ and further adding vertex $v_{6'}$ and the edge $(v_6, v_{6'})$ due to $\gamma(v_6)\neq \bot$. For task~\hyperref[task:i]{\it (ii)}, given the pair $\vertex{init}$ and $\vertex{init}$,  there is no cycle leading back to $\vertex{init}$, so the total length is infinite and there is no corresponding sub-NBA $\auto{relax}$. The total legnth for the pair $\vertex{init}$ and $v_3$ is $2+2=4$, and $\auto{subtask}$ is shown in  Fig.~\ref{fig:nba_ii_subtask}.
     \end{cexmp}

Observe that the sub-NBA $\auto{subtask}$ in Fig.~\ref{fig:nba_i_subtask} still costitutes a large portion of  $\auto{relax}$ in Fig.~\ref{fig:nba_i_relax}, which is typical due to that the ratio of the number of edges to the number of initial and accepting vertices is not small and the \ltl formulas permit the existence of self-loops of most vertices. Therefore, in what follows, we further prune the NBA $\auto{subtask}$  by exploiting the structure of the NBA.

\begin{figure}
  \centering
  \subfigure[ID property]{
    \includegraphics[width=0.6\linewidth]{id.pdf}\label{fig:id}}
  \subfigure[ST property]{
    \includegraphics[width=0.36\linewidth]{st.pdf}\label{fig:st}}
  \caption{ID and ST properties.}\label{fig:property}
\end{figure}
  \subsubsection{Prune the sub-NBA \upshape $\auto{subtask}$:} \label{sub-NBA:2}
Recall that for task~\hyperref[task:i]{\it (i)}  some visitation of certain regions can be executed in parallel. To capture this, We define the independent diamond (ID) property adapted from~\cite{stefanescu2006automatic}  and sequential triangle (ST) property over vertices; see also Fig.~\ref{fig:property}.
\begin{defn}[(Independent diamond property)]\label{defn:id}
  Given 4 different vertices $v_1, v_2, v_3, v_4$ in the NBA $\auto{relax}$, we say that these 4 vertices have the ID property if (a) $\gamma(v_1) = \gamma(v_2) = \gamma(v_4)$, (b) $v_1 \xrightarrow{\gamma}_B v_2 \xrightarrow{\gamma'}_B v_3$, (c) $v_1 \xrightarrow{\gamma'}_B v_4 \xrightarrow{\gamma}_B v_3$,  (d) $v_1 \xrightarrow{\gamma \wedge \gamma'}_B v_3$, and (e) $\gamma_\phi(v_3) = \top$ if $v_3 = \vertex{accept}$.
\end{defn}
Intuitively, if vertices have the ID property (see Fig.~\ref{fig:id}), we have equivalent subtasks $(v_1, v_2) \sim (v_4, v_3)$ and $(v_1, v_4) \sim (v_2, v_3)$ in $\auto{subtask}$ according to conditions {\it (a)-(c)}, and the occurence order is arbitrary according to conditions {\it (b)-(d)}.  We refer to $(v_1, v_3)$ as the {\it composite} subtask and $(v_1, v_2)$, $(v_1, v_4)$ as the {\it elementary} subtasks.  Although both can lead to vertex $v_3$, elementary subtasks are preferred since subtasks $(v_1, v_2)$ and $(v_1, v_4)$ can be executed independently, making it easier to satisfy and more flexible to implement, when compared to the composite subtask that requires that two subtasks are accomplished at the same time. It's worth noting that the $\top$-check in condition {\it (e)} are conducted in terms of the corresponding vertex label in $\autop^-$ for the sake of condition~\hyperref[cond:f]{\it (f)} in the Definition~\ref{defn:run}. If $\gamma_\phi(v_3) \ne \top$ when $v_3 = \vertex{accept}$, and further if an accepting run traverses edges $(v_1, \vertex{accept})$ and $(\vertex{accept}, \vertex{next})$ where $\vertex{next}\neq \vertex{accept}$, condition~\hyperref[cond:f]{\it (f)} requires that $\gamma_\phi(v_1, \vertex{accept}) \simplies \gamma_\phi(\vertex{accept}, \vertex{next})$, but $\gamma(v_2, \vertex{accept})$ and $\gamma(v_4, \vertex{accept})$ may not be able to imply $\gamma_\phi(\vertex{accept}, \vertex{next})$ since they are subformulas of $\gamma_\phi(v_1, \vertex{accept})$. Therefore, removing the composite subtask $(v_1, \vertex{accept})$ can be at the risk of emptying the  set of restricted accepting runs,  as shown in Proposition~\ref{prop:sub-NBA} in Section~\ref{sec:correctness}.


\begin{defn}[(Sequential triangle property)]\label{defn:st}
  Given 3 different vertices $v_1, v_2, v_3$ in the NBA $\auto{relax}$, we say that these 3 vertices $v_1, v_2, v_3$ have the ST property if %% {\it (i)} $\gamma(v_1) = \gamma(v_2)$,
(a) $v_1 \xrightarrow{\gamma}_B v_2 \xrightarrow{\gamma'}_B v_3$,  (b) $v_1 \xrightarrow{\gamma \wedge \gamma'}_B v_3$, and (c) $\gamma_\phi(v_3) = \top$ if $v_3 = \vertex{accept}$.
\end{defn}

If vertices have the ST  property (see Fig.~\ref{fig:st}), subtask $(v_1, v_2)$ should be satisfied no later than $(v_2, v_3)$, according to conditions {\it (a)} and {\it (b)}. Observe that if vertices $v_1, v_2, v_3, v_4$ have the ID property, then $v_1, v_2, v_3$ and $v_1, v_4, v_3$ have the ST property. Based on these two properties, for any edge $(v_1, v_3)$ in $\auto{subtask}$, we delete it if there exists  vertex $v_2$ such that combined they have  ST property. We denote by $\auto{subtask}^-$ the pruned $\auto{subtask}$.

Note that a composite subtask can be an elementary subtask of another composite subtask at a higher layer, therefore, removing composite subtasks  is vital for reducing the size of $\auto{subtask}$. Similar to the pruning of $\autop$ to get $\autop^-$, feasibility of Problem~\ref{prob:1} is not compromised by pruning the NBA $\auto{subtask}$, as shown in Proposition~\ref{prop:sub-NBA} in Section~\ref{sec:correctness}. %% \red{ This also justifies the method to sort a pair of initial and accept vertices. The shortest path usually results in longer labels that can be decomposed into multiple shorter labels, hence more subtasks but each one can be fulfilled easily.}
\begin{figure}[t]
    \centering
    \subfigure[$\auto{subtask}^-$]{
      \label{fig:sub-NBA}
      \includegraphics[width=0.2\linewidth]{nba_i_subtask_prune.pdf}}
    \hspace{2em}
    \subfigure[Subtasks]
    {\label{fig:subtask}
      \includegraphics[width=0.5\linewidth]{subtask_i.pdf}}
        \caption{The NBA $\auto{subtask}^-$ and corresponding subtasks.} \label{fig:subtask_prune}
\end{figure}
\begin{cexmp} [(ID and ST properties and NBA $\auto{subtask}^-$)]
  In the NBA $\auto{subtask}$ for task~\hyperref[task:i]{\it (i)}, shown in Fig.~\ref{fig:nba_i_subtask}, instances of the ID and ST properties are the set of 4 vertices $v_1, v_2, v_3, v_4$ and the set of 3 vertices $v_2, v_3, v_6$, respectively. So we delete $(v_1, v_3)$ and $(v_2, v_6)$. The obtained $\auto{subtask}^-$ is shown in Fig.~\ref{fig:sub-NBA}. The NBA $\auto{subtask}^-$ of task~\hyperref[task:ii]{\it (ii)} is the same as $\auto{subtask}$ since there are no composite subtasks.
\end{cexmp}

\begin{rem}
  The last conditions {\it (e)} in the definition of ID property and {\it (c)} in the definition of ST property are necessary for establishing the theorectical guarantee in Proposition~\ref{prop:sub-NBA}  on the non-emptiess of  set of restricted accepting runs after the prunning of composite subtasks. However, these conditions are not necessary in practice when implementating the prunning process. We found that in the simulations in Section~\ref{sec:sim}, with condition {\it (c)} being omitted, only checking conditions {\it (a)} and {\it (b)} of Definition~\ref{defn:st} in $\auto{subtask}$  does not compromise  the preformance.
\end{rem}


%% \begin{figure}[t]
%%   \centering
%%   \includegraphics[width=1\linewidth]{p_nba0.pdf}
%%    \caption{Sub-NBA $\auto{subtask}$}
%%   \label{fig:nba_b}
%% \end{figure}

\subsection{Inferring temporal order between subtasks in  $\auto{subtask}^-$}\label{sec:poset}
In this section,  we infer the temporal relation between subtasks in the pruned NBA $\auto{subtask}^- = (\ccalV_\text{s}, \ccalE_\text{s})$; see also block 2 in Fig.~\ref{fig:overview}.  To capture the temporal relation among subtasks in a high-level plan,  we rely on the use of partial orders described in Subsection~\ref{sec:partial}.


Specifically, given the NBA $\auto{subtask}^-$, let $\Theta$ denote the set that collects all simple paths that connect $v_0$ and $\vertex{accept}$ in $\auto{subtask}^-$. Simple paths suffice since condition~\hyperref[cond:a]{\it a)} in Definition~\ref{defn:run} excludes cycles. In the case that $\vertex{accept}$ has a self-loop, we collect all paths leading to $\vertex{accept}'$.
For a simple path $\theta \in\Theta$, let $\ccalT(\theta)$ denote the set of subtasks in $\theta$. We say two simple paths $\theta_1, \theta_2$ have the same set of subtasks if $\ccalT(\theta_1) =\ccalT(\theta_2)$. Then we partition $\Theta$ into subsets of  simple paths that contain the same set of subtasks, that is, $\Theta = \cup_e \Theta_e$, $\Theta_e \cap \Theta_{e'} = \emptyset$ if $e\not=e'$. The motivation for this partition is that the set of linear extensions generated by a poset has the same set of elements. {In what follows, we map subtasks to integers to facilitate the discovery of the  poset.}

Given a subset $\Theta_e$ of simple paths in the partition, with a slight abuse of notation, let $\ccalT(\Theta_e)$ denote the set of corresponding  subtasks. Let the function $f_e:\ccalT(\Theta_e)\to [|\ccalT(\Theta_e)|]$ map each subtask to a positive integer. Using $f_e$, we can map every path in $\Theta_e$ to a sequence of integers. Let $\Gamma_e$ collect all sequences of integers for all paths in $\Theta_e$, so $|\Theta_e| =  |\Gamma_e|$. Moreover, a sequence in $\Gamma_e$ is a permutation of the same set of integers, denoted by $X_e = [|\Theta_e|]$. For every sequence $S_e \in \Gamma_e$, let $S_e[i]$ denote its $i$-th entry. We define a linear order $L_{X_e} = (X_e, <_L)$ such that  $S_e[i]  <_L  S_e[j] $ if $i  <  j$. In other words, the subtask $S_e[i]$ should be executed prior to  $S_e[j]$. Then, let $\Xi_e$ collect all linear orders over $X_e$ that can be defined from sequences in $\Gamma_e$. An underlying poset $P_e  = (X_e, <_{P_e})$ of $\Xi_e$ can be found using the algorithm for the partial cover problem in~\cite{heath2013poset}, where the order represents the precedence relation. After obtaining the poset $P_e$, we double check whether the set of all linear extensions of $P_e$ is the same as $X_e$. Otherwise, we treat each linear order in~$\Xi_e$ as a linear ordered set, which is a poset as well.

{Finally, given a partition $\{\Theta_e\}$ and a corresponding set of posets $\{P_e\}$, we sort the posets  $\{P_e\}$ first in a descending order in terms of the width of the posets. The width of a poset  is the cardinality of a maximum antichain, which is a subset of the poset where any two distinct elements are incomparable. Then, if there are multiple posets with the same width, we sort them in a ascending order in terms of the height, which is cardinality of a maximum chain, where any two elements are comparable. Intuitively, the wider a poset is, the larger the number of temporally independent subtasks it contains. The lower of a poset is, the smaller the number of elementary subtasks it has.} Every linear extension of subtasks in a poset produces a simple path that connects $v_0$ and $\vertex{accept}$ (if $\gamma(\vertex{accept}) \neq \bot$) or $v'_{\text{accept}}$ (if $\gamma(\vertex{accept}) = \bot$). In the next section, our goal is to find a high-level plan that induces a linear extension of a given poset and optimizing the cost of the plan at the same time.

\begin{cexmp}[(Temporal constraints)]
  For task~\hyperref[task:i]{\it (i)}, there are 2 simple paths in $\auto{subtask}^-$ leading to $v_6'$ and all have the same set of 5 edges.  $\Theta_1 = \{\vertex{init},v_1, v_4,v_3,v_6,v_{6'}$; $\vertex{init}, v_1, v_2,v_3, v_6, v_{6'}$\}; see~Fig~\ref{fig:sub-NBA}. Note that the added edge $(v_6, v_{6'})$ is always at the end since it is the only edge after the accepting vertex $v_6$. The design of equivalent subtasks, mapping function, integer sequence and the poset are shown in Fig.~\ref{fig:subtask}. The temporal relation implies that subtasks $(v_1, v_4)$ and $(v_1, v_2)$ are independent, which agrees with our observation. For task~\hyperref[task:ii]{\it (ii)}, the NBA $\auto{subtask}^-$ in Fig.~\ref{fig:nba_ii_subtask} only has one path of 2 subtasks that generates a total ordered set, that is, every two subtasks are comparable.
\end{cexmp}

%% Given $e = (v_1, v_2) \in\ccalE_\text{s}$, let $\ccalE_e$ collect all edges in $\ccalE_\text{s}$ that share the same first vertex label and edge label with $e$, i.e., $\ccalE_e = \{e' = (v'_1, v'_2) \in \ccalE_p \, |\, \gamma(v_1) = \gamma(v'_1), \gamma(v_1, v_2) = \gamma(v'_1, v'_2)\}$. Next, we partition $\ccalE_e$ into two disjoint subsets $\ccalE_e^1$ and $\ccalE_e^2$ such that any $e_1, e_2 \in \ccalE_e^1$ do not belong to a common path in $\Pi$ and $\ccalE_e^2$ is the complement of $\ccalE_e^1$, where $\Pi$ collects all simple paths that connect $v_0$ and $\vertex{accept}$ in $\auto{subtask}$. Tasks in $\ccalE_e^1$ are temporally independent and $\ccalE_e^1$ contains all possible such tasks/e{e'ges.

%% Given $\ccalE_e$ and its partition into $\ccalE_e^1$ and $\ccalE_e^2$, let the function $f_e: \ccalE_e \to \{N_e, \ldots,N_e+|\ccalE_e^2|\}$ map all edges in $\ccalE_e^1$ to the positive integer $N_e$, i.e., $f(e_1) = f(e_2)=N_e, \forall e_1, e_2 \in \ccalE_e^1$, and every edge in $\ccalE_e^2$ to a distinct integer in $\{N_e+1, \ldots, N_e+|\ccalE_e^2|\}$ with one-to-one correspondence, where  $[N_e-1]$ are the integers that have been already used for other sets in $\{\ccalE_e\}$. Since ${\ccalE_e}$ forms a partition of $\ccalE_\text{s}$, we can combine all functions $f_e$ in the function $f: \ccalE_p \to \mathbb{N}^+$ that maps an edge in $\ccalE_p$ to a positive integer. %% In Example~\ref{exp:1}, the function is defined as $f(\vertex{init}, v_{1}) = 1, f(v_{1}, v_{2}) = f(v_5, v_4) = 2, f(v_1, v_5) = f(v_{2}, v_{4}) = f(v_3, v_7)=3, f(v_{2}, v_{3}) = f(v_4, v_7) =4$.


%% \begin{cexmp}
%%   Consider the running example. The equivalence sets are $\ccalE_{(\vertex{init}, v_{1})} = \ccalE^1_{(\vertex{init}, v_{1})} = \{(\vertex{init}, v_{1})\}$, $\ccalE_{(v_{1}, v_{2})} = \ccalE^1_{(v_{1}, v_{2})} = \{(v_{1}, v_{2}), (v_5, v_4)\}$, $\ccalE_{(v_{1}, v_{5})} = \ccalE_{(v_{1}, v_{5})}^1 =  \{(v_1, v_5), (v_{2}, v_{4}), (v_3, v_7)\}$, $\ccalE_{(v_{2}, v_{3})} = \ccalE^1_{(v_{2}, v_{3})} = \{(v_{2}, v_{3}), (v_4, v_7)\}$. The function is defined as $f(\vertex{init}, v_{1}) = 1, f(v_{1}, v_{2}) = f(v_5, v_4) = 2, f(v_1, v_5) = f(v_{2}, v_{4}) = f(v_3, v_7)=3, f(v_{2}, v_{3}) = f(v_4, v_7) =4$. The set of sequences $\Gamma = \Gamma_\sim^1 = \{(1,2,4,3), (1,2,3,4), (1,3,2,4)\}$ and the order relation of the underlying poset $P_1 = P = \{1<_{P}2, 1<_{P}4, 1<_{P}3, 2<_{P}4\}$. In words, eventually 1 robot of type 1 visits $\ell_1$ before 2 robots of type 1 visits $\ell_3$, and the time that 1 robot of type 2 visits $\ell_2$ can be arbitrary.
%% \end{cexmp}
\section{MILP Solution to the Relaxed Automaton}\label{sec:solution}
We iterate over the poset in the  sorted set of posets  $\{P_e\}$. Given a poset $P$, let $X_{P}$ denote its base set. Note that each element in $X_P$ is an integer, which is also an edge in the NBA $\auto{subtask}^-$ and a subtask defined in Definition~\ref{defn:subtask}. In this section, we find a high-level plan that indicates  a sequence of waypoints that each robot need to visit by solving a MILP program inspired by vehicle routing problem; see also blocks 3-5 in Fig.~\ref{fig:overview}. The collective behavior produces a linear extension of the poset $P$ by satisfying vertex and edge labels of all elements sequentially. In this way,  this plan will generate a path in $\auto{subtask}^-$ that connects $v_0$ and $\vertex{accept}$ or $v'_{\text{accept}}$ in~$\auto{subtask}^-$.


\subsection{Construction of the routing graph}\label{sec:graph}
To leverage the MILP formulation, in this section, we construct a routing graph $\ccalG = (\ccalV_{\ccalG},\ccalE_{\ccalG})$ where each vertex represents a specific region that is associated with a specific literal in a specific label of a subtask in $X_P$. Each vertex/region in $\ccalV_\ccalG$ is visited by at most one robot during the whole process. Simultaneous visits of multiple vertices in $\ccalV_\ccalG$ by a team of robots  satisfy a literal, a clause, or a label. The time of visits reflects the precedence order among subtasks  Below, we first construct  the vertex set and then the edge set of $\ccalG$. Both constructions follow four layers of nested iterations, starting with the edges, then the labels, then the clauses, and finally the literals. The outline of the algorithm is shown in Alg.~\ref{alg:milpgraph}.  Fig.~\ref{fig:routing} demonstrates such routing graph. An illustrative graph for task~\hyperref[task:i]{\it (i)}  is also shown in Fig.~\ref{fig:milp}.
\begin{algorithm}[!t]
      \caption{Construct the routing graph}
      \LinesNumbered
      \label{alg:milpgraph}
      \KwIn {Poset $P$}
      \Comment*[r]{Create the vertex set}
      Create the vertex set $\ccalV_{\text{init}}$ for initial locations \label{milp:init}\;
      \Comment*[r]{vertices for  labels}
      \For{$e = (v_1, v_2) \in X_P$ \label{milp:for}}{
        \If{$\gamma(v_1, v_2) \not= \top$ \label{milp:nottrue}}{
          \For{$\ccalC_p^\gamma \in \clause{\gamma} $\label{milp:clause}}{
            \For{$\ap{i}{j}{k,\chi} \in \mathsf{lits}(\ccalC_p^{\gamma})$\label{milp:ap}}{
              Create $i$ vertices \label{milp:i}\;
            }
          }
        }
          \If{$\gamma(v_1)\not= \top, \bot$ \label{milp:nottrue2}}{
            Create vertices by following lines~\ref{milp:clause}-\ref{milp:i} \label{milp:repeat}\;
          }

      }
      \Comment*[r]{Create the ege set}
      \For{$e = (v_1, v_2) \in X_P$ \label{milp:for2}}{
        \If{$\gamma(v_1, v_2) \not= \top$ \label{milp:e}}{
            \For{$\ccalC_p^\gamma \in \clause{\gamma} $\label{milp:clause2}}{
              \For{$\ap{i}{j}{k,\chi} \in \mathsf{lits}(\ccalC_p^{\gamma})$\label{milp:lits}}{
                $(i)$ Vertices of  initial robot locations \label{milp:i2}\;
                $(ii)$ Vertices of prior tasks \label{milp:ii}\;
                $(iii)$ Vertices associated with  $\gamma(v_1)$ \label{milp:iii}\;
              }
            }
        }
        \If{$\gamma(v_1) \not= \top,\bot$ \label{milp:nottrue3}}{
          %%   Create edges by following lines~\ref{milp:clause2}-\ref{milp:ii} \label{milp:repeat2}\;

          \If{$S_2^e= \emptyset$}{
            Create edges by following lines~\ref{milp:clause2}-\ref{milp:i2} \label{milp:repeati}\;
          }
          \ElseIf{\upshape $S_2^e\ne \emptyset$ {\bf and} $v_1 \ne \vertex{accept}$}{
            Create edges from vertices associated with subtasks in $S_2^e$  \label{milp:repeatiii}\;
         }
          \ElseIf{\upshape $S_2^e \neq \emptyset$ {\bf and} $v_1 = \vertex{accept}$}{
            Create edges by following lines~\ref{milp:clause2}-\ref{milp:ii} \label{milp:repeatii}\;
          }
        }
      }
\end{algorithm}


\subsubsection{Construction of the vertex set:}\label{sec:vertex} The vertex set of the routing graph  consiss of three parts: the first part is related to intial robot locations, the other two parts are associated with edge labels and vertex labels, respectively, in the sub-NBA $\auto{subtask}^-$.

\paragraph{(i) Vertices associated with initial locations:}\label{vertex:initial} First we create $n$ vertices, collected in the set $\ccalV_{\text{init}}\subseteq \ccalV_{\ccalG}$ such that each vertex points to the initial location $s^0_{r,j}$ of robot $[r,j]$ [line~\ref{milp:init}, Alg.~\ref{alg:milpgraph}] (see vertices inside the blue circle in Fig.~\ref{fig:routing} and blue dots in Fig.~\ref{fig:milp}).

Next, we iterate over subtasks in $X_{P}$. Given a subtask $e = (v_1, v_2) \in X_{P}$, we construct new vertices for the  edge label $\gamma(v_1, v_2)$ and starting vertex label $\gamma(v_1)$, if they are neither $\top$ nor $\bot$. In Fig.~\ref{fig:routing} there are three subtasks $e_1, e_2$ and $e_3$  and vertices correpond to the same subtask are surrounded by gray ellipses.

\paragraph{(ii) Vertices associated with the edge label of subtask $e$:}\label{vertex:edge} If $\gamma(v_1, v_2) \not= \top$, we operate on $\gamma(v_1, v_2) =  \bigvee_{p\in \ccalP} \bigwedge_{q \in \ccalQ_{p}} \ap{i}{j}{k,\chi}$ starting by iterating over clauses $\ccalC_p^{\gamma}$ in $\clause{\gamma}$, and then over literals in $\ccalC_p^\gamma$ [lines~\ref{milp:for}-\ref{milp:i}, Alg.~\ref{alg:milpgraph}].
The literal $\ap{i}{j}{k,\chi}\in $ $\mathsf{lits}^+(\ccalC_p^{\gamma})$ implies that $\ag{i}{j}$, that is, $i$ robots of type $j$,  should visit the target region $\ell_k$ simultaneously. Hence, we create $i$ vertices in $\ccalV_\ccalG$  that all point to region $\ell_k$. If $\ag{i}{j}$ visit these $i$ vertices simultaneously, one robot each vertex, then $\ap{i}{j}{k,\chi}$ is true Note that if $\chi\not=0$, additionally, the robots visiting these $i$ vertices should be the same as those visiting another $i$ vertices which are associated with a literal with identical non-zero connector, which will be ensured in the MILP formulation in~Section \ref{sec:milp}. See organge ellipses in Fig.~\ref{fig:routing} that surround vertices associated with the same edge labels and the partition of vertices associated with subtask $e_1$ based on clauses and literals; see also red, yellow, and green dots in Fig.~\ref{fig:milp} that correspond to some edge labels in~$\auto{subtask}^-$.

\begin{figure}[!t]
  \centering
  \includegraphics[width=0.8\linewidth]{routing_graph.pdf}
  \caption{Routing graph $\ccalG$. There are three subtasks $e_1, e_2$ and $e_3$. The temporal order is $e_1 \| e_2, e_1 \prec e_3, e_2 \prec e_3$.    Vertices that are associated with initial robot locations are inside the blue circle (see case~\hyperref[vertex:initial]{\it (i)}). Each gray ellipse surrounds vertices that are associated with the same subtask, most of which consist of two smaller ellipses, one including vertices associated with the the edge label (orange ellipse; see case~\hyperref[vertex:edge]{\it (ii)}), the other including vertices associated the starting vertex label (green ellipse; see case~\hyperref[vertex:vertex]{\it (iii)}).  Each smaller ellipse is divided into several parts (solid line, we only show the partition for subtask $e_1$), each part including vertices that associated with the same clause. Furthermore, each part is divided into smaller parts (dashed line), each smaller part including vertices that are associated with the same literal.
    Edges indicate that there are connected vertices between  ellipses. Blue, orange and green  edges represent that leaving vertices are from those associated with initial robot locations, from  prior subtask and from vertex labels of the same subtasks, respectively. There are orange edges between $e_1$ and $e_2$ in both directions since they are independent, and only single directed orange edges exist pointing to vertices associated with $e_3$ since it is the last one {(see case~\hyperref[sec:b]{\it (i)})}. There are blue edges pointing to vertex labels of $e_1$ and $e_2$ since they are independent and ahead of $e_3$  whereas there is no blue edge pointing to the vertex label of $e_3$ since $e_3$ occurs after $e_1$ and $e_2$ and its leaving vertices are associated with  edge labels of $e_1$ and $e_2$ (see case~\hyperref[edge:vertex2]{\it (b)}).  Note that no edges exist inside any ellipse, since vertices inside one ellipse will be visited at the same time.}
  \label{fig:routing}
\end{figure}
\paragraph{(iii) Vertices associated with the starting vertex label of subtask $e$:}\label{vertex:vertex} After the iteration over the edge label $\gamma(v_1, v_2)$ of subtask $e$ is complete, vertices in $\ccalV_\ccalG$ associated with the starting  vertex label $\gamma(v_1)$ can be constructed in the same manner if $\gamma(v_1)$ is neither $\top$ nor $\bot$ [lines~\ref{milp:nottrue2}-\ref{milp:repeat}, Alg.~\ref{alg:milpgraph}]. The green ellipses in Fig.~\ref{fig:routing} capture vertices that are associated with the same vertex labels, which are inside the same ellipses as their correponding edge labels. We do not create vertices for the end vertex label since the meaning of subtask $e$ is irrelevant to end vertex $v_2$. Furthermore, the vertices for $v_2$ will be created when it comes to other subtasks, since it can be the starting vertex of other subtasks.

Finally, repeating this process and iterating over subtasks in $X_{P}$ completes the construction of the vertex set $\ccalV_\ccalG$. Note that each vertex in $\ccalV_\ccalG\setminus \ccalV_{\text{init}}$ is associated with a literal of some subtask in $X_P$ and each literal of some subtask in $X_P$ is associated with multiple vertices in $\ccalV_\ccalG\setminus \ccalV_{\text{init}}$ and specifies the region and the robot type associated with these vertices.
To capture this correspondence, let $\ccalM^\ccalV_{e} : \ccalV_{\ccalG}\setminus \ccalV_{\text{init}} \to  X_{P} $ and $\ccalM^\ccalV_{\mathsf{lits}}  : \ccalV_\ccalG\setminus \ccalV_\text{init}  \to  \prod_{\mathsf{lits}} $  map a vertex in $\ccalV_\ccalG \setminus \ccalV_{\text{init}}$ to its associated subtask and literal, respectively, and $\ccalM^\mathsf{lits}_{\ccalV}:   \prod_{\mathsf{lits}}  \to  2^{\ccalV_\ccalG}$ and $\ccalM^\mathsf{cls}_{\ccalV} :  \prod_{\mathsf{cls}} \to  2^{\ccalV_\ccalG}$ map a literal and clause to the associated vertices, where $\prod_{\mathsf{lits}}$ and $\prod_{\mathsf{cls}}$ are the cartesian products $ X_{P} \times\{0, 1\} \times [|\ccalP|]  \times \ccalQ_p$ and $X_{P}\times \{0, 1\} \times[|\ccalP|]$, respectively, and 0, 1 represent the label type, 0 for vertex label and 1 for edge label, respectively. Furthermore, we define $\ccalM^{\ccalV}_\ccalL :  \ccalV_\ccalG  \to  \ccalL$ and $ \ccalM^{\ccalV}_\ccalK :  {\ccalV_\ccalG}  \to  \{\ccalK_j\}$ that map a vertex to its associated  region and robot type. {If $\chi\not=0$, we define  $\ccalM_{\gamma}^\chi: \mathbb{N}^+ \to 2^{X_{P}\times \{0,1\}}$ to map $\chi$ to all labels (vertex or edge labels) in $X_P$ that have literals with the same connector $\chi$}.

\begin{cexmp}[(Mappings for task {\it (i)})]
    The mappings in Fig.~\ref{fig:milp} regarding the vertex $\ell_2^{1}$ are:
    $\mathcal{M}_e^{\mathcal{V}}(\ell_{2}^{1})  = (v_1,v_2) = 3$ and $\mathcal{M}_{\mathsf{lits}}^{\mathcal{V}}(\ell_{2}^{1})  = ((v_1,v_2), 1, 1, 1)$ since the vertex $\ell_2^{1}$ corresponds to the first literal $\ap{2}{1}{2,1}$ of the first clause of the edge label of the subtask $(v_1, v_2)$ in $X_P$; see also Fig.~\ref{fig:subtask_prune}.  $\mathcal{M}_\mathcal{L}^{\mathcal{V}}(\ell_{2}^{1})  = \ell_2$  and $\mathcal{M}_\mathcal{K}^{\mathcal{V}}(\ell_{2}^{1})  = \mathcal{K}_1$ since the literal that $\ell_2^1$ corresponds to requires 2 robots of type 1 to visit region $\ell_2$. Furthermore,  the literal/clause-to-vertex mappings are:
    $\mathcal{M}^{\mathsf{lits}}_{\mathcal{V}}(((v_1,v_2), 1, 1, 1)) = \mathcal{M}^{\mathsf{cls}}_{\mathcal{V}}(((v_1,v_2), 1, 1))  = \{\ell_2^{1}, \ell_2^{2}\}$, since the literal $\ap{2}{1}{2,1}$ requires 2 robots to visit region $\ell_2$; $\mathcal{M}^{\mathsf{lits}}_{\mathcal{V}}(((v_1,v_4), 1, 1, 1)) = \mathcal{M}^{\mathsf{cls}}_{\mathcal{V}}(((v_1,v_4), 1, 1))  = \{\ell_4^{1}\}$ since the literal $\ap{1}{2}{4}$ requires 1 robot to visit region $\ell_4$. Finally, the connector-to-label mapping is: $\ccalM^{\chi}_{\gamma} (1)  = \{((v_1, v_2), 1), ((v_3, v_6), 1)\}$ since the connector 1 appears in the edge label of subtask $(v_1 ,v_2)$ and the edge label of subtask $(v_3, v_6)$.
   \end{cexmp}
\begin{figure}[t]
  \centering
  \includegraphics[width=0.7\linewidth]{milp.pdf}
  \caption{Routing graph $\ccalG$ for task~\hyperref[task:i]{\it (i)}. $s^0_{1,1}$, $s^0_{2,1}$ and $s^0_{3,1}$ are initial locations of 3 robots of type 1 and $s^0_{1,2}$ and $s^0_{2,2}$ are the initial locations of 2 robots of type 2. Red dots $\ell_{2}^{1}$ and $\ell_{2}^{2}$ correspond to the edge label $\ap{2}{1}{2,1}$ of element 3, i.e., edge $(v_1, v_2)$ in $X_P$; see Fig.~\ref{fig:subtask}, yellow dots $\ell_{3}^{1}, \ell_{3}^{2}$ correspond to the edge label $\ap{2}{1}{3,1}$ of element 4, and green dot $\ell_{4}^{1}$ corresponds to the edge label $\ap{1}{2}{4}$ of element 2. No dots correspond to vertex labels since all vertex labels are either $\top$ or $\bot$.  The edges from $\ell_2^{1}$ to $\ell_3^{1}$ and from $\ell_2^{2}$  to $\ell_3^{2}$ are due to $3 <_{P} 4$. }
    \label{fig:milp}
\end{figure}

\subsubsection{Construction of  the edge set:}\label{sec:edge_set} We follow the similar procedure for the construction of vertex set $\ccalV_\ccalG$ to construct the edge set $\ccalE_\ccalG$ which captures the precedence order in ${P}$, by iterating over $X_P$. For any subtask $e = (v_1, v_2) \in X_{P}$, if $\gamma(v_1, v_2) \not=\top$, we operate on $\gamma(v_1, v_2) =  \bigvee_{p\in \ccalP} \bigwedge_{q \in \ccalQ_{p}} \ap{i}{j}{k,\chi}$ starting by iterating over clauses $\ccalC_p^{\gamma}$ in $\clause{\gamma}$, and then over literals in $\ccalC_p^\gamma$ [lines~\ref{milp:for2}-\ref{milp:iii}, Alg.~\ref{alg:milpgraph}]. Consider the literal $\ap{i}{j}{k,\chi} \in \mathsf{lits}^+(\ccalC_p^{\gamma})$. Its associated $i$ vertices correspond to target region $\ell_k$ that should be visited by $i$ robots. We identify three types of leaving vertices in $\ccalV_\ccalG$ from where $i$ robots depart for region $\ell_k$ to satisfy this specific literal $\ap{i}{j}{k,\chi}$.
\paragraph{(i) Vertices associated with initial robot locations:}\label{sec:a} The initial vertices in $\ccalV_{\text{init}}$ that are associated with  robots of type $j$ are leaving vertices. We add an edge from each vertex associated with such an initial vertex to each vertex associated with this specific literal $\ap{i}{j}{k,\chi}$ (see blue edges in Fig.~\ref{fig:routing} and in~Fig.~\ref{fig:milp}), with a weight equal to the length of the shortest path from the initial location to the region the vertex corresponds to.
\paragraph{(ii) Vertices associated with prior subtasks:}\label{sec:b} Let $X^e_{<_{P}}$, $X^e_{\prec_{P}}$ and $X^e_{\|_{P}}$ denote the sets that collect subtasks in $X_{P}$ that are  smaller than, covered by, and incomparable to subtask $e$, respectively; see Section~\ref{sec:partial}. In words, $X^e_{<_{P}}$ contains subtasks in $X_P$ that should be completed prior to $e$, $X^e_{\prec_{P}}$ contains subtasks that can be completed right before $e$  and $X^e_{\|_{P}}$ constains subtasks in  $X^e_{<_P}$ that are independent from $e$. To find leaving vertices, we iterate over $S_1^e = X^e_{<_{P}} \cup X^e_{\|_{P}}$ which includes all subtasks that can be completed prior to $e$.
Given a subtask $e' = (v'_1, v'_2) \in S_1^e$, if its edge label $\gamma'(v'_1, v'_2) \not=\top$ (recall that we did not create vertices for $\top$ labels), we iterate all literals in $\gamma'$ by iterating over clauses in $\gamma'$. Specially, given a clause $\ccalC^{\gamma'}_{p'} \in \clause{\gamma'}$, for any literal $\ap{i'}{j'}{k',\chi'} \in\mathsf{lits}^+(\ccalC^{\gamma'}_{p'})$, if $j'=j$, then those vertices in $\ccalV_\ccalG$ associated with this literal are leaving vertices. If $i'<i$, we add $i\cdot  i'$ edges to $\ccalE_\ccalG$ by creating an edge from any vertex associated with $\ap{i'}{j'}{k',\chi'}$ to any vertex of $\ap{i}{j}{k,\chi}$. Otherwise, if $i' \geq  i$, i.e., at least $\ag{i}{j}$ are at region $\ell_k$, we randomly select $i$ from these $i'$ vertices and add $i$ one-to-one edges starting from these $i$ vertices and ending at the $i$ vertices associated with $\ap{i}{j}{k,\chi}$ (see orange edges in Fig.~\ref{fig:routing} and Fig.~\ref{fig:milp}). This is because there are at least $i$ homogeneous robots of type $j$ and of these only $i$ robots are required, if suffices to build $i$ one-to-one edges. Furthermore, if $\chi=\chi'\neq0$, then literals $\ap{i}{j}{k,\chi}$ and $\ap{i'}{j'}{k',\chi'}$ must have the same number of vertices if formula $\phi$ is a valid formula (see Definition~\ref{defn:valid}). Building $i$ one-to-one edges can guarantee the same number of $i$ robots satisy these two literals. Finally, since each region may span multiple cells, the weight of these edges is set as the length of the shortest path from region  $\ell_{k'}$ to $\ell_k$.

After creating edges in the graph $\ccalG$ associated with the edge label  $\gamma'(v'_1,v'_2)$ of $e'$, we identify  leaving vertices  among the vertices associated with the starting vertex label $\gamma(v'_1)$ of $e'$ and build edges in the same manner. %% \red{This simpilication will be addressed in Section~\ref{sec:solution2mapp}}.




%% In what follows, we investigate the following cases depending on the value of $\chi$ in $\ap{i}{j}{k,\chi}$.
%% \paragraph{\quad (a) $\chi = 0$:}\label{sec:ba} When $\chi=0$, no restriction is imposed on robots of the specified type about which robots should visit the region.  Given a clause $\ccalC^{\gamma'}_{p'} \in \clause{\gamma'}$, for any literal $\ap{i'}{j'}{k',\chi'} \in\mathsf{lits}^+(\ccalC^{\gamma'}_{p'})$, if $j'=j$, then those vertices in $\ccalV_\ccalG$ associated with this literal are starting locations. If $i'<i$, we add $i\cdot  i'$ edges to $\ccalE_\ccalG$ by creating an edge from any vertex associated with $\ap{i'}{j'}{k',\chi'}$ to any vertex of $\ap{i}{j}{k,\chi}$. Otherwise, if $i' \geq  i$, i.e., at least $\ag{i}{j}$ are at region $\ell_k$, we randomly select $i$ from these $i'$ vertices and add $i$ one-to-one edges starting from these $i$ vertices and ending at the $i$ vertices associated with $\ap{i}{j}{k,\chi}$ (see orange edges in Fig.~\ref{fig:routing} and Fig.~\ref{fig:milp}). This is because there are more than $i$ homogeneous robots of type $j$ and of these only $i$ robots are required, if suffices to build $i$ one-to-one edges. Furthermore, since each region may span multiple cells, the weight of these edges is the length of the shortest path from region  $\ell_{k'}$ to $\ell_k$. %% \red{This simpilication will be addressed in Section~\ref{sec:solution2mapp}}.
%%   \paragraph{\quad (b) $\chi \not=0$:}\label{sec:bb} In this case, the same group $\ag{i}{j}$ are required to visit several regions sequentially.
  %% Given a clause $\ccalC^{\gamma'}_{p'} \in \clause{\gamma'}$, for any literal $\ap{i'}{j'}{k',\chi'} \in\mathsf{lits}^+(\ccalC_{\gamma'}^{p'})$ with $j'=j$ and $\chi'=\chi$, there are $i'=i$ vertices associated with this literal. In this case, we add $i$ one-to-one edges starting from these $i'$ vertices and ending at the $i$ vertices associated with $\ap{i}{j}{k,\chi}$.

\paragraph{(iii) Vertices associated with $\gamma(v_1)$ of $e$:}\label{sec:c} When the iteration over $S_1^e$ is over, we identify leaving vertices  among the vertices associated with the starting vertex label  $\gamma(v_1)$ of the current subtask $e$ following the same procedures~\hyperref[sec:a]{\it (i)} and~\hyperref[sec:b]{\it (ii)} as that for the prior subtasks, since $\gamma(v_1)$  becomes true before $\gamma(v_1, v_2)$ (see green edges in Fig.~\ref{fig:routing}).

So far we have constructed starting locations corresponding to the literal $\ap{i}{j}{k,\chi}$ in $\mathsf{lits}^+(\ccalC_p^{\gamma})$ [lines~\ref{milp:i2}-\ref{milp:iii}, Alg.~\ref{alg:milpgraph}]. We need to continue construct starting locations for all other literals in~$\mathsf{lits}^+(\ccalC_p^{\gamma})$ [line~\ref{milp:lits},  Alg.~\ref{alg:milpgraph}] and other clauses in $\clause{\gamma}$ [line~\ref{milp:clause2},  Alg.~\ref{alg:milpgraph}].
After constructing all edges pointing to vertices associated with literals in the edge label $\gamma(v_1, v_2)$ of the current subtask $e$ [line~\ref{milp:e},  Alg.~\ref{alg:milpgraph}], we next construct  edges pointing to vertices associated with literals in the starting vertex label $\gamma(v_1)$ if it is  neither $\top$ nor $\bot$, by identifying leaving vertices among vertices associated with initial robot locations and locations of prior subtasks,


Specifically, let $S_2^e = X_{\prec_P}^e \cup X_{\|_P}^e$ be the set that collects all subtasks that can occur immediately prior to subtask $e$, that is, the satisfaction of edge labels  of subtasks in $S_2^e$  can directly lead to the starting vertex $v_1$ of $e$.

\paragraph{(a) If $S_2^e = \emptyset$:}\label{edge:vertex1} The subtask $e$ should be the first one among all to be completed. Thus, $v_1$ is identical to $v_0$. In this case,  we only identify leaving vertices that are associated with initial robot locations, as in case~\hyperref[sec:a]{\it (i)} [lines~\ref{milp:repeati},  Alg.~\ref{alg:milpgraph}].

\paragraph{(c) If $S_2^e \neq \emptyset$ and $v_1 \neq \vertex{accept}$: }\label{edge:vertex2} Note that when $\vertex{accept}$ does not have self-loop, $v_1$ can not be $\vertex{accept}$. When $\vertex{accept}$ appears as $v_1$, the subtask $(\vertex{accept}, \vertex{accept}')$ must be the last subtask to be completed since it appears a the end of each simple path. To reduce the size of the routing graph $\ccalG$, we only identify leaving vertices associated with prior subtasks in $S_2^e$. Given a subtask $e' = (v_1', v_2') \in S^e_2$, for the edge label $\gamma'$ of $e'$, we find all clauses $\ccalC_{p'}^{\gamma'} \in  \clause{\gamma'}$ such that the clause $\ccalC_p^\gamma \in \clause{\gamma} $ under consideration is their subformula. Such clauses exist (maybe more than one) in $\clause{\gamma'}$ based on the condition~\hyperref[cond:d]{\it (d)} regarding strong implication in Definition~\ref{defn:run} and removing of edges that do not meet condition~\hyperref[cond:d]{\it (d)} in step~\hyperref[prune:infeasible]{\it (f)} in Section~\ref{sec:prune}. Next, for each literal $\ap{i}{j}{k,\chi} \in \mathsf{lits}(\ccalC_p^\gamma)$, we create $i$ one-to-one edges starting from those $i$ vertices that are associated with the counterpart  of literal  $\ap{i}{j}{k,\chi}$ in the found clause  $\ccalC_{p'}^{\gamma'} \in \clause{\gamma'}$  and ending at the $i$ vertices associated with $\ap{i}{j}{k,\chi}$ [lines~\ref{milp:repeatiii},  Alg.~\ref{alg:milpgraph}]. In this way, the conditions~\hyperref[asmp:b]{\it (b)} and~\hyperref[asmp:c]{\it (c)} in Assumption~\ref{asmp:same} are met, that is, the satisfied clause in the edge label strongly implies the satisfied clause in the end vertex label, and they are satisfied by the same fleet of robots. Moreover, if $X_{\prec_P}^e = \emptyset$ and $X_{\|_P}^e \neq \emptyset$, then subtask $e$ can be the first one among all to be completed. In this case, its starting vertex label $\gamma(v_1)$  should be satisfied at the beginning, but leaving vertices associated with other edge labels can not achieve this. Therefore, we additionally create leaving vertices associated with initial robot locations for the vertex label $\gamma(v_1)$, as in  case~\hyperref[sec:a]{\it (i)}. For instance, in Fig.~\ref{fig:id}, subtasks $(v_1, v_4)$ and $(v_1, v_2)$ are independent. If $(v_1, v_4)$ is the first one to be completed and $(v_4, v_3)$ follows, then, the leaving vertices pointing to vertices associated with  $\gamma(v_1)$ should corrsepond to the initial locations, and the leaving vertices pointing to vertices associated with $\gamma(v_4)$ should correspond to the incoming edge label $\gamma'$. Note that there is no need to create such leaving vertices pointing to initial locations if $X_{\prec_P }^e \neq \emptyset$ since subtask $e$ is impossible to occur first, and its starting vertex is strongly implied by the incoming edge label.

\paragraph{(b) If $S_2^e \neq \emptyset$ and $v_1 = \vertex{accept}$:}\label{edge:vertex3} We identify leaving vertices among vertices associated with initial robot locations (as in case ~\hyperref[sec:a]{\it (i)} ) and locations of prior subtasks (as in case ~\hyperref[sec:a]{\it (ii)}), [lines~\ref{milp:repeatii},  Alg.~\ref{alg:milpgraph}], since by condition~\hyperref[cond:d]{\it (d)} in the Definition~\ref{defn:run}, there is no strong implication requirement for the accepting vertex.



Finally,  when the iteration over all subtasks in $X_{P}$ is over, we finish the construction of  the edge set $\ccalE_\ccalG$ [line~\ref{milp:for2},  Alg.~\ref{alg:milpgraph}].


 \subsection{Formulation of the MILP problem}\label{sec:milp}
 In this section, as indicated by block 4 in Fig.~\ref{fig:overview}, we propose an MILP-based method inspired by the vehicle routing problem (VRP) with temporal constraints~\cite{bredstrom2008combined} to solve the LTL-MRTA problem that is graphically captured by the routing graph $\ccalG$. In the VRP, a fleet of vehicles traverse a given set of customers such that all vehicles depart from and return to the same depot and each customer is visited by exactly one vehicle. Normally, a weighted graph is built first with vertices corresponding to the customers and the depot, edges corresponding to the paths the vehicles can travel along, and edge weights representing the the travel cost, e.g., energy and time. Then,  a MILP-based model can be formulated to solve the problem. Compared to the VRP, the MRTA-LTL problem is significantly more complex. First, robots are not required  to return to their initial locations, instead there may exist robots that need to execute the task forever due to the  ``always'' operator. Second, there may exist  labeled regions that do not need to be  visited at all and others that need to be visited exactly once,  more than once, or even infinitely  many times. Finally, temporal constraints may exist  among robots. For example, robots that execute a cooperative subtask together are subject to synchronization constraints and robots that execute two different subtasks can be subject to precedence constraints. In what follows, we formulate an MILP to solve this MRTA-LTL problem.


Given the routing graph $\ccalG$, the robots move along $\ccalG$ to drive the transition in~$\auto{subtask}^-$ from $v_0$ to $v'_{\text{accept}}$ or $v'_{\text{next}}$. To formulate the MILP, we define two types of variables: the routing variables $x_{uvr} \in\{0, 1\}$ and the scheduling variables $t^-_{vr}, t^+_{vr} \in \mathbb{N}$, where $x_{uvr}=1$  if robot  $r\in \ccalM^\ccalV_\ccalK(v)$ traverses the edge $(u,v) \in \ccalE_\ccalG$, and $t^-_{vr}, t^+_{vr}$ are times when robot $r$ should arrive at and is allowed to leave from vertex $v \in \mathcal{V}_\ccalG$. We assume that robot $r$ is still at vertex $v$ at departure time $t^+_{vr}$. Since the satisfaction of the edge label is instantaneous, if $v \in \ccalV_\ccalG$ is associated with an edge label, we have
  $t_{vr}^- = t_{vr}^+$, which means that the robot is allowed to leave at the next time instant. As for the vertex label, we have $t_{vr}^-  \leq t_{vr}^+$, which means that the robot should stay where it is to wait for the satisfaction of the corresponding edge label. Below, we describe  different types of constraints and the objective function of the proposed MILP.
\subsubsection{Routing constraints:} These constraint restrict the flow when the robot traverses between connected vertices in $\ccalV_\ccalG$. Specifically, $\forall\, v \in \ccalV_\ccalG\setminus\ccalV_{\text{init}}$, the constraint that  $v$ is visited by at most one robot belonging to type $\ccalM^\ccalV_{\ccalK}(v)$ can be encoded as
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}
   & \sum_{u:(u,v)\in \ccalE_\ccalG} \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} x_{uvr}  \leq 1, \;\forall\, r \in \ccalM^\ccalV_{\ccalK}(v), \label{eq:1}
\end{align}
\endgroup
which does not take the strict equality since the clause that vertex $v$ is associated with can be false, so there is no need to visit this vertex. Moreover, the flow constraint on a vertex, $\forall \,v \in \ccalV_\ccalG\setminus\ccalV_{\text{init}}$, that the inflow is no less than the outflow, which hints that the robot can remain idle if it is not assigned a subtask, can be encodes as
 \begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}
& \sum_{w:(v,w)\in \ccalE_\ccalG} x_{vwr}   \leq  \sum_{u:(u,v)\in \ccalE_\ccalG} x_{uvr}, \;\forall\, r \in \ccalM^\ccalV_{\ccalK}(v). \label{eq:2}
\end{align}
\endgroup
Then, $\forall \,v \in \ccalV_{\text{init}}$, the initial conditions of~\eqref{eq:2} are
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{subequations}\label{eq:2.5}
  \begin{align}
    & \sum_{w:(v,w)\in \ccalE_\ccalG} x_{vwr}  \leq 1, \;\text{if}\; r = r_v \in \ccalM^\ccalV_{\ccalK}(v), \label{eq:2.5a}\\
    & \sum_{w:(v,w)\in \ccalE_\ccalG} x_{vwr}  = 0, \;\forall r \in \ccalM^\ccalV_{\ccalK}(v)\setminus \{ r_v\}, \label{eq:2.5b}
  \end{align}
\end{subequations}
\endgroup
where $r_v$ refers to the specific robot at the initial location $\ccalM^\ccalV_{\ccalL}(v)\in s^0$ if $v \in \ccalV_{\text{init}}$.
 \subsubsection{Scheduling constraints:} These capture the timing relation on a vertex or between visitation of two connected vertices. First, we require positivity of the scheduling variables, $\forall \, v \in \ccalV_\ccalG$, i.e.,
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align} \label{eq:3}
  0 \leq t_{vr}^{-}, t_{vr}^+ \leq M_{\text{max}} \sum_{u:(u,v)\in \ccalE_\ccalG} x_{uvr}& , \forall r\in \ccalM^\ccalV_{\ccalK}(v),
\end{align}
\endgroup
where $M_{\text{max}}$ is a large positive integer. The constraint~\eqref{eq:3} implies that $t_{vr}^- = t_{vr}^+ = 0$ if $v$ is not visited by robot $r$. The initial condition of~\eqref{eq:3} is
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}\label{eq:3.5}
   t_{vr}^- = t_{vr}^+ = 0,  \quad   \;\forall r \in \ccalM^\ccalV_{\ccalK}(v), \;\forall\, v \in \ccalV_{\text{init}}.
\end{align}
\endgroup
The scheduling constraints between visitation of two connected vertices considering the travelling time, $\forall\, r\in \ccalM^\ccalV_{\ccalK}(v),\, \forall \,(u,v)\in \ccalE_\ccalG$, are
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{subequations}\label{eq:4}
  \begin{align}
    & \hspace{-0.6em} t_{ur}^+ +  T^*_{uv} x_{uvr} \leq  \,t_{vr}^- + M_{\text{max}} (1 - x_{uvr}), \nonumber \\
    &  \pushright{\text{if}\;  u\in \ccalV_{\text{init}}\; \text{or}\; u<_{P}v \; \text{or}\; (u,v)\in X_P,} \label{eq:4b} \\
    & \hspace{-0.6em}t_{ur}^+  + (T^*_{uv} + M_{\min})  x_{uvr}  \leq t_{vr}^- + M_{\text{max}} (1 - x_{uvr}),  \nonumber \\
    & \pushright{\text{if}\; u\|_{P} v,} \label{eq:4a}
  \end{align}
\end{subequations}
\endgroup
where $M_{\text{min}}$ is a small positive integer, $T^*_{uv}$ is the travelling time from $u$ to $v$, $u \in \ccalV_{\text{init}}$ means the starting vertex $u$ is the initial vertex in case~\hyperref[sec:a]{{\it (i)}}, $u \|_{P} v$ and $u<_{P} v$ mean that the subtask $\ccalM^\ccalV_{{e}}(u)$ is incomparable to or smaller than $\ccalM^\ccalV_e(v)$, which corresponds to the case~\hyperref[sec:b]{{\it (ii)}} where $u$ is associated with prior substasks, and $(u,v)\in X_P$ points to case~\hyperref[sec:c]{{\it (iii)}} where $u$ is associated with the vertex label and $v$ is associated with the edge label of the same subtask. We set $T^*_{uv}$ as the shortest travelling time between two regions. When $x_{uvr}=1$, constraint~\eqref{eq:4b} becomes $t_{ur}^+  + T^*_{uv}  \leq t_{vr}^-$ and constraint~\eqref{eq:4a} becomes $t_{ur}^+  + T^*_{uv} + M_{\text{min}}   \leq t_{vr}^-$. Because $T^*_{uv} \geq 0$, constraints~\eqref{eq:4} ensure that $t_{vr}^-$ should be no less than $t_{ur}^+$ if $x_{uvr}=1$. Note that a cycle in $\ccalG$ must include a pair of incomparable vertices, since all comparable vertices constitute a chain. Constraint~{\eqref{eq:4a} avoids cycles in $\ccalG$ where all vertices correspond to the same region. E.g., consider such a cycle $u_1,u_2,\ldots, u_c, u_1$. Without  constraint~\eqref{eq:4a}, zero travelling time will be exploited by constraints~\eqref{eq:1},~\eqref{eq:2} and~\eqref{eq:4b}, generating a solution $x_{u_1 u_2 r} = ,\ldots,=x_{u_c u_{1} r}= 1$ for a robot $r$, without this robot actually visiting any vertex from its initial location.  Constraint~\eqref{eq:4a} is functionally similar to the subtour elimination constraint in vehicle routing problems which prevents any solution that consists of a disconnected tour. We leverage a small positive value $M_{\text{min}}$ to ensure that time increases along the edge that connects incomparable vertices, thus preventing the visitation of a cycle.

  \subsubsection{Logical constraints:}\label{sec:labelconstraints} These encode the logical relation between labels, clauses and literals, and the realization of literals.
                {Given a subtask $e\in X_P$, every vertex or edge label  $\gamma  = \bigvee_{p\in \ccalP} \bigwedge_{q\in \ccalQ_p} \ap{i^q}{j^q}{k^q,\chi^q}$ (neither $\top$ nor $\bot$) is true as long as one of its clauses is true.  To this end, we associate each clause  $\ccalC_{p}^{\gamma} \in \clause{\gamma}$ with a binary variable $b_p$ such that $b_p=1$ if $\ccalC_{p}^{\gamma}$ is true. Hence, $\gamma$ being true can be encoded as
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}\label{eq:c}
   \sum_{p  \in \ccalP} b_p = 1.
\end{align}
\endgroup
That is, one and only one clause is true, which is justified by the Assumption~\ref{asmp:same} that the same clause of a vertex label is satisfied within a consecutive time period. The logical relation, between a clause and its literals, that the satisfaction of the clause is equivalent to the satisfaction of all its literals, can be encoded as
\begingroup\makeatletter\def\f@size{9}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}
 \!\!\!  \left. \left[ \sum_{q\in \ccalQ_p} \sum_{v \in \ccalM^\mathsf{lits}_{\ccalV}(e,0|1,p,q)} \sum_{u: (u,v) \in \ccalE_\ccalG} \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} x_{uvr} \right] \middle/ {\sum_{q\in \ccalQ_p} i^q} \right.= b_p, \label{eq:6}
\end{align}
\endgroup
which also bridges the routing variables $x_{uvr}$ with the logical variables $b_p$. In words, if $b_p=1$, then every vertex corresponding to the $p$-th clause should be visited by one robot.
{Let $$z_{q} = \sum_{v \in \ccalM^\mathsf{lits}_{\ccalV}(e,0|1,p,q)} \sum_{u: (u,v) \in \ccalE_\ccalG} \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} x_{uvr}$$ be the inner summation. If $b_p=1$, then all literals in $\ccalC_p^{\gamma}$ are true. In this case, for the $q$-th literal $\ap{i^q}{j^q}{k^q,\chi^q} \in \mathsf{lits}^+(\ccalC_p^\gamma)$, all $i^q$ vertices in ${\ccalM^\mathsf{lits}_{\ccalV}(e,0|1,p,q)}$ should be visited, so $\sum_{u: (u,v) \in \ccalE_\ccalG} \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} x_{uvr} = 1$ for each vertex $v \in {\ccalM^\mathsf{lits}_{\ccalV}(e,0|1,p,q)}$, and therefore $z_{q}= i^q$, and the left side of constraint~\eqref{eq:6} becomes $ \sum_{q\in \ccalQ_p} z_q/ {\sum_{q\in \ccalQ_p} i^q} = {\sum_{q\in \ccalQ_p} i^q}/{\sum_{q\in \ccalQ_p} i^q} = 1 $. If $b_p=0$, all $x_{uvr}$ in constraint~\eqref{eq:6} equal 0, that is, no vertices need to be visited. Combining constraints~\eqref{eq:3} and~\eqref{eq:6}, $\sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t^-_{vr}$ equals 0 if the  clause that $v$ corresponds to is false. That is, a robot remains idle if it is not responsible for the satisfaction of any clause. Furthermore, constraints~\eqref{eq:1} and~\eqref{eq:6} imply that, if visited, each vertex is visisted by only one robot the whole time, which aligns with the Assumption~\ref{asmp:same} that same fleet of robots satisfy the same clause.

    Note that the logical relation in constraint~\eqref{eq:6} only encodes that some vertices should be visited sometime to satisfy the literals, next we encode the synchronization constraint that, if the clause $\ccalC_p^\gamma$ in the edge label $\gamma$ is true, all vertices in~$\ccalM^\mathsf{cls}_\ccalV(e, 1,p)$ should be visited at the same time, since the satisfaction of edge labels is instantaneous.
      We define the pairwise vertex set induced from the clause $\ccalC_p^\gamma$ as  $\ccalV_{\gamma, p}^{\text{sync}} = \{(u,v)\,|\, u, v\in \ccalM^\mathsf{cls}_\ccalV(e,1,p), u\not= v \}$. If $b_p=1$, visiting any pair in $\ccalV_{\gamma, p}^{\text{sync}}$ simultaneously is encoded as
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}
  & \quad\quad  \sum_{r\in \ccalM^\ccalV_{\ccalK}(u)} t_{ur}^-  = \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t_{vr}^- , \quad\forall (u,v) \in \ccalV_{\gamma, p}^{\text{sync}}.\label{eq:7}
\end{align}
\endgroup





\subsubsection{Temporal constraints:}\label{sec:temporal} We first introduce the notion of the activation and completion time of a subtask. Then, given the subtask $e$, there are three types of temporal constraints regarding the activation and completion time,  within the subtask or between subtasks.
\begin{defn}[(Activation and completion time of a subtask or its starting vertex label)]
Given a subtask $e = (v_1, v_2)$, we define the  activation time of a subtask (or its starting  vertex label) as when its vetex label $\gamma(v_1)$ turns true, and the completion time  of a subtask (or its starting vertex label) as when its edge label $\gamma(v_1, v_2)$ becomes true (or the last time its starting vertex label $\gamma(v_1)$ is true). The span of a subtask (or its starting vertex label) starts from the activation time and ends at the completion time.
\end{defn}
\paragraph{(i) Temporal constraints on one subtask:}\label{sec:onesubtask} These capture the containment constraints that the completion time of a subtask should lie in the span of the associated vertex label, or exactly one time instant later than the completion of its vertex label. Intuitively, the ``avoid'' part should be maintained until the ``reach'' part is realized.

For this, define variable  $t_e$ as the completion time of the subtask $e$, i.e., time when its edge label  becomes true. We have  that
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}\label{eq:edgetime}
  t_e = \sum_{p\in \ccalP} \sum_{r\in \ccalM^\ccalV_{\ccalK}(v_p)}t_{v_p r}^-,
\end{align}
\endgroup
where $v_p$ is randomly selected from $\ccalM^\mathsf{cls}_\ccalV(e,1,p)$ due to constraints~\eqref{eq:c} and~\eqref{eq:7} that only one clause is true and all corresponding vertices are visited at the same time.

When the starting vertex $v_1$ has a self-loop, and its label $\gamma(v_1)$ is not  $\top$ (otherwise, there are no associated vertices in $\ccalG$), the containment relation, $\forall\, \ccalC_p^{\gamma} \in \clause{\gamma(v_1)}$ and $\forall v \in \ccalM^\mathsf{cls}_\ccalV(e,0,p)$, can be encoded as
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
  \begin{align}
 \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t_{vr}^-  \leq  t_e \leq
    \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t_{vr}^+ + 1  + M_{\text{max}} (1 - b_{p}). \label{eq:17}
  \end{align}
  \endgroup
  If $b_p=0$, then no robot visits vertex $v$ according to constraint~\eqref{eq:6}, so~ $ \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t_{vr}^- = 0 \leq t_e$, i.e., the left inequality holds. The right one holds obviously. Only when $b_p=1$, does constraint~\eqref{eq:17} come into effect. Constraint~\eqref{eq:17} implies that the span of the subtask is not necessarily equal to the span of the associated vertex label.

  On the other hand, when the starting vertex $v_1$ does not have a self-loop, we have that $v_1$ is identical to the initial vertex $v_0$. Observe that in Fig.~\ref{fig:prefix}, only $v_0$ and $\vertex{accept}$ are allowed to not have self-loops. Furthermore, $\vertex{accept}$ can not be the starting vertex if it does not have a self-loop, since there is no subtask associated with it. In the case of $v_1 = v_0$ and $\gamma(v_0) = \bot$, the edge label of subtask $e$ should be satisfied at time instant 0, i.e.,
  \begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
  \begin{align}
 t_e = 0. \label{eq:tis0}
  \end{align}
  \endgroup


\paragraph{(ii) Temporal constraints on the completion of two sequential subtasks:}\label{sec:constraintonedge}
This imposes the precedence constraint that subsequent subtasks should be completed after the completion of the prior subtasks.   Given the current subtask $e$, we consider its prior subtasks in the set $X^e_{\prec_{P}}$, that is, subtasks that are covered by $e$, other than a larger set $X^e_{<_{P}}$ due to the transitivity of the partial order.
If $X^e_{\prec_{P}}$ is non-empty, we iterate over subtasks in it.  Given $e' \in X^e_{\prec_{P}}$, the fact that the substask $e'$ is completed before the current substask $e$ can be encoded as
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}\label{eq:12}
  t_{e'} +  M_{\text{min}}  \leq t_e, \; \forall \, e' \in X_{\prec P}^e,
\end{align}
\endgroup
where $M_{\text{min}}$ excludes the case where two edge labels become true simultaneously, violating the precedence order.

\paragraph{(iii)  Temporal constraints on  the  completion of the current substask and the activation  of subsequent substasks:}
These capture the precede constraints that the completion of the current subtask $e$ should be at most one time instant earlier than the activation of the subtask immediately after it. Otherwise, the sub-NBA induced from the poset $P$ will be trapped at $e$ if there is no activated subtask immediatedly after it. Recall that the set  $S_2^e = X^e_{\succ_{P}} \cup X^e_{\|_{P}}$ collects all subtasks whose activation can immediately follow the completion of subtask $e$. For each subtask $e'$ in the set $S_2^e$, we define a binary variable $b_{ee'}$ such that  $b_{ee'}=1$ if it is subtask $e'$ that occurs immediately after subtask $e$. In what follows, we proceed based on whether $ X^e_{\succ_{P}} \neq \emptyset$.

\paragraph{(a) $ X^e_{\succ_{P}} \neq \emptyset$:}\label{activation:a} In this case, there exists a subtask that occurs after $e$. Then, the  constraint that there must be a subtask in $S_2^e$ that occurs immediately after it can be encoded as
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}\label{eq:bafter}
 \sum_{e'\in  S_2^e} b_{ee'} = 1.
\end{align}
\endgroup
If the subtask $e'$ occurs immediately  after subtask $e$, then it should be completed after subtask $e$, that is,
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}\label{eq:after}
  t_e + 1 \leq  t_{e'} + M_{\text{max}} (1 - b_{ee'}),\; \forall\, e' \in S_2^e.
\end{align}
\endgroup
Note that $t_e$ can not be equivalent to $t_{e'}$, otherwise, when subtask $e$ is completed, it is still possible that no subtask is being or about to be activated  at the next time instant (subtask $e'$ has been completed). Furthermore, the subtask $e'$ that occurs immediately  after subtask $e$ should be activated at most one time instant later than the completion of $e$. That is,  if $\gamma(e')$ is not $\top$, then $\forall\, e' \in S_2^e, \forall \, \ccalC_p^{\gamma(e')} \in \clause{\gamma(e')} , \forall \,v \in \ccalM^\mathsf{cls}_\ccalV(e',0,p)$, we have that
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}\label{eq:20}
  & \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t_{vr}^-   \leq t_{e}  + 1 + M_{\text{max}} (1 - b_{ee'}).
\end{align}
\endgroup
If $\gamma(e')=\top$, we can view that subtask $e'$ is activated since the beginning, thus,~\eqref{eq:20} is satisfied trivially.

\paragraph{(b)  $ X^e_{\succ_{P}} = \emptyset$:} In this case, if subtask $e$ is completed after  subtasks in  $X_{\|_P}^e$, then it is the last  subtask  to be completed in  $X_P$. Thus, there is no subtask to be activated any more. Otherwise, if subtask $e$ is not the last subtask, then there exists a subtask that occurs after $e$, same as the case in~\hyperref[activation:a]{\it (a)}. To determine whether subtask $e$ is the last subtask, we define $|X_P|^2$ binary variables $b_{e}^{e'}, \forall e, e' \in X_P$,  such that $b_{e}^{e'}=1$  iff $t_{e} \geq t_{e'}$, that is, iff subtask $e$ is completed after $e'$. This implication can be encoded as
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}
  M_{\text{max}} (b_{e}^{e'} - 1) \leq t_e -  t_{e'} \leq M_{\text{max}} b_{e}^{e'} -1,
\end{align}
  \endgroup
 where the terms $-1$ on the right side is used to enforce $b_{e}^{e'}=1$ if $t_e = t_{e'}$. Furthermore, we define $z = |X^e_{\|_{P}}|$. Observe that, for $e' \in X^e_{\|_{P}} $, the term $z -  \sum_{e' \in X^e_{\|_{P}}  } b_{e}^{e'} = 0$ if $e$ is the last completed task, otherwise  positive.

If subtask $e$ is not the last subtask, there should be a subtask in $X^e_{\|_{P}}$ that occur immediately after $e$, which can be encoded as
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{subequations}\label{eq:afterparallel}
  \begin{align}
  \sum_{e' \in X_{\|_P}^e} b_{ee'} & \le 1,\label{eq:afterparallel_a}\\
  z - \sum_{e' \in X^e_{\|_{P}}  } b_{e}^{e'} - M_{\text{max}}  \sum_{e' \in X_{\|_P}^e} b_{ee'} &  \leq 0, \label{eq:afterparallel_b} \\
 % \sum_{e' \in X_{\|_P}^e} b_{ee'} & \leq 1.
  %% M_{\text{max}} ( \sum_{e' \in X^e_{\|_{P}}  } b_{e}^{e'} -   z ) & \leq
  \sum_{e' \in X_{\|_P}^e} b_{ee'} - M_{\text{max}}(z -  \sum_{e' \in X^e_{\|_{P}}  } b_{e}^{e'}) & \leq0 . \label{eq:afterparallel_c}
\end{align}
\end{subequations}
\endgroup
If subtask $e$ is completed no earlier than subtasks in  $X_{\|_P}^e$, then $z - \sum_{e' \in X^e_{\|_{P}}  } b_{e}^{e'} = 0$, we have $ \sum_{e' \in X_{\|_P}^e} b_{ee'}=0$ according to constraint~\eqref{eq:afterparallel_c}, that is, there is no subtask required to follow $e$ immediately. Otherwise, if subtask is not the last subtask, i.e., $z - \sum_{e' \in X^e_{\|_{P}}  } b_{e}^{e'} > 0$, then we have $ \sum_{e' \in X_{\|_P}^e} b_{ee'}=1$ according to constraints~\eqref{eq:afterparallel_a} and~\eqref{eq:afterparallel_b}. Finally, we can impose the same constraints as~\eqref{eq:after} and~\eqref{eq:20}.

Another constraint is that, after the activation of the current subtask, i.e., $\gamma(v_1)$ becomes true, it should remain true until all subtasks in $X^e_{\prec_P}$ are completed. Otherwise, since the subtask $e$ should be completed when $\gamma(v_1)$ remains true or at the same time  $\gamma(v_2)$ becomes false, it will complete earlier than some subtasks in $X^e_{\prec_P}$. In this case, the precedence relation that subtasks in $X^e_{\prec_P}$ are completed before $e$ will be violated. This constraint, $\forall \, \ccalC_p^{\gamma} \in \clause{\gamma} , \forall \,v \in \ccalM^\mathsf{cls}_\ccalV(e,0,p)$,  $\forall\, e' \in X^e_{\prec_P}$,  can be encoded as,
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}\label{eq:redundant}
   t_{e'} + M_{\text{min}}   \leq  \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t_{vr}^+   + M_{\text{max}}(1 - b_p).
\end{align}
\endgroup
Indeed, constraint~\eqref{eq:redundant} is redundant, which can be enforced by constraints~\eqref{eq:17} and~\eqref{eq:12}. In constraint~\eqref{eq:17} we have $t_e \leq    \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t_{vr}^+ + 1 + M_{\text{max}} (1 - b_{p})$ and in~\eqref{eq:12}, we have $ t_{e'} +  M_{\text{min}}  \leq t_e$. Therefore, $t_{e'} +  M_{\text{min}} \leq  \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t_{vr}^+  + 1 + M_{\text{max}} (1 - b_{p})$.

%% To determine this first satisfied subtask in $S_2^e$, we define $|X_{P}|^2$ binary variables $b_{e'}^{o}, \forall e', o \in X_{P}$,  such that $b_{e'}^{o}=1$  iff $t_{e'} \leq t_{o}$, that is, iff $e'$ is satisfied no later than  $o$. This implication can be encoded as
%% \begingroup\makeatletter\def\f@size{10}\check@mathfonts
%% \def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
%% \begin{align}
%%   M_{\text{min}} -  M_{\text{max}} b_{e'}^{o} \leq t_{e'} -  t_{o} \leq M_{\text{max}} (1- b_{e'}^{o}) ,
%% \end{align}
%%   \endgroup
%%  where $M_{\text{min}}$ is a small positive number and it is used to enforce $b_{e'}^{o}=1$ if $t_{e'} = t_{o}$. Furthermore, we define $z = |S_2^e| -1$. Observe that, for $e' \in S_2^e $, the term $z -  \sum_{o \in S_2^e\setminus \{e'\}  } b_{e'}^o = 0$ if $e'$ is the first completed task, otherwise  positive.

%%  Assuming that $S_2^e$ is non-empty, then if $e'$ is the first completed subtask in $S_2^e$, it should be activated at most one time instant later than the completion of the current subtask $e$, that is,  $\forall\, e' \in S_2^e, \forall \, \ccalC_p^{\gamma(e')} \in \clause{\gamma(e')} , \forall \,v \in \ccalM^\mathsf{cls}_\ccalV(e',0,p)$, the precedence constraint is
%% \begingroup\makeatletter\def\f@size{10}\check@mathfonts
%% \def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
%% \begin{align}\label{eq:20}
%%   & \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t_{vr}^-   \leq t_{e}  + 1 +
%%   M_{\text{max}} \Big(z  - \sum_{o \in S_2^e\setminus \{e'\}} b_{e'}^o\Big).
%% \end{align}
%% \endgroup
%% Only when $ \sum_{o\in S_2^e\setminus \{e'\}} b_{e'}^o = z $, does~\eqref{eq:20} come into effect.

%% \paragraph{(iii) Temporal constraints on  the  activation of the current substask and the completion  of prior substasks:}
%% These capture the precedence constraints that the activation of the current subtask $e$  should be at most one time instant later than the the completion of the last subtask that can occur prior to it. Otherwise, the sub-NBA induced from the poset $P$ will be trapped at $e$ since all subtasks that can be completed  before $e$ have been satisfied.  Let $S_2^e = X^e_{\prec_{P}} \cup X^e_{\|_{P}}$ collect all subtasks whose satisfaction can directly lead to the starting vertex $v_1$ of $e$. To determine this last satisfied subtask in $S_2^e$, we define $|X_{P}|^2$ binary variables $b_{e}^{e'}, \forall e, e' \in X_{P}$,  such that $b_{e}^{e'}=1$  iff $t_e \geq t_{e'}$, that is, iff $e$ is satisfied after $e'$. This implication can be encoded as}
%% \begingroup\makeatletter\def\f@size{10}\check@mathfonts
%% \def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
%% \begin{align}
%%   M_{\text{max}} (b_{e}^{e'} - 1) \leq t_e -  t_{e'} \leq M_{\text{max}} b_{e}^{e'} - M_{\text{min}},
%% \end{align}
%%   \endgroup
%%   where $M_{\text{min}}$ is a positive number that is smaller than or equal to the minimum possible gap between $t_e$ and $t_{e}$ if $t_e \not= t_{e}$, and it is used to enforce $b_{e}^{e'}=1$ if $t_e = t_{e'}$. Furthermore, we define $z = |S_2^e| -1$. Observe that, for $e' \in S_2^e $, the term $z -  \sum_{o \in S_2^e\setminus \{e'\}  } b_{e'}^o = 0$ if $e'$ is the last fulfilled task, otherwise  positive.

%% We first assume that $S_2^e$ is non-empty, then  the starting vertex of $e$ has a self-loop, $\forall \, \ccalC_p^{\gamma} \in \clause{\gamma} , \forall \,v \in \ccalM^\mathsf{cls}_\ccalV(e,0,p), \forall e' \in S_2^e$, the precedence constraint is
%% \begingroup\makeatletter\def\f@size{10}\check@mathfonts
%% \def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
%% \begin{align}\label{eq:20}
%%   & \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t_{vr}^-   \leq t_{e'}  + 1 +
%%   M_{\text{max}} \Big(z  - \sum_{o \in S_2^e\setminus \{e'\}} b_{e'}^o\Big).
%% \end{align}
%% \endgroup
%% Only when $ \sum_{o\in S_2^e\setminus \{e'\}} b_{e'}^o = z $, does~\eqref{eq:20} come into effect.

\paragraph{(iv) Temporal constraints on the activation of the first subtask}
If the subtask $e$ is the first subtask to be completed, there is no subtask whose completion activates $e$. Let $P_{\text{max}}$ be the set that collects subtasks that can be the first one to be completed, which are referred to as the maximal element in a poset $P$. An elment in a poset $P$ is a maximal element if there is no element in $P$ larger than it. To determine this first satisfied subtask in $P_{\text{max}}$ if $|P_{\text{max}}|>1$, we define $|P_{\text{max}}|^2$ binary variables $\tilde{b}_{e}^{e'}, \forall e, e' \in P_{\text{max}}$,  such that $\tilde{b}_{e}^{e'}=1$  iff $t_{e} \leq t_{e'}$, that is, iff $e$ is satisfied no later than  $e'$. This implication can be encoded as
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}
  1 -  M_{\text{max}} \tilde{b}_{e}^{e'} \leq t_{e} -  t_{e'} \leq M_{\text{max}} (1- \tilde{b}_{e}^{e'}) ,
\end{align}
  \endgroup
  where the term $1$ on the left side  is used to enforce $\tilde{b}_{e}^{e'}=1$ if $t_{e} = t_{e'}$. Furthermore, we define $z = |P_{\text{max}}| -1$. Observe that, for $e \in P_{\text{max}} $, the term $z -  \sum_{e' \in P_{\text{max}}\setminus \{e\}  } \tilde{b}_{e}^{e'} = 0$ if $e'$ is the first completed task, otherwise  positive. If the first completed subtask $e = (v_1 ,v_2)$ has a self-loop and the vertex label is not $\top$ (otherwise, there are no associated vertices in $\ccalG$), we have that the vertex label $\gamma(v_1)$ should be activated at time 0, and the corresponding vertices should be visited at 0,   i.e., $\forall\, e \in P_{\text{max}}, \forall\, \ccalC_p^{\gamma(v_1)} \in \clause{\gamma(v_1)}, \forall \,v \in \ccalM^\mathsf{cls}_\ccalV(e,0,p)$,
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}\label{eq:zeroactivation}
  & \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t_{vr}^-  \leq M_{\text{max}} (z -  \sum_{e' \in P_{\text{max}}\setminus \{e\}  } \tilde{b}_{e}^{e'} + 1- b_p).
\end{align}
\endgroup
Only when $e$ is the first subtask, i.e, $z -  \sum_{e' \in P_{\text{max}}\setminus \{e\}  } \tilde{b}_{e}^{e'}=0$ and the associated clause is true ($b_p=1$), can the vertices be visited by robots at time 0. When $|P_{\text{max}}=1|$, constraint~\eqref{eq:zeroactivation} will be reduced to  $ \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t_{vr}^-  \leq M_{\text{max}} (1- b_p).$ If the vertex label $\gamma(v_1)$ has no self-loop, then $v_1$ is idential to $v_0$. We have discussed in constraint~\eqref{eq:tis0} the case where $v_0$ does not have a self-loop. %% If $v_1$ has a self-loop and  the vertex label $\gamma(v_1)$ is not $\top$(otherwise, there are no associated vertices in $\ccalG$), we have that the vertex label $\gamma(v_1)$ should be activated at time 0, i.e., $\forall\, \ccalC_p^{\gamma} \in \clause{\gamma}$,
%% \begingroup\makeatletter\def\f@size{10}\check@mathfonts
%% \def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
%% \begin{align}\label{eq:zeroactivation}
%%   & \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t_{vr}^-  \leq M_{\text{max}} (1- b_p), \;\forall \,v \in \ccalM^\mathsf{cls}_\ccalV(e,0,p).
%% \end{align}
%% \endgroup

Recall that in case~\hyperref[edge:vertex3]{\it (c)}  when constructing the edges for vertex labels of subtasks in $P_{\text{max}}$, leaving vertices fall into 2 categories, one category for initial vertices and the other for prior subtasks. To meet the conditions~\hyperref[asmp:b]{\it (b)} and~\hyperref[asmp:c]{\it (c)} in the Assumption~\ref{asmp:same} that the satisfied clause in the edge label stronly implies the satisfied clause in the end vertex label and the same fleet of robots satisfy these two clauses, we require that, the starting vertex label of the first completed  subtask in $P_{\text{max}}$ should be satisfied by robots coming from the initial vertices $\ccalV_{\text{init}}$ in $\ccalG$, and the starting vertex label of the remaining subtasks in $P_{\text{max}}$ should be satisfied by robots coming from vertices in $\ccalG$ that are associated with edge labels of prior subtasks. To this end, we first define an auxilary binary variable $b_{e}^{\prec}$ such that $b_{e}^{\prec}= 1$ if subtask $e$ is the first subtask in $P_{\text{max}}$, that is,
\begin{subequations}
  \begin{align}
    z - \sum_{e' \in P_{\text{max}}\setminus \{e\}} \tilde{b}_e^{e'}  - M_{\text{max}} (1 - b_{e}^{\prec}) & \leq 0\\
    1 - b_{e}^{\prec} -  M_{\text{max}} (z - \sum_{e' \in P_{\text{max}}\setminus \{e\}} \tilde{b}_e^{e'})     & \leq 0
  \end{align}
\end{subequations}
Only when $z = \sum_{e' \in P_{\text{max}}\setminus \{e\}} \tilde{b}_e^{e'}$, we get that $b_e^{\prec}=1$. Then, for any clause in the starting vertex label of $e$, the constraints regarding the categories of leaving vertices can be encoded as, $\forall \, \ccalC_p^\gamma \in \clause{\gamma} $,
\begin{subequations}\label{eq:routingforactivation}
  \begin{align}
   & \sum_{q\in \ccalQ_p} \sum_{v \in \ccalM^\mathsf{lits}_{\ccalV}(e,0,p,q)} \sum_{\substack{u: (u,v) \in \ccalE_\ccalG \\ u \not\in \ccalV_{\text{init}}}}   \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} x_{uvr} \leq M_{\text{max}} (1 - b_e^{\prec}),  \label{eq:routingforactivation_a}\\
   & \sum_{q\in \ccalQ_p} \sum_{v \in \ccalM^\mathsf{lits}_{\ccalV}(e,0,p,q)} \sum_{\substack{u: (u,v) \in \ccalE_\ccalG \\ u \in \ccalV_{\text{init}}}}   \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} x_{uvr} \leq M_{\text{max}}  b_e^{\prec}.  \label{eq:routingforactivation_b}
  \end{align}
\end{subequations}
where $u \in \ccalV_{\text{init}}$ means that vertex $u$ falls into the category of  $\ccalV_{\text{init}}$ in $\ccalG$. When subtask $e$ is the first subtask to be completed in $P_{\text{max}}$, i.e., $b_e^{\prec}=1$, constraint~\eqref{eq:routingforactivation_a}, combining with constraint~\eqref{eq:6}, says that robots should come from the vertices in~$\ccalV_{\text{init}}$. However, when subtask $e$ is not  the first subtask to be completed in $P_{\text{max}}$, i.e., $b_e^\prec=0$, constraint~\eqref{eq:routingforactivation_b} requires that robots should come from vertices associated with prior subtasks.

\subsubsection{Same-$\ag{i}{j}$ constraints:}\label{sec:samegroup}
Finally, we encode the constraints that some subtasks are executed by the same $\ag{i}{j}$, which are indicated by the same non-zero connector $\chi$. Given a non-zero connector $\chi$, we can locate all labels, vertex or edge labels, that have literals with the same connector $\chi$  by the mapping $\ccalM_\mathsf{\gamma}^\chi(\chi)$. For an edge label $(e, 1)  \in  \ccalM_\mathsf{\gamma}^\chi(\chi)$ or a vertex label $(e, 0)  \in  \ccalM_\mathsf{\gamma}^\chi(\chi)$, each clause has at most one literal $\aap{i}{j}{k}{\chi}$ with connector $\chi$ and it is associated with $i$ vertices in $\ccalG$. We enumerate these $i$ vertices and denote the $b$-th vertex by $v_k^b$. Then for any two labels $\gamma, \gamma'\in\ccalM_\mathsf{\gamma}^a(\chi)$ and any two clauses $\ccalC_p^\gamma \in \clause{\gamma}$ and $\ccalC_{p'}^{\gamma'} \in \clause{{\gamma'}}$ that have  literals $\aap{i}{j}{k}{\chi}$ and $\aap{i}{j}{k'}{\chi}$, respectively, {the constraint} that the corresponding literals are satisfied by the same $\ag{i}{j}$, $\forall \,b \in [i]$ and  $\forall \, r \in \ccalK_j$, can be encoded as
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{subequations}\label{eq:same}
  \begin{align}
    & \sum_{u:(u, v_k^b) \in \ccalE_\ccalG} x_{u v_k^b r} + M_{\text{max}} (b_p - 1) \nonumber \\& \quad\quad\quad \leq  \sum_{u:(u, v_{k'}^b) \in \ccalE_\ccalG} x_{u v_{k'}^b r} + M_{\text{max}}(1 - b_{p'}),\\
    & \sum_{u:(u, v_{k'}^b) \in \ccalE_\ccalG} x_{u v_{k'}^b r} + M_{\text{max}} (b_{p'} - 1) \nonumber \\& \quad\quad\quad \leq \sum_{u:(u, v_{k}^b) \in \ccalE_\ccalG} x_{u v_{k}^b r} + M_{\text{max}}(1 - b_{p}),
  \end{align}
\end{subequations}
\endgroup
where $v_{k'}^b$ is the $b$-th vertex associated with $\aap{i}{j}{k'}{\chi}$. Only when $b_p = b_{p'}=1$, does~\eqref{eq:same} come into effect. Then, $\sum\nolimits_{u:(u, v_k^b) \in \ccalE_\ccalG} x_{u v_k^b r} = \sum\nolimits_{u:(u, v_{k'}^b) \in \ccalE_\ccalG} x_{u v_{k'}^b r} $, i.e., vertices $v_k^b$ and $v_{k'}^b$ are visited by the same robot $r$.

\subsubsection{MILP objective}The objective is to minimize the weighted sum of travelling distance and execution time, i.e.,
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}\label{equ:obj}
  \min \; \;&  \alpha \sum_{(u,v)\in \ccalE_\ccalG}  \sum_{r \in \ccalM^\ccalV_{\ccalK}(v)} w_{uv} x_{uvr} +  (1 - \alpha) \sum_{e\in X_P} t_e,
\end{align}
 \endgroup
  where $\alpha$ is a user-specified parameter.
  \begin{rem}
   Compared to Problem~\ref{prob:1}, the objective~\eqref{equ:obj} involves the optimization of time. In the simulations in Section~\ref{sec:sim}, we observed that without optimizing the time, some scheduling variables can take large values, which impacts the plan execution; see Section~\ref{sec:path}. Note that travel distance and execution time are typically non-conflicting objectives.

  \end{rem}
\subsection{Construction of robot prefix plans from the MILP solution}\label{sec:path}
After solving the MILP discussed in Section~\ref{sec:milp}, we first extract a time axis by sorting the completion times of all subtasks such that each time instant in the time axis is the completion time of one subtask $X_P$. This time axis  will be used in Section~\ref{sec:run} to extract a simple path from the NBA $\auto{subtask}^-$ that connects the initial vertex $v_0$ and the accepting vertex $v_\text{accept}$. Next, we extract a high-level plan for each robot  that will be concretized in Section~\ref{sec:mapp} to generate low-level paths that satisfy the specification $\phi$; see also block 5 in Fig.~\ref{fig:overview}.


\subsubsection{Time axis:} The progress made in the NBA $\auto{subtask}^-$ is directly linked to the satisfaction of the edge label, and also the satisfaction of most edge labels  will lead to the satisfaction of the end vertex labels according to condition~\hyperref[cond:d]{\it (d)} in the Definition~\ref{defn:run}. Therefore, we collect the  set of completion times of all subtasks, evaluated at $t_e$ defined in Section~\ref{sec:constraintonedge}, and sort them in an ascending order to form a unique non-decreasing time axis, denoted by $\vec{t}$. There may exist identical time instants due to the parallel completion of subtasks. To break the tie, we increment each time instant by a small constant if it is identical with its previous one and further shift the remaing instants into the future by the same amount. For instance, by incrementing 1, the time axis $\vec{t}= (3, 4, 4, 7, 7)$ becomes $(3, 4, 5, 8, 9)$, where the number 7 becomes 9 since among those prior to it, 4 becomes 5 and 7 becomes 8.  Note that the satisfaction of  the specification $\phi$ relies upon the relative order between the completion of substasks, other than the exact occurence time. In large part, we mantain the relevant order between these time instants and only slightly stagger completion times of subtasks that are independent. This operation is safe since independent subtasks can happen arbitrarily. The reason we stagger is that independent elementary subtasks that are completed at the same time will enable an edge in the NBA $\autop^-$ that corresponds to a composite subtask, while this edge does not exist in the NBA $\auto{subtask}^-$. Our manipulation prevents this happening with the intention of decomposing complex subtasks and focusing on elementary subtasks.

  \subsubsection{High-level plans for robots:} Next we extract a high-level plan for each robot, which is a sequence of waypoints that are related  to  the completion of subtasks in $X_P$, along with a sequence of associated non-decreasing time instants. For robot $[r,j]$, let $p_{r,j}$ denote its plan and $t_{r,j}$ denote the  timeline. Consider the vertex $v^*_0 \in \ccalV_{\text{init}}$ in the routing graph $\ccalG$ that points to the initial location of  robot $[r,j]$  and let $v^*_1$ be the vertex such that $x_{v^*_0 v^*_1 r} =1$. Recall that each vertex in the routing graph $\ccalG$ is associated with an label that is captured by the mapping $\ccalM_{\mathsf{lits}}^{\ccalV}$ in Section~\ref{sec:vertex}. If the label of $v_1^*$ is a vertex label, we continue to search for vertex $v_2^*$ such that $x_{v_1^* v_2^* r}=1$ until a vertex $v^*$ is found that is associated with an edge label. Then the associated region  $\ccalM^\ccalV_{\ccalL}(v^*)$ is the first waypoint robot $r$ visits to complete a subtask and thus, we add this region $\ccalM^\ccalV_{\ccalL}(v^*)$ to the plan $p_{r,j}$. Next, the visit time  $t^-_{v^* r} = t^+_{v^* r}$ equals the completion time of the associated subtask, which is captured by $\ccalM_{e}^{\ccalV}(v^*)$. Note that each time instant in the time axis $\vec{t}$ corresponds to one subtask.  We adjust this visit time $t^-_{v^* r}$ to be the time instant in $\vec{t}$ that is associated with the same subtask, and then add it to the timeline $t_{r,j}$.   Continuing the above process, we can construct a sequence of waypoints along with the associated timeline where visit times are aligned with time instants in the time axis $\vec{t}$. Based on the high-level plan $\{p_{r,j}\}$, in Section~\ref{sec:solution2mrta} we design low-level executable paths to take into account negative literals and collision avoidance.

%% \blue{The synthesized plan corresponds to the whole or a partial prefix plan
%%   depending on whether a vertex label exists for $\vertex{accept}$, which will be discussed in Section~\ref{sec:suf}. Note that the high-level plans are defined on an abstraction of the environment, minimizing the travelling distance between regions and ignoring inter-robot collision avoidance. Furthermore, these plans are associated with the relaxed automaton $\auto{relax}^-$. In Section~\ref{sec:solution2mrta}, we show how to use these high-level plans to generate low-level executable plans that work for the original automaton $\autop^-$.}
\begin{cexmp}
 {After solving the MILP for the environment in Fig.~\ref{fig:workspace}, the high-level plans and the associated timelines for robots are as follows: $p_{2,1} = p_{3,1} = \{\ell_2, \ell_3\}, t_{2,1} = t_{3,1} = \{4, 12\},    p_{2,2} = \{\ell_4\}$, $t_{2,2} = \{8\}$.    That is, robots $[2,1]$ and $[3,1]$ visit the office building $\ell_2$ at time instant 4, then robot $[2,2]$ visits the road at time instant 8, and finally robots $[2,1]$ and $[3,1]$ visit the  open area $\ell_3$ at time instant 12. The remaining  robots remain idle. Observe that the lengths of the plans differ. The induced run from $\auto{subtask}^-$ in Fig.~\ref{fig:sub-NBA} is $\vertex{init}, v_1, v_2, v_3, v_6, v_{6'}$. The associated time axis  is $\vec{t} = \{0, 4, 8, 12, 13\}$, one time instant each subtask. In words, the subtask $(\vertex{init}, v_1)$ is completed at time instant 0 and the subtask $(v_1, v_2)$ is completed at time instant 4, which corresponds to the event that robots $[2,1]$ and $[3,1]$ visit the office building $\ell_2$ at time instant 4.
  }
\end{cexmp}

\subsection{Construction of robot suffix paths}\label{sec:suf}
The goal of the suffix paths is to drive the progression in the NBA~$\autop^-$ back to the accepting vertex and send robots to final locations of the prefix part to close the trajectory.
We assume that the high-level plan found in Section~\ref{sec:path} for the prefix part  has been used to generate low-level paths as in Section~\ref{sec:solution2mrta} and thus, the final robot locations for the prefix part are given, which will be treated as the initial robot locations of the suffix part. We have discussed the suffix paths when the given accepting vertex $\vertex{accept}$ has a self-loop; see Fig.~\ref{fig:prefix}. In what follows, we construct closed robot paths for the suffix part when $\vertex{accept}$ does not have a self-loop, which drives the transition along a cycle back to $\vertex{accept}$. Intuitively, by viewing the simple cycle around $\vertex{accept}$ as a simple path, we treat the  accepting vertex on the starting side of this simple path as the initial vertex $v_0$ and the other accepting vertex on the ending side as the goal to be reached, then  starting from the NBA $\autop^-$ in Section~\ref{sec:prune}, we  follow the similar procedure as for the prefix part to obtain paths for the suffix part.

  \begin{figure}[!t]
    \centering
    \includegraphics[width=0.5\linewidth]{suffix.pdf}
    \caption{$\auto{subtask}$ for the suffix part when $\vertex{accept}$ does not have a self-loop. $\gamma_1$, $\gamma_2$ and $\gamma_3$ are edge labels and $\pi_{\text{init}}$ is the literal that captures the initial robot configurations; see Section~\ref{sec:suf_milp}.}
    \label{fig:suffix}
  \end{figure}

  \subsubsection{Extracting Subtasks and Infer the Temporal Order from the NBA:}\label{sec:suf_prune}
  \paragraph{(i) Extraction of sub-NBA $\auto{subtask}$ from $\auto{relax}$:} First, based on the NBA $\autop^-$ we obtain the relaxed NBA $\auto{relax}$, as in Section~\ref{sec:prune}.  Then, similar to finding the shortest simple cycle around $\vertex{accept}$ in Section~\ref{sec:sort}, we remove all other accepting vertices from $\auto{relax}$ and then remove all initial vertices if they do not have self-loops. Let $\gamma_\phi(\vertex{prior}, \vertex{accept})$ denote the edge label in the NBA $\autop^-$ that corresponds to the last completed subtask in the prefix part, thus, after generating the low-level paths for the prefix part, the final robot locations of the prefix part satify $\gamma_\phi(\vertex{init}, \vertex{accept})$ (see Fig.~\ref{fig:lasso}).  Next, since $\vertex{accept}$ does not have a self-loop, by condition \hyperref[cond:f]{\it f)} in Definition~\ref{defn:run}, we remove any outgoing edges of $\vertex{accept}$ (acting as $v_0$) from $\auto{relax}$ if $\gamma_\phi(\vertex{prior}, \vertex{accept})$ does not imply its edge label in $\autop^-$. Same as the satisfaction check in Section~\ref{sec:sort}, the implication check is conducted in $\autop^-$ as well. According to condition \hyperref[cond:f]{\it f)}, if the set of restricted accepting runs is non-empty, the  implication holds  for some  outgoing edges of some accepting vertices. Next, we can follow Section~\ref{sec:pregraph} to  extract a sub-NBA $\auto{subtask}$ from $\auto{relax}$ for the pair $\vertex{accept}$ (acting as $v_0$) and $\vertex{accept}$. The structure of $\auto{subtask}$ is shown in Fig.~\ref{fig:suffix}, which is very similar to those in Fig.~\ref{fig:prefix}, except that $v_0$ does not have a self-loop.  Then, we prune $\auto{subtask}$ to obtain the NBA $\auto{subtask}^-$.
  \paragraph{(ii) Infer temporal order between subtasks in $\auto{subtask}^-$:}The following step is to infer the temporal order as in Section~\ref{sec:poset}. Recall that in Section~\ref{sec:poset}, we collect all simple paths in $\Theta$ that connects $v_0$ and $\vertex{accept}$. Here, given such a simple path, before adding it to $\Theta$, we further check whether the label $\gamma_\phi(\vertex{prior}, \vertex{accept})$ implies both  the label of its last edge in $\autop^-$ (serving as $(\vertex{prior}', \vertex{accept})$; see Fig.~\ref{fig:lasso}) and the label of the starting vertex (serving as $\vertex{prior}'$) of the last edge  in $\autop^-$ according to Definition~\ref{defn:implication}.
  %% the initial robot locations of the suffix part satisfy  the corresponding label (including the negative literals) of its last edge in $\autop^-$ (the end vertex of this last edge is $\vertex{accept}$) and the correponding label of the starting vertex of the last edge  in $\autop^-$ according to Definition~\ref{defn:implication}.
  If so, by taking this simple path, not only the transition is driven back to $\vertex{accept}$, but robots can return to their initial locations to close the trajectories. %% while respecting the same-$\ag{i}{j}$ constraints in Section~\ref{sec:samegroup}.
  We highlight that the implication check isconducted in the NBA $\autop^-$ by condition \hyperref[cond:f]{\it f)} in Definition~\ref{defn:run}, as well. By the condition \hyperref[cond:f]{\it f)}, if the set of restricted accepting runs is non-empty, such simple paths exist for some accepting vertices. Finally, we infer the set $\Theta$ of simple paths that meet this extra requirement and  obtain a sorted set of posets $\{P_e\}$ from simple paths in $\Theta$.

  \subsubsection{MILP Solution to the Relaxed Automaton:}\label{sec:suf_milp} To achieve the two goals of returning to initial locations and close the suffix part of an accepting run at the same time, we first define an atomic proposition $\pi_{\text{init}}$ which is true if all robots return to there initial locations at the end of the suffix paths. Next, we find the set of subtasks, denoted by $P_{\text{min}}$, in a given poset $P$ in $\{P_e\}$ that can be the last one to be completed, which are referred to as the minimal elements in a poset. An element in a poset $P$  is a minimal element if there is no element in $P$ smaller than it. Note that the edge labels of all subtasks in $P_{\text{min}}$ can be satisfied by the initial robot locations, since the last edges of all simple paths in $\Theta$ are ensured to be satisfied by the initial robot locations in Section~\ref{sec:suf_prune}, which is the direct consequence of implication.  For each subtask $e = (v_1, v_2) \in P_{\text{min}}$, we augment its edge label $\gamma(v_1, v_2)$ with another clause $\pi_{\text{init}}$, that is, $\gamma(v_1, v_2) = \gamma(v_1, v_2) \vee \pi_{\text{init}}$; see also Fig.~\ref{fig:suffix}. If $e \in P_{\text{min}}$ is truly the last subtask to be completed, we require the clause $ \pi_{\text{init}}$  to be satisfied. If $\pi_{\text{init}}$ is satisfied, the original edge label $\gamma(v_1, v_2)$ before augment will also be satisfied, since initial robot locations satisfy the original edge label of the last completed subtask. Thus, in this way, these two goals of returning to initial locations and close the suffix part of an accepting run are achieved  at the same time.
  \paragraph{(i) Construction of the routing graph:}   Next, given the poset $P$, we build a routing graph $\ccalG = (\ccalV_G, \ccalE_G)$ as in Section~\ref{sec:graph}. Recall that the vertex set $\ccalV_\text{init} \subseteq \ccalV_\ccalG$ contains vertices that point to the initial robot locations. When buidling the vetex set $\ccalV_\ccalG$, each time we encounter a literal $\pi_{\text{init}}$, we creat a copy of vertices in $\ccalV_{\text{init}}$ to be associated with the literal $\pi_{\text{init}}$. These vertices will be visited at the same time by all robots.  Also, we build a one-to-one correspondence between copied vertices and robots since  robots need to return to different initial locations. The other  mappings are created following the way in Section~\ref{sec:vertex}.

  When  building the edge set $\ccalE_\ccalG$, there are no outgoing edges from  vertices that are associated with the literal $\pi_\text{init}$, since these verties will be where robots reside at the final moment. The incoming edges of these vertices are constructed by treating $\pi_{\text{init}}$ as a regular clause (single literal with connector $\chi=0$) of an edge label, as in Section~\ref{sec:edge_set} but with one exception.  Recall that in step~\hyperref[sec:a]{\it {(ii)}}, when identifying the leaving vertices that are associated with prior subtasks,  when the number of leaving vertices is larger than the number of end vertices, we randomly create multiple  one-to-one edges, since all robots visiting these leaving vertices belong to the same type. However, here we create edges from all leaving vertices to each vertex associated with $\pi_{\text{init}}$ since each vertex with $\pi_{\text{init}}$ is only allowed to be visited by a specific robot of a specific type, making all robots heterogeneous in this sense.

 \paragraph{(ii) Formulation of the MILP problem:}  To find a high-level plan, we formulate a MILP problem based on the routing graph $\ccalG$ by following almost identical procedures in Section~\ref{sec:milp} with two exceptions.

\paragraph{\quad (a) same-$\ag{i}{j}$ constraints:} The first exception is the same-$\ag{i}{j}$ constraints in Section~\ref{sec:samegroup}, since we need to maintain the same group of $i$ robots of type $j$ visiting some regions sequentially as those in the prefix plan. Specifically, after solving the MILP for the prefix part, for any connector $\chi\not=0$ that appear in $\phi$, we check whether any literal that includes this connector was involved in the prefix part. If yes, then these literals with the same non-zero connector should be satisfied by the same $\ag{i}{j}$. We denote by $\ccalK^\chi \subseteq \ccalK_j$ the set of $\ag{i}{j}$ that make these literals true and  by  $r^b$ the $b$-th robot in the enumerated set $\ccalK^\chi$. When dealing with the suffix part, for any label $\gamma \in\ccalM_\mathsf{\gamma}^\chi(\chi)$ where literals with connector $\chi$ appear and any clause $\ccalC_p^\gamma \in \clause{\gamma}$ that has  literal $\aap{i}{j}{k}{\chi}$, the constraint that this literal is satisfied by the same $\ag{i}{j}$  can be encoded as}
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}\label{eq:same_suffix}
    \sum\nolimits_{u:(u, v_k^b) \in \ccalE_\ccalG} x_{u v_k^b r^b} =  b_p, \;\forall\, r^b \in \ccalK^\chi,
  \end{align}
\endgroup
where $v_k^b$ is the $b$-th vertex in the set of vertices in the routing graph $\ccalG$  that are associated with literal $\ap{i}{j}{k,\chi}$. If the clause $\ccalC_p^\gamma$ is true, i.e.,  $b_p=1$, the $b$-th vertex $v_k^b$ is visited by the $b$-th robot $r^b \in \ccalK^\chi$. On the other hand, if $\ccalK^\chi = \emptyset$, that is, literals that share this $\chi$ do not appear in the prefix part, we turn to constraint~\eqref{eq:same} to impose the same-$\ag{i}{j}$ constraints. Note that by condition \hyperref[cond:f]{\it f)} regarding implication in Definition~\ref{defn:run}, the clause $\ccalC$ in the edge label $\gamma(\vertex{prior}, \vertex{accept})$ (see Fig.~\ref{fig:lasso}) that the final locations of the prefix part satisfy implies a clause $\ccalC'$ in the edge label $\gamma(\vertex{prior}', \vertex{accept})$, therefore, robots returning to the final locations of the prefix part will enable this clause $\ccalC'$ in $\gamma(\vertex{prior}', \vertex{accept})$ and at the same time maintain that any literal in the clause $\ccalC'$ with non-zero connector uses the same group of robots as the literal in the clause $\ccalC$ in $\gamma(\vertex{prior}', \vertex{accept})$ with the same connector.  In other words, when robots head back towards their initial locations, the same-$\ag{i}{j}$ constraints over the last-completed subtask are satisfied automatically. Robots can safely return to their initial locations at last without worrying about violating the same-$\ag{i}{j}$ constraints. This is why we treat the literal $\pi_{\text{init}}$ as a literal with connect $\chi=0$ when we build the routing graph $\ccalG$.

%% The solution to this MILP returns high-level plans that induce a run in $\auto{subtask}^-$ that starts from and ends at the accepting vertex $\vertex{accept}$. Then, we can get the low-level executable paths by following the method in~Section~\ref{sec:solution2mrta} that drive the transitions to vertex label of $v_{\text{next}}$. The last step is to design paths that satisfy  the vertex label of $v_{\text{next}}$ so that robots go back  to their initial locations from the final locations of these paths returned by Section~\ref{sec:solution2mrta} and meanwhile do not violated the specification. In this way, robots' path constitute a cycle.
\paragraph{\quad (b) Closing of robots trajectories:} The second exception results from the requirement that, while driving transition back to $v_{\text{accept}}$, robots need to synchronize and make their trajectories a loop, i.e., the finial locations of the suffix paths should be identical to the initial locations of the suffix paths.
To this end, we define binary variables $b_e$ for each subtask in $P_{\text{min}}$ such that $b_e$ equaling 1 implies the satisfaction of the corresponding clause $\pi_{\text{init}}$. First, we require that one  and only one $b_e$ can be true, i.e.,
\begin{align}
  \sum_{e \in P_{\text{min}}} b_e = 1.
\end{align}
If $b_e=0$ for a subtask $e$ in $P_{\text{min}}$, then one of the remaining clauses in the edge label of $e$ must be satisfied according to constraint $\eqref{eq:c}$, which is reduced to the regular case as if $\pi_{\text{init}}$ did not exist.

Next, we encode the constraint that it is when completing the last subtask in $P_{\text{min}}$ that robots return to their initial locations. Recall that in Section~\ref{sec:milp} we define binary variables $b_{e}^{e'}=1$ which is 1 if subtask $e$ is completed no earlier than $e'$, i.e., $t_e \geq t_{e'}$. To determine this last satisfied subtask in $P_{\text{min}}$, %% we define $|P_{\text{min}}|^2$ binary variables $b_{e}^{e'}, \forall e, e' \in P_{\text{min}}$,  such that $b_{e}^{e'}=1$  iff $t_e \geq t_{e'}$, that is, iff $e$ is satisfied no earlier than  $e'$. This implication can be encoded as}
%% \begingroup\makeatletter\def\f@size{10}\check@mathfonts
%% \def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
%% \begin{align}
%%   M_{\text{max}} (b_{e}^{e'} - 1) \leq t_e -  t_{e'} \leq M_{\text{max}} b_{e}^{e'} - M_{\text{min}},
%% \end{align}
%%   \endgroup
%%  where $M_{\text{min}}$ is a small positive number and it is used to enforce $b_{e}^{e'}=1$ if $t_e = t_{e'}$.
  we define $z = |P_{\text{min}}| -1$. Then, for any $e \in P_{\text{min}}$, the term $\sum_{e' \in  P_{\text{min}}\setminus \{e \} } b_{e}^{e'} - z  = 0$ if $e$ is the last subtask to be completed. Thus, robot returning to initial locations to complete the last subtask  can be encoded as
\begin{align}
  1 + M_{\text{max}} ( &  \sum_{e' \in  P_{\text{min}}\setminus \{e \} } b_{e}^{e'} - z)  \leq  b_e \nonumber \\
  & \leq 1 + M_{\text{max}} (z - \sum_{e' \in  P_{\text{min}}\setminus \{e \} } b_{e}^{e'}),
\end{align}
for any subtask $e \in P_{\text{min}}$. Only when $e$ is the last subtask in $P_{\text{min}}$ to be completed, does $b_e = 1$ come into effect.


Given a subtask $e = (v_1, v_2) \in P_{\text{min}}$, similar to constraint~\eqref{eq:6}, the following constraint says that when $b_e=1$,i.e., subtask $e$ is indeed the last one to be completed,  each vertex in $\ccalG$ that is associated with clause $\pi_{\text{init}}$ of $\gamma(v_1, v_2)$ will be visited by a specific robot among the whole fleet of $n$ robots,
\begin{align}\label{eq:return_suffix}
  \left.   \left[ \sum_{v \in \ccalM_\ccalV^\mathsf{lits}(e, 1, p_e, 1)}   \sum_{u: (u,v) \in \ccalE_\ccalG}     \sum_{r = \ccalM_{\ccalK}^\ccalV(v) }   x_{uvr} \right] \middle/ {n} \right. = b_e,
 \end{align}
where $p_e$ is the index of the clause $\pi_{\text{init}}$ in $\gamma(v_1, v_2)$ and robot $r$ is the specific robot that should visit vertex $v$.

%% To this end, the clause that will be satisfied in the label of vertex $v_{\text{next}}$ in the suffix part should be the same as the clause that was satisfied in the prefix part. Both vertices refer to $v_{\text{next}}$ at the bottom part in Fig.~\ref{fig:absence}. Specifically, from the solution of MILP for the prefix part, we can locate the clause $\ccalC_p^\gamma \in \clause{\gamma(v_{\text{next}})}$ such that  $b_p = 1$, and then in the MILP for the suffix part, we set the variable $b_p$ as 1 that corresponds to the $p$-th clause of the label $\gamma(v_{\text{next}})$.

%%   Besides that the same clauses are satisfied, it should be the same set of robots that enable literals in these two clauses, that is, these robots return to the same region where they are when they satisfy the clause in the prefix part. To find the set of robots, given
%%   the $q$-th literal $\ap{i}{j}{k,\chi}$ in the $p$-th clause that was satisfied in $\gamma(v_{\text{next}})$ in the prefix part,  we locate robot $r\in \ccalM_\ccalK^\ccalV(v)$ such that $\exists\, v\in \ccalM_{\ccalV}^\mathsf{lits} (e, 0, p, q),\,\exists\, (u,v)\in\ccalE_\ccalG$, making $x_{uvr}=1$, where $e$ is the subtask whose starting vertex is $v_{\text{next}}$. In this way, we can find the set of robots that together satisfy this lietral. Therefore, in the suffix part, these $i$ robots should visit $i$ vertices that  point to region $\ell_k$ to satisfy the same literal $\ap{i}{j}{k,\chi}$ in $\gamma(v_{\text{next}})$. This constraint now becomes the same as the same-$\ag{i}{j}$ constraint. We can enumerate these $i$ robots to have one-to-one correspondence with $i$ vertices, and formulate the constraints like~\eqref{eq:same_suffix}.

After solving the MILP for the suffix part, we can use the method in Section~\ref{sec:solution2mrta} to obtain low-level paths which drives the transition back to $\vertex{accept}$ and return to initial locations to close the trajectories.



{Finally, for each poset $P_{\text{suf}}$, we can potentially find one suffix path (failures may result from that the MILP formulation is physically infeasible), then we select the suffix path over $\{P_{\text{suf}}\}$ with the lowest cost, which will be the best suffix path that correponds to a poset $P_{\text{pre}}$ in the prefix part for the given pair $(v_0, \vertex{accept})$. This best suffix path and the prefix path corresponding to $P_{\text{pre}}$ constitute a best total path for the poset $P_{\text{pre}}$ given the triple $(v_0, \vertex{accept})$. Then, according to~\eqref{eq:cost}, we select the best total paths over all posets $\{P_{\text{pre}}\}$ in the prefix part for the given pair $(v_0, \vertex{accept})$.  At last, we can obtain the best total path by iterating over all pairs of initial and accepting vertice with finite total length. We highlight that our method can terminate anytime once a feasible path is found and running more cases can lead to feasible paths that outperform the best incumbent solution.
}

  \section{Design of Low-Level Paths that Satisfy the Original LTL Task}\label{sec:solution2mrta}
 This section involves the correction stage, which corresponds to blocks 6 and 7 in Fig.~\ref{fig:overview}. We first extract a simple path from NBA $\auto{subtask}^-$ that connects $v_0$ and $\vertex{accept}$, based on the time axis and the high-level plan, and then find the counterpart of this simple path from the NBA $\autop^-$ that connects $v_0$ and $\vertex{accept}$, which corresponds to the prefix part of the accepting run. To satisfy the specification $\phi$, we formulate a sequence of generalized multi-robot path planning problems to design low-level executable paths that incur this simple path in $\autop^-$, by following along the high-level plan.
\subsection{Extraction of the simple path from the relaxed NBA \upshape $\auto{subtask}^-$}\label{sec:run}
  %% Note that we operate on $\auto{subtask}^-$ other than the pruned NBA  $\auto{subtask}^-$. This is because independent elementary subtasks can occur simultaneously, which together consistitute a composite subtask whose associated edge  appears in the NBA $\auto{subtask}^-$ but not in~$\auto{subtask}^-$.

Each distinct time instant in the time axis $\vec{t}$ obtained in Section~\ref{sec:path} has one-to-one correspondence with subtasks in the set $X_P$, and the sorted time axis generates a linear extension of subtasks in $X_P$ that incurs a simple path in $\auto{subtask}^-$ that connects $v_{0}$ and $\vertex{accept}$. In this section, we proceed along the time axis $\vec{t}$ to extract this simple path using the backtracking search. The outline of the algorithm is shown in Alg.~\ref{alg:extract}.

  To this end, we define $c\in \mathbb{N}$ as the {\it global counter} which keeps track of the progress that has been made along the time axis $\vec{t}$. Specifically, $c$ is the index of the subtask that  has  been completed most recently, therefore, $\vec{t}(c+1)$ denotes  the  completion time of the current subtask, denoted by $e' = (v'_1, v_2')$, which is  the next one to be completed. Let $v_1$ denote the vertex in $\auto{subtask}^-$ that is the  most recently reached when following along the time axis.  We start from the initial vertex $v_1= v_0$ with global counter $c=0$ [line~\ref{run:initialization}, Alg.~\ref{alg:extract}]. At each iteration, among all subtasks from the vertex $v_1$, we find the one $(v_1, v_2)$ that is  equivalent to the  subtask $e'$ [line~\ref{run:edgelabel}, Alg~\ref{alg:extract}]. Then, after the time instant $\vec{t}(c+1)$,  vertex $v_2$ becomes the most recently reached vertex. We then increase the global counter by 1 and add it to a stack, a last-in-first-out container [line~\ref{run:put}, Alg.~\ref{alg:extract}]. The iteration will terminate until the accepting vertex $\vertex{accept}$ (if $\gamma(\vertex{accept}) = \bot$) or $v'_{\text{accept}}$ (if $\gamma(\vertex{accept})\neq \bot$) is reached.


 \begin{algorithm}[t]
      \caption{Extract the  simple path  from $\auto{subtask}^-$ }
      \LinesNumbered
      \label{alg:extract}
      \KwIn {time axis $\vec{t}$, relaxed NBA $\auto{subtask}^-$}
         \Comment*[r]{Initialization}
         $v_1 = v_0, c = 0,  \text{stack} = \emptyset $ \label{run:initialization}\;
           \Comment*[r]{Backtracking search}
           \While{\upshape $v_1 \neq \vertex{accept}$ {\bf or} $v_1 \neq v_{\text{accept}}'$}{
             Obtain the subtask $e'=(v'_1, v_2')$ that is associated with $\vec{t}(c+1)$\;
           \For{\upshape $(v_1, v_2) \in \auto{subtask}^-$}{
             \If{\upshape   $ \gamma(v_1, v_2) = \gamma(v'_1, v'_2)$ {\bf and} $\gamma(v_1) = \gamma(v'_1)$ \label{run:edgelabel}}{
               Determine {\it (i)} essential clauses, {\it (ii)} essential robots, {\it (iii)} negative clauses, and {\it (iv)} the sequence of vertices leading to  $v_2$\label{run:info}\;
                 $\text{stack.put}(v_2, c+1)$\label{run:put}\;

             }
           }
           $(v_1, c) = \text{stack.pop}()$\;
           }
           return the simple path leading to $v_1$\;

 \end{algorithm}

 When a subtask $(v_1, v_2)$ in~$\auto{subtask}^-$ is matched with the subtask in $X_P$ that is completed at $\vec{t}(c+1)$, we keep track of information regarding {\it (i)} the exact clauses that are\ satisfied in the vertex label $\gamma(v_1)$  and edge label $\gamma(v_1, v_2)$, since only one clause in each label is true by constraint~\eqref{eq:c}, and {\it (ii)} the subset of robots that participate to satisfy each literal in these clauses (see constraint~\eqref{eq:6}),
 {\it (iii)} the clause composed of negative literals in $\autop^-$ that is in conjunction  with the satisfied clause in {\it (i)} but is replaced with $\top$ during the relaxation stage in Section~\ref{sec:prune}, and  {\it (iv)} the sequence of vertices in $\auto{subtask}^-$ that have been visited up to vertex $v_2$. These infomation will be used when planning the low-level paths. In what follows, we discuss {\it (i)-(iii)} in detail.

   \paragraph{(i) Essential clauses:} Given the edge label or vertex label $\gamma=\bigvee_{p\in \ccalP} \bigwedge_{q\in \ccalQ_p} \ap{i}{j}{k,\chi}$ of subtask $(v_1, v_2)$ that is neither $\top$ nor $\bot$, we refer to the unique clause that is satisfied as the {\it essential clause} and denote by $\gamma^+$, which is determined by locating the binary variable $b_p$, defined in~Section~\ref{sec:labelconstraints} representing the truth of a clause, whose value is 1. That is, find the clause $\ccalC_{p}^{\gamma} \in \clause{\gamma}$ such that $b_p=1$. On the othe hand, when the vertex or edge label is $\top$, by default we define the essential clause as $\top$.
   \paragraph{(ii) Essential robots:} We refer to the set of robots whose collective behavior satisfies the positive literals in the essential clause as the {\it essential robots}. For $q$-th literal $\ap{i}{j}{k,\chi}$ in the essential clause $\ccalC_p^\gamma$ of a vertex or edge label of subtask $(v_1, v_2)$, we determine its essential robots by locating the binary variable $x_{uvr}$, representing one robot visiting a vertex in the routing graph $\ccalG$ that is associated with this literal, whose value is 1. That is, for each $v\in \ccalM_{\ccalV}^\mathsf{lits} (e, 0|1, p, q)$, find the robot $r\in \ccalM_\ccalK^\ccalV(v)$ such that $\exists\, (u,v)\in\ccalE_\ccalG$, making $x_{uvr}=1$.  On the other hand, if the essential clause is $\top$, there is no essential robots.
   \paragraph{(iii) Negative clause:} The collective behavior of essential robots satisfies the essential clauses in $\auto{subtask}^-$. For every essential clause if the associated label is neither $\top$ nor $\bot$, there exists a unique clause in the NBA $\autop^-$ that only differs from the essential clause in that it may contain the conjunction of the negative literals that were removed during the relaxation stage. We refer to this conjunction of negative literals  as the {\it negative clause} and denote by $\gamma^-$, which will be avoided when desinging the low-level paths in Section~\ref{sec:mapp}. By default, we  define the negative clause as $\top$, if the corresponding clause in $\autop^-$ does not have negative literals. In this way, the conjunction $\gamma^+ \wedge \gamma^-$ of an essential  clause and its corresponding negative clause correspond to  one {\it complete clause} in~$\autop^-$.

   On the other hand, when the vertex label $\gamma(v_1)$ or edge label $\gamma(v_1, v_2)$ of subtask $(v_1, v_2)$ in $\auto{subtask}^-$ is $\top$, the associated essential clause is $\top$. However, the negative clause may not be $\top$, which happens when there exists a  clause in the corresponding label in $\autop^-$ that only includes negative literals. In this case, if the label is $\gamma(v_1)$, we select one  among clauses that only include negative literals such that the selected clause does not contradict the essential clause of the previous edge label in the path in $\auto{subtask}^-$ that leads to subtask $(v_1, v_2)$. Recall that we keep track of the path that leads to vertex $v_2$ during the search.   Such negative clause exists if $v_1$ and $v_2$ are in a restricted accepting run,  based on condition (a)  in the Definition~\ref{defn:compatibility} regarding compatibility.
   Otherwise, if the selected negative clause contradicts the essential clause of the previous edge label, assuming the robot locations in the designed low-level paths  satisfy the complete clause of the previous edge label of the current subtask $(v_1, v_2)$ , then the robot locations at the next time instant  should satisfy the negative clause of $\gamma(v_1, v_2)$. Due to the contradicton, this goal is hard to realize.  Similarly, if the label is the edge label $\gamma(v_1, v_2)$, we select one among clauses that only include negative literals such that the selected clause does not contradict the essential clause of the end vertex label $\gamma(v_2)$. Such negative clause also exists  if $v_1$ and $v_2$ are in a restricted accepting run,  based on condition (b)  in the Definition~\ref{defn:compatibility} regarding compatibility.}



 %%  To this end, we define $c\in \mathbb{N}$ as the {\it global counter} which keeps track of the progress that has been made along the axis $\vec{t}$. Specifically, $c$ is the index of the subtask that  has  been completed most recently, therefore, $\vec{t}(c+1)$ denotes  the   completion time of the current subtask, which is the immediate one to be completed. Let $v_1$ denote the vertex that is the  most recently reached when following along the time axis.  We start from the initial vertex $v_1= v_0$ with global counter $c=0$ [line~\ref{run:initialization}, Alg.~\ref{alg:extract}]. At each iteration, we determine the set $H$ of time instants that are identical to $\vec{t}(c+1)$, of which the corresponding subtasks will be completed parallelly at the same time. We denote by $\gamma_{\text{edge}}$ and $\gamma_{\text{vertex}}$ the conjunciton of the associated edge labels  and vertex labels of those subtasks, respectively. [line~\ref{run:instants}, Alg.~\ref{alg:extract}].
 %%   Among all outgoing edges from the vertex $v_1$, we find the subtask $(v_1, v_2)$  whose edge label abd vertex label are logically equivalent to $\gamma_{\text{edge}}$ and $\gamma_{\text{vertex}}$, respectively [line~\ref{run:edgelabel}, Alg~\ref{alg:extract}]. Recall that when $|H|>1$, by definition~\ref{defn:id} of ID property, all independent subtasks  have vertex labels $\top$.    In this way, after the time instant $\vec{t}(c+1)$,  vertex $v_2$ becomes the most recently reached vertex. We then increase the global counter by $|H|$ and add it to a stack, a last-in-first-out container [line~\ref{run:put}, Alg.~\ref{alg:extract}]. The iteration will terminate until the accepting vertex $\vertex{accept}$ is reached.}


 %% \begin{algorithm}[t]
 %%      \caption{Extract the  run from $\auto{subtask}^-$ }
 %%      \LinesNumbered
 %%      \label{alg:extract}
 %%      \KwIn {time axis $\vec{t}$, relaxed NBA $\auto{subtask}^-$}
 %%         \Comment*[r]{Initialization}
 %%         $v_1 = v_0, c = 0,  stack = \emptyset $ \label{run:initialization}\;
 %%           \Comment*[r]{Backtracking search}
 %%         \While{\upshape $v_1 \not= \vertex{accept}$}{
 %%           Determine the set of identical time instants: $H = \{\vec{t}(h): \vec{t}(h) = \vec{t}(c+1), \;\forall\,  c+1 \leq h \leq |\vec{t}|\}$
 %%           and the conjunction of labels $\gamma_{\text{edge}}$ and $\gamma_{\text{vertex}}$ \label{run:instants}\;
 %%           \For{\upshape $(v_1, v_2) \in \auto{subtask}$}{
 %%             \If{\upshape   $ \gamma(v_1, v_2) = \gamma_{\text{edge}}$ {\bf and} $\gamma(v_1) = \gamma_{\text{vertex}}$ \label{run:edgelabel}}{
 %%                 Determine {\it (i)} essential clauses, {\it (ii)} essential robots {\it (iii)} the sequence of vertices \label{run:info}\;
 %%                 $stack.put(v_2, c+|H|)$\label{run:put}\;

 %%             }
 %%           }
 %%           $(v_1, c) = stack.pop()$\;
 %%         }

 %% \end{algorithm}

 %% \blue{When an edge $(v_1, v_2)$ in~$\auto{subtask}^-$ is matched with a subtask in~$X_P$, we keep track of information regarding {\it (i)} the exact clauses that are\ satisfied in the vertex label $\gamma(v_1)$ (if $\gamma(v_1) \neq \top, \bot$) and edge label $\gamma(v_1, v_2)$ (if $\gamma(v_1, v_2) \neq \top$), since only one clause in each label is true by~\eqref{eq:c}, and {\it (ii)} the subset of robots that participate to satisfy each literal in these clauses, {\it (iii)} the sequence of vertices in $\auto{subtask}^-$ that have been visited up to vertex $v_2$. We next discuss {\it (i)} and {\it (ii)} in detail.

 %%   \domanda{(i) Essential clauses} When $H=1$, given the edge label or vertex label $\gamma=\bigvee_{p\in \ccalP} \bigwedge_{q\in \ccalQ_p} \ap{i}{j}{k,\chi}$, we refer to the clause that is satisfied as the {\it essential clause} and denote by $\gamma^+$, which is determined by locating the binary variable, defined in~Section~\ref{sec:labelconstraints} representing the truth of a clause, whose value is 1. That is, $b_p=1, \, \forall\, \ccalC_{p}^{\gamma} \in \clause{\gamma}$. On the other hand, when $|H|>1$, we first determine the essential clauses for the elementary subtasks, and then determine the essential clause for the composite substask that is the conjunction of these clauses.
 %%   \domanda{(ii) Essential robots} We refer to the set of robots whose collective behavior satisfies the literals in the essential clause as the essential robots. For each literal $\ap{i}{j}{k,\chi}$ in the essential clause for each elementary subtask, we determine its essential robots by locating the binary variable, representing one robot visiting a vertex in the routing graph $\ccalG$ associate with this literal, whose value is 1. That is, $x_{vr}=1, \, \forall\, v\in \ccalM_{\ccalV}^\mathsf{lits} (e, 0|1, p, q),\,\forall\, r\in \ccalM_\ccalK^\ccalV(v)$.




 %% \begin{cexmp}
 %%   The time axis obtained from individual timeline $\{t_{1,2}, t_{2,1}, t_{2,4}\}$ is  $\vec{t} = \{7, 17\}$, since each time instant unless the starting instant 0 corresponds to an edge label.  The detailed search over the NBA $\auto{subtask}^-$, also $\auto{relax}$, in Fig.~\ref{fig:nba_m} is shown Table~\ref{tab:search}, where the first column lists the vertex that is being searched and the second column records the set $stack$ once the search over the left-side vertex is over. The run in the relaxed NBA $\auto{relax}$ in Fig.~\ref{fig:nba_m} is $v_0 \to v_1 \to v_3 \to v_6(\vertex{accept})$. That is, robots $[2,1], [2,4]$ and $[1,2]$ are involved in the subtask $(v_1,v_3)$ that occurs at time instant  $7$, and robots $[2,1] $ and $[2,4]$ are involved in the subtask $(v_3, v_6)$ that occurs at time instant $17$.
 %% \end{cexmp}
 %% \begin{table}[t]
 %%   \caption{Extract a run from automaton $\auto{subtask}^-$}\label{tab:search}
 %%   \centering
 %%   \red{\begin{tabular}{cl}
 %%     \toprule
 %%     vertex & $stack$\\
 %%     \midrule
 %%     $v_0$ & $\{(v_1, 1)\}$\\
 %%     $v_1$ & $\{(v_4, 2), (v_2, 2), (v_3, 2)\}$\\
 %%     $v_4$ & $\{(v_2, 2), (v_3, 2)\}$\\
 %%     $v_2$ & $\{(v_3, 2)\}$\\
 %%     $v_3$ & $\{(\vertex{accept}, 3)\}$\\
 %%     $\vertex{accept}$ & $\emptyset$\\
 %%     \bottomrule
 %%   \end{tabular}}
 %% \end{table}

 {\subsection{Generalized multi-robot path planning}\label{sec:mapp}
   Using  the relation between the pruned NBA  $\autop^-$ and the relaxed NBA $\auto{subtask}^-$, in $\autop^-$ we can find the counterpart  of the  simple path in $\auto{subtask}^-$ obtained in Section~\ref{sec:run}. We denote by $\theta_\phi$ this counterpart, which corresponds to  a sequence of temporally sequential subtasks. Our goal is to find a collection of executable paths for the robots that incur the simple path $\theta_\phi$ in $\autop^-$; see also block 7 in Fig.~\ref{fig:overview}. To achieve this, we formulate  the execution of each subtask in $\theta_\phi$ into a {\it generalized multi-robot path planning problem (GMRPP)}. Compared to the classical multi-robot path planning that, given an initial robot configuration, designs paths to reach the target configuration, the GMRPP imposes extra constraints on the intermediate configuration.

 %% \begin{figure}[t]
 %%  \centering
 %%  \includegraphics[width=0.9\linewidth]{adjustment.pdf}
 %%  \caption{\blue{Adjustment of time spans. Consider three consecutive subtasks $e_1, e_2, e_3$. Every green horizontal bar depicts the time interval when the vertex label of one subtask is true and the red triangle marks the satisfaction of the edge label, i.e., the completion of the subtask. The upper part illustrates the general relation between the spans of subtasks (unaligned in the vertical direction for better illustration) and the lower  part shows the overlapping at the endpoints after the alignment.}}
 %%  \label{fig:adjustment}
 %% \end{figure}
 %% We first  align the timing of subtasks, consisting of two consecutive vertices in the found run $\theta_\phi$,  along the timeline. Specially, we fix the completion time of each subtask as an ``anchor' and then align the time interval when the associated vertex label is true,  so that the activation time of this subtask is the same as  the completion time   of the previous subtask, and the last time when the associated vertex label is true is the same as the completion time of this subtask; see also Fig.~\ref{fig:adjustment}. In this way,  the union of all spans of subtasks covers the whole timeline and the spans of two consecutive subtasks only overlap at the endpoint. Also, the time interval when the vertex label is true is the same as the span of the subtask. To realize the alignment, each  pair of  time instants in $t_{r.j}$ that specify the time interval when a vertex label is true will be modified so that the first time instant equals the completion of the previous subtask and the second one equals the completion of the current subtask that this vertex label corresponds to.

 %% {Note that the plan $\{p_{r,j}\}$ and the timeline $\{t_{r,j}\}$ still satisfy the constraints in Section~\ref{sec:milp} except~\eqref{eq:4}. Because we adjusted the timeline by fixing the time instants associated with edge labels, only constraints related to time instants associated with vertex labels can be affected, that is, \eqref{eq:4}, \eqref{eq:17} and~\eqref{eq:20}. Specifically, the completion time of the subtask is the same as the completion time of the corresponding vertex label, thus, the containtment in~\eqref{eq:17} is satisfied. Furthermore, the activation time of the current subtask is same as the completion time of the subtask immediately preceding it, thus, temporal constraint~\eqref{eq:20} is satisfied. Constraints in~\eqref{eq:4} can be  violated since the alignment can bring forward the activation time of the vertex label or delay the completion time of the vertex label, which might make the time difference between visitation of connecting vertices slightly less than the required travelling time. However, since the travelling time used in~\eqref{eq:4} is the shortest travelling time between regions, the constraints~\eqref{eq:4} are the approximation of the real situation, thus, violation of~\eqref{eq:4} is acceptable and will be addressed in Section~\eqref{sec:solution2mapp}.}

 {Observe that given the completion time of two consecutive subtasks in the time axis $\vec{t}$, we can obtain the tightest span of the vertex label of the second subtask. Specifically, the activation time, at the latest, of the vertex label of the second subtask is exactly one time instant later than the completion time of the first subtask; see also constraint~\eqref{eq:20} that captures the temporal relation between two subtasks. On the other hand, the earliest completion time of the vertex label of the second subtask is exactly one time instant earlier than the completion time of the second subtask; see also constraint~\eqref{eq:17} that captures the temporal relation for the same subtask.  To design the low-level paths,  we let each robot visit waypoints in its individual plan $p_{r,j}$ sequentially, maybe at different time instants than those in its timeline $t_{r,j}$ when taking collision avoidance into account, but relative temporal relations with other robots (precedence or simultaneity) are kept. Also we maintain the tightest span of the vertex label of the considered subtask between completion times of two consecutive subtasks.}

 To this end, for each robot $[r,j] \in \{\ccalK_j\}$, we define a {\it local counter} $\zeta_{r,j} \in \mathbb{N}$  that  keeps track of how much progress has been made along the individual plan $p_{r,j}$. Specifically, $\zeta_{r,j} = a$ indicates that the waypoint in the plan $p_{r,j}$ most recently visited by  robot $[r,j]$ is the $a$-th waypoint. Furthermore, recall the  global clock $c$ that monitors the index of the most recently completed subtask  along the time axis $\vec{t}$, which also captures the execution progress along the simple path  $\theta_\phi$. In what follows, we provide the ingredients for the construction of GMRPP.

 %%  \blue{Next, we discuss the correspondence between clauses in the NBA $\auto{subtask}^-$ and those in $\autop$ in two cases:
 %% \domanda{(i) Label is neither $\top$ nor $\bot$} Given a subtask $e$ contained in the run $\theta_\phi$ in $\auto{subtask}^-$, only one clause (a conjunction of positive literals) can be true in every associated label $\gamma$, vertex or edge label by~\eqref{eq:c}, if it is neither $\top$ nor $\bot$. We refer to this clause as the {\it satisfied clause} and denote by $\gamma^+$. For every satisfied clause in $\auto{subtask}^-$, there exists a unique clause in the pruned NBA $\autop^-$ that only differs from the satisfied clause in that it may contain the conjunction of the negative literals that were removed  during the relaxation stage . We refer to this conjunction of negative literals  as the {\it negative clause} and denote by $\gamma^-$, which is defined as $\top$ by default, if the corresponding clause does not have negative literals. In this way, each label is associated with a satisfied clause and a negative clause which together constitute one clause.

 %% \domanda{(ii) Label is $\top$}  When the vertex or edge label is $\top$, the associated satisfied clause is $\top$ by default. However, the negative clause may not be $\top$, which happens when all clauses in the corresponding label in $\autop^-$ only include negative literals. For the edge label, we randomly select one of its clauses as the negative clause. For the vertex label, we select one among clauses that only include negative literals that is not mutually exclusive with the conjunction of the satisfied and negative clauses associated with  the edge label of the subtask that is immediately preceding the current subtask. Otherwise, if the robot locations in the designed low-level paths  satisfy the edge lalel of the previous subtask in $\autop^-$, then the next robot locations should satisfy the negative clause associated with the vertex label of the current subtask. Due to the mutual exclusion,  this situation is hard to realize.}  In what follows, we describe  the ingredients of a single instance of the generalized multi-robot path planning problem [line~\ref{seq:ingredients}, Alg.~\ref{alg:sequentialMAPP}].

 \subsubsection{Ingredients of GMRPP:}\label{sec:gmmpp1} Consider a subtask $e = (v_1, v_2)$ generated by the simple path $\theta_\phi$ that is the next one to be completed. We assume that the end vertex $v_2$ has a self-loop. Let $\gamma_1^+$ and $\gamma_1^-$ denote the essential and negative clauses associated with the vertex label $\gamma(v_1)$, respectively. Similarly, we define  $\gamma_{1,2}^{+}$ and $\gamma_{1,2}^{-}$  for the edge label $\gamma(v_1, v_2)$, and  $\gamma_2^+$ and $\gamma_2^-$ for the vertex label $\gamma(v_2)$ of the next substask in $\theta_\phi$. The goal of a GMRPP formulated  is to determine a collection of executable paths such that robots complete the current subtask (by satisfying the corresponding edge label $\gamma_{1,2}^+ \wedge \gamma_{1,2}^-$ at the end while respecting the vertex label $\gamma_1^+ \wedge \gamma_1^-$ en route) and activate the next subtask (by satisfying the next vertex label $\gamma_2^{+}\wedge \gamma_2^{-}$ after the completion of the current subtask). We refer to $\gamma_1^-$ as the {\it running constraint}, and $\gamma_{1,2}^- $ and $ \gamma_2^{-}$ as the {\it terminal constraints}. By condition~\hyperref[cond:d]{\it d)}} in the Definition~\ref{defn:run}, an important observation is that the satisfaction of the current subtask can activate the next subtask. Also, the construction of the edge set of the routing graph $\ccalG$ in Section~\ref{sec:edge_set} ensures that the next subtask is activated automatically. Therefore, there is no need to consider $\gamma_2^+$ and $\gamma_2^-$ for most subtasks. The only exception is  when the accepting vertex $\vertex{accept}$ has a self-loop since condition~\hyperref[cond:d]{\it d)}} does not involve this. In this case, we need to consider the activation of the label of the accepting vertex $\text{accept}$. Therefore, for the sake of comprehensiveness, we consider the activation of the next subtask.

%% Let $\gamma_1^-$ denote the negative clause associated with the vertex label $\gamma(v_1)$. Let $\gamma_2^{+,1} (\gamma_2^{-,1}) $ and $\gamma_2^{+,2} (\gamma_2^{-,2})$ denote the satisfied (negative) clause associated with the edge label $\gamma(v_1, v_2)$ and the vertex label of the next subtask, respectively. Then, we define $\gamma_2^+ = \gamma_2^{+,1} \wedge \gamma_2^{+,2}$ and $\gamma_2^- = \gamma_2^{-,1} \wedge \gamma_2^{-,2}$. As mentioned  in the definition of subtasks (see Definition~\ref{defn:subtask}), the completion of a subtask requires the satisfaction of its edge label while respects its vertex label. Thus, the goal of a GMRPP is to determine a collection of executable paths that satisfy the clauses $\gamma^+_2 \wedge \gamma^-_2$ at the end and respect the clause $\gamma_1^-$ en route.\endnote{We do not consider the satisfied clause, denoted by $\gamma_1^+$, in the vertex label of the current subtask since it is satisfied at the end of the previous subtask and will maintain true since involved robots remain idle, same as that $\gamma_2^{+,2}$ of the next vertex label is addressed when dealing with the current subtask.} That is, robots complete the current subtask (by satisfying the corresponding edge label $\gamma_2^{+,1}\wedge \gamma_2^{-,1}$ and the vertex label $\gamma_1^-$) and activate the next subtask (by satisfying the next vertex label $\gamma_2^{+,2}\wedge \gamma_2^{-,2}$). We refer to $\gamma_1^-$ as the {\it running constraint},  $\gamma_2^-$ as the {\it terminal constraint}, and $\gamma_2^+$ as the {\it target}.

Note that not all robots need to move for one specific subtask, since only the set of essential robots are responsible for the satisfaction of this subtask. In what follows, we introduce two moving schemes with the difference of whether the full set or only a subset of robots move.   We first determine the subset of robots that should move in both schemes in 4 cases:
\paragraph{(i) Essential robots associated with the target $\gamma_{1,2}^{+}$ and $\gamma_2^{+}$:}  We collect essential robots associated with essential clauses in $\gamma_{1,2}^{+}$ and $\gamma_2^{+}$ in the sets $\ccalR_{1,2}$ and $\ccalR_2$, respectively, where  robots need to reach certain target regions related to the current and next subtasks.
\paragraph{(ii) Essential robots associated with the constraint $\gamma_1^+$:} We collect essential robots associated with essential clauses in $\gamma_{1}^{+}$ in the sets $\ccalR_{1}$,  where robots need to remain at certain target regions related to the current subtask.
\paragraph{(iii) Essential robots associated with subsequent subtasks:} These robots move simultaneously with the first two types of robots heading towards  waypoints associated with subsequent subtasks of the current subtask $e$. We collect robots in the set $\ccalR'_{1,2}$ and identify them in the following way. First, we identify the completion time  of the current subtask, which is given by $\vec{t}(c+1)$.  Next, we iterate over the remaining robots that are not in $\ccalR_1 \cup \ccalR_{1,2} \cup \ccalR_2$. For every such robot $[r',j']$, the time when it should visit the next waypoint based on its local counter $\zeta_{r',j'}$ is given by $t_{r',j'}(\zeta_{r',j'}+1)$. Note that {$t_{r', j'}(\zeta_{r',j'}+1) > \vec{t}(c+1)$}, since we proceed along the simple path $\theta_\phi$ and the completion time of  subtasks that have not been considered, by the precedence relation in~\eqref{eq:12} and the increasing time axis, will be larger than that of the current subtask. Finally, we calculate the time difference $\Delta t = t_{r', j'}(\zeta_{r',j'}+1) - \vec{t}(c+1)$  and then check whether the robot $[r', j']$ can arrive at the target region $p_{r',j'}(\zeta_{r',j'}+1)$  within time $\Delta_t$ starting from  its current location by taking the shortest route. {If not, robot $[r', j']$ should move simultaneously when completing the current subtask.}
\paragraph{(iv) robots associated with running and terminal constraints:} The robots in this case  are different from the above-mentioned three types due to that they are related to negative clauses $\gamma_1^-$, $\gamma_2^-$ or $\gamma_{1,2}^-$. These robots navigate without specific targets, unless they appear in the first 3 cases, only to satisfy the threshold imposed by the negative literals on the number of certain type of robots that appear at some regions. We collect them in the set $\ccalR^-$, which contains all robots that belong to certain types mentioned in $\gamma_1^-$, $\gamma_2^-$ or $\gamma_{1,2}^-$. That is, $\ccalR^- = \{\{\ccalK_j\}: \neg \ap{i}{j}{k} \in \mathsf{lits}^- (\gamma_1^- \vee \gamma_2^- \vee \gamma_{1,2}^-) \}$.

Let $\ccalR = \ccalR_1 \cup\ccalR_{1,2} \cup \ccalR_{2} \cup \ccalR'_{1,2} \cup \ccalR^-$ denote the set that collects all robots that need to move in both schemes, and $\ccalR_0 = \{\ccalK_j\}\setminus\ccalR$ collect robots that do not need to move in the partial-moving sheme but move in the full-moving sheme. In what follows, we provide the partial-moving scheme which shares most similarity with the full-moving scheme. First, we treat robots in $\ccalR_0$ as obstacles, giving rise to a new environment $E'=(S', \to_{E'})$. Furthermore, we define by $X_I$ and $X_G$ the sets of initial and target locations, respectively, for robots in $\ccalR$  such that $X_I(r,j) \in S'$ and $X_G(r,j)\subseteq S'$ are the initial  and target locations of robot $[r,j] \in \ccalR$. Specifically, the initial robot locations are those where the robots stand at the end of the subtask immediately preceding $e$. Moreover, the target region of  robot $[r,j] \in \ccalR_{1,2}$ is determined  by its associated literal in $\gamma_{1,2}^+$, which is also given by  $p_{r,j}(\zeta(r,j)+1)$. Similarly, the target region of robot $[r,j] \in \ccalR_{1} \cup \ccalR_{2}$ can also be determined by its associated literal in $\gamma_1^+$ or $\gamma_2^+$. Furthermore, the target region of robot $[r',j'] \in \ccalR'_{1,2}$ is the  location from where robot $[r',j']$ can reach the region $p_{r',j'}(\zeta(r',j')+1)$ within time $\Delta t$ by taking the shortest route in the new environment $S'$. If the selected target location of robot $[r',j']$ has already been assigned to another robot in $\ccalR'_{1,2}$, then we select another free cell on the shortest route to be this robot's target location, which is close to the previously selected occupied cell and has not been assigned.

Finally, let $\tau'_{r,j}$ denote the path segment of robot $[r,j] \in \ccalR$, where $\tau'_{r,j}(t)$ denotes the robot location at time $t$ for $ t = 0,  \ldots, T, T+1$, where time instants 0, $T$ and $T+1$ indicate the completion time of the immediately preceding subtask and the current subtask and the activation time of the next subtask, respectively. Next, under the assumption that the end vertex $v_2$ has a self-loop, the generalized multi-robot path planning problem in the partial-moving scheme, adapted from~\cite{yu2016optimal}, is defined as follows.
 \begin{defn}[(Generalized multi-robot path planning)]\label{defn:gmmpp}
    Given a discrete environment $E'$, a set of robots $\ccalR$ where $\ccalR = \ccalR_1 \cup\ccalR_{1,2} \cup \ccalR_{2} \cup \ccalR'$, a set of initial locations $X_I$ and a set of target regions $X_G$, the running constraint $\gamma_1^-$, the terminal constraints $\gamma_{1,2}^-$ and $\gamma_2^-$, and the horizon $T+1$, find a collection of path segments $\tau'_{r,j}$ for all robots $[r,j]\in \ccalR$ such that {\it (i)} every robot $[r,j] \in \ccalR\setminus\ccalR_1$ starts from the initial location and arrives at the target region at time instants $T$ or $T+1$, i.e., $ \tau'_{r,j}(0) = X_I(r,j)$ and  $ \tau'_{r,j}(T) \in X_G(r,j)$ for $[r,j] \in  \ccalR_{1,2} \cup \ccalR'$ or $ \tau'_{r,j}(T+1) \in X_G(r,j)$ for $[r,j] \in \ccalR_{2}$. Furthermore, every robot $[r,j] \in \ccalR_1$ remains in the target region for all time except  at 0 and $T, T+1$, that is, $ \tau'_{r,j}(0) = X_I(r,j)$ and $\tau'_{r,j}(t) \in X_G(r,j)$ for $t\in\{1,\ldots, T-1\}$;
  {\it (ii)} the paths of  any two distinct robots $[r,j]$ and $[r', j']$ are collision-free, that is, there does not exist  a atime instant $t \in [T+1]$ such that $\tau'_{r,j}(t) = \tau'_{r',j'}(t)$ (meet collision, that is, two robots occupy the same cell at the same time) or  $\tau'_{r,j}(t) = \tau'_{r',j'}(t-1) \wedge \tau'_{r',j'}(t) = \tau'_{r,j}(t-1)$ (head-on collision, that is, two robots at adjacent cells switch locations with each other); and {\it (iii)} the paths $\{\tau'_{r,j}\}$ must satisfy the running constraint $\gamma^-_1$ for all time except  at 0 and $T, T+1$, and they also satisfy the terminal constraint $\gamma^-_{1,2}$ at time instant $T$ and $\gamma^-_{2}$ at time instant $T+1$, respectively.
 \end{defn}

 \begin{figure}[!t]
   \centering
   \includegraphics[width=0.9\linewidth]{timeline.pdf}
   \caption{The time relation within one GMRPP. The essential and negative clauses are aligned with the time instants when they should be satisfied.}
   \label{fig:timeline}
 \end{figure}

 Fig.~\ref{fig:timeline} illustrates the timing relations of essential and negative clauses.  The paths do not need to satisfy  $\gamma_1^+$ and $\gamma_1^-$ at time instants 0,  $T$ and $ T+1$ since the tightest span of the vertex label of the current subtask can be one time instant later than the completion of the immediately preceding subtask, which is indicated by time 0, and one time instant earlier than the completion of the current subtask, which is indicated by time $T$. In the full-moving scheme, robots in $\ccalR_0$ can move but, like those in $\ccalR^-$, there is no specific target regions for robots in $\ccalR_0$. They  navigate only to move out of the way of robots that head for their targets. Therefore, the new environment $E'$ is the same as the original one $E$. The rest will remain the same as in the partial-moving sheme.

 Note that when the end vertex $v_2$ does not have a self-loop, that is, $v_2$ is $\vertex{accept}$ (only $\vertex{accept}$ can have no self-loop when acting as the end vertex according to condition \hyperref[cond:c]{\it c)} in Definition~\ref{defn:run}), we do not consider robots in $\ccalR_2$ and the terminal constraint $\gamma_2^-$. Therefore, the horizon of the GMRPP is $T$. In the following Section~\ref{sec:solution2mapp} we discuss how to solve the GMMPP with horizon $T+1$ which  includes the satisfaction of $\gamma_2^+\wedge \gamma_2^-$ at time instant $T+1$ and all formulations established over the first $T$ instants can be directly applied to the case for $T$.  The paths returned by this GMRPP complete the subtasks $(v_1, v_2)$  and meanwhile activate the vertex label of $v_2$, i.e., the next subtask.



 %% \subsubsection{$\gamma(v_2)=\bot$}\label{sec:gmmpp2} Given the current subtask $(v_1, v_2) \in \theta_\phi$, when $\gamma(v_2) = \bot$, we have $v_2 = \vertex{accept}$; see also Fig.~\ref{fig:absence}.  In this case, we consider these two subtasks $(v_1, \vertex{accept})$ and  $(\vertex{accept}, v_{\text{next}})$ together. First, we treat the edge label $\gamma(\vertex{accept}, v_{\text{next}})$ as if it were the vertex label of $\vertex{accept}$, since $\gamma(\vertex{accept}, v_{\text{next}})$ should be satisfied one step later after the subtask $(v_1,  \vertex{accept})$, acting like the vertex label of $\vertex{accept}$. Therefore, similar to case~\hyperref[sec:gmmpp1]{{\it 1)}}, we obtain the negative clause $\gamma^-_2$ and the subset of robots $\ccalR^-$  from the label $\gamma(\vertex{accept}, v_{\text{next}})$ and $\gamma_2^-$ should still be satisfied at time instant $T+1$. The subset $\ccalR_2$ is empty since $\gamma(\vertex{accept}, v_{\text{next}})$ is $\top$. Next, we consider extra constraints than case~\hyperref[sec:gmmpp1]{{\it 1)}}, which are related to the activation of vertex label of $v_{\text{next}}$. Specifically, we require that $\gamma(v_{\text{next}})$ be activated at time instant $T+2$. To this end, let $\ccalR'_2$ collect all essential robots related to the  essential clause of $\gamma(v_{\text{next}})$ so that the set $\ccalR$ of robots that need to move also includes $\ccalR'_2$ and robots in $\ccalR'_2$ should reach target regions at time instant $T+2$. Furthermore, we denote by $\gamma'^-_2$ the negative clause related to $\gamma(v_{\text{next}})$ and the set of robots $\ccalR^-$ should include all robots of some types that appear in negative literals in $\gamma_2'^-$. Therefore, $\gamma'^-_2$ is also a terminal constraint which should be satisfied at time instant $T+2$. In the following Section~\ref{sec:solution2mapp} we discuss how to solve the above  generalized multi-robot path planning problem with given horizon  $T+2$. The paths returned by this GMRPP complete the subtasks $(v_1, \vertex{accept})$ and  $(\vertex{accept}, v_{\text{next}})$  and meanwhile activate the vertex label of $v_{\text{next}}$.

%% In what follows, we define a template for the generalized multi-robot path planning adapted from~\cite{yu2016optimal}, which can be instantiated based on different scenarios.  Each instantiated problem imposes constraints on the path $\tau'_{r,j}$ for each robot $[r,j] \in \ccalR$. We denote by  $\tau'_{r,j}(t)$ the robot location at time instant  $ t = 0,  \ldots, T, \ldots, T+x$, where the time instant $T$ is when robots reach their target regions associated with the current subtask, and the extension term $x\in \mathbb{N}$ is problem-specific.
%% \begin{defn}[Template for the generalized multi-robot path planning]\label{defn:gmmpp}
%%     Given a discrete environment $E'$, a set of robots $\ccalR=\ccalR_1 \cup \ccalR_{\setminus1} $, a set of initial locations $X_I$ and a set of target regions $X_G$, the constraints $\gamma^-$ and the horizon $T+x$, along with the time interval $I = \{0, \ldots, T+x\}$, find a collection of path segments $\tau'_{r,j}$ for all robot $[r,j]\in \ccalR$ such that {\it (i)} every robot $[r,j] \in \ccalR_{\setminus1}$ starts from the initial location and arrives at the target region at time instants $T+y\in I$ where $y\in \{0,\ldots,x\}$, i.e., $ \tau'_{r,j}(0) = X_I(r,j)$ and  $\tau'_{r,j}(T+y) \in X_G(r,j)$ for $[r,j] \in \ccalR_{\setminus1}$. Furthermore, every robot $[r,j] \in \ccalR_1$ remain in the target region over a time interval $I_1\subseteq I$, that is, $\tau'_{r,j}(t) \in X_G(r,j)$ for $t \in I_1$; {\it (ii)} the paths of  any two distinct robots $[r,j]$ and $[r', j']$ are collision-free, that is, there does not exist time instant $t\in I$ such that $\tau'_{r,j}(t) = \tau'_{r',j'}(t)$ (meet collision, that is, two robots occupy the same cell at the same time) or $\tau'_{r,j}(t) = \tau'_{r',j'}(t-1) \wedge \tau'_{r',j'}(t) = \tau'_{r,j}(t-1)$ (head-on collision, that is, two robots at adjacent cells switch locations with each other); and {\it (iii)} the paths $\{\tau'_{r,j}\}$ must satisfy the constraint $\gamma^-$ over a time interval $I_2\subseteq I$ or at a specific time instant $t\in I$.
%% \end{defn}

%% When the vertex label of $v_2$ exists, the instantiated GMRPP is as follows.
%%   \begin{defn}[Instantiated GMRPP when $\gamma(v_2)\neq \bot$]\label{defn:gmmpp1}
%%     Given a discrete environment $E'$, a set of robots $\ccalR = \ccalR_1 \cup\ccalR_{1,2} \cup \ccalR_{2} \cup \ccalR'_{1,2}$, a set of initial locations $X_I$ and a set of target regions $X_G$, the running constraint $\gamma_1^-$, the terminal constraints $\gamma_{1,2}^-$ and $\gamma_2^-$, and the horizon $T+1$ (thus, $x=1$), find a collection of path segments $\tau'_{r,j}$ for all robot $[r,j]\in \ccalR$ such that {\it (i)} every robot $[r,j] \in \ccalR\setminus\ccalR_1$ starts from the initial location and arrives at the target region at time instants $T$. Furthermore, every robot $[r,j] \in \ccalR_1$ remain in the target region for all $t = 1, \ldots, T-1$;
%%   {\it (ii)} same as (ii) in the template; and {\it (iii)} the paths $\{\tau'_{r,j}\}$ must satisfy the running constraint $\gamma^-_1$ for all $t = 1, \ldots, T-1$, and they also satisfy the terminal constraint $\gamma^-_{1,2}$ at time instant $T$ and $\gamma^-_{2}$ at time instant $T+1$.
%% \end{defn}

%%  In this instantiation, time instants $0$, $T$ and $T+1$ indicate the completion time of the immediately preceding subtask, the completion time of  the current subtask and the activation time of the next subtask, respectively. The paths do not need to satisfy the running constraint $\gamma_1^-$ at time instants 0,  $T$ and $ T+1$ since the tightest span of the vertex label of the current subtask can be one time instant later than the completion of the immediately preceding subtask and one time instant earlier than the completion of the current subtask.

%%  \subsubsection{$\gamma(v_2)=\bot$}\label{sec:gmmpp2} Given the current subtask $(v_1, v_2) \in \theta_\phi$, when $\gamma(v_2) = \bot$, we have $v_2 = \vertex{accept}$. In this case, we consider these two subtasks $(v_1, v_2)$ and $(v_2, v_{\text{next}})$ together. First, we treat the edge label $\gamma(v_2, v_{\text{next}})$ as if it were the vertex label of $v_2$, since $\gamma(v_2, v_{\text{next}})$ should be satisfied one step later after the subtask $(v_1, v_2)$, acting like the vertex label of $v_2$. Therefore, similar to case~\hyperref[sec:gmmpp1]{{\it 1)}}, we obtain the negative clause $\gamma^-_2$ and the subset of robots $\ccalR^-$  from the label $\gamma(v_2, v_{\text{next}})$ and $\gamma_2^-$ should still be satisfied at time instant $T+1$. The subset $\ccalR_2$ is empty since $\gamma(v_2, v_{\text{next}})$ is $\top$. Next, we consider extra constraints compared to the instantiation in case~\hyperref[sec:gmmpp1]{{\it 1)}}, which are related to the vertex label of $v_{\text{next}}$. Specifically, we require that $\gamma(v_{\text{next}})$ be activated at time instant $T+2$ (thus, $x=2$). To this end, let $\ccalR'_2$ collect all essential robots related to the  essential clause of $\gamma(v_{\text{next}})$ so that the set $\ccalR$ of robots that need to move also includes $\ccalR'_2$ and robots in $\ccalR'_2$ should reach target regions at time instant $T+2$. Furthermore, we denote by $\gamma'^-_2$ the negative clause related to $\gamma(v_{\text{next}})$ and the set of robots $\ccalR^-$ should include all robots of some types that appear in negative literals in $\gamma_2'^-$. Therefore, $\gamma'^-_2$ is also a terminal constraint which should be satisfied at time instant $T+2$. In the following Section~\ref{sec:solution2mapp} we discuss how to solve the above  generalized multi-robot path planning problem with given horizon  $T+2$. The paths returned by this instantiation complete the subtasks $(v_1, v_2)$ and $(v_2, v_{\text{next}})$ and meanwhile activate the vertex label of $v_{\text{next}}$, thus, preparing for the start of the suffix part or robots returning to initial locations to make the suffix part a loop.
 %% \subsubsection{Robots return to the initial locations} When the robots need to return to initial locations of the prefix plan, all robots need to move, therefore, $\ccalR = \{\ccalK_j\}$.
 %% The initial locations $X_I(r,j)$ are the final  locations in~\hyperref[sec:gmmpp2]{{\it 2)}} that drive the transition to vertex $v_{\text{next}}$  and the target locations $X_G(r,j)$ are the final locations of the  prefix plan, which should be visited by robots in $\ccalR$ at time instant $T$, thus, $x=0$. We initialize horizon  $T$  as the  longest travelling time between the initial locations and target locations over robots in $\ccalR$. Furthermore, the set $\ccalR_1$ is empty since
 %% and  also the running constraint $\gamma_1^-$ determined by the negative clause in $\gamma(v_{\text{next}})$ is satisfied for all $t=1, \ldots,T$, where  the last time instant $T$ is included since there is no edge transition and the target locations still correspond to the vertex label $\gamma(v_{\text{next}})$.

 {\begin{algorithm}[!t]
    \caption{Executable multi-robot path planning}
    \algorithmendnote{The right-side time instant $\vec{t}(c+1)$ in~line~\ref{seq:axis} is the one before updated.}
      \LinesNumbered
      \label{alg:sequentialMAPP}
      \KwIn {environment $E$,  robot team $\{\ccalK_j\}$, subtask sequence $\theta_\phi$, waypoint sequence $\{p_{r,j}\}$, time sequence $\{t_{r,j}\}$, NBA $\autop^-$ and $\auto{subtask}^-$}
      \Comment*[r]{Initilization}
        $\tau_{r,j} = s_{r,j}^0 $, $\zeta_{r,j} = 0, \forall\, [r,j] \in \{\ccalK_j\}$, $c = 0$ \label{seq:initilization}\;
      \For{$e = (v_1, v_2) \in \theta_\phi$}{
        \Comment*[r]{Solving GMRPP}
        \If{\upshape initial robot locations satisfy the edge label $\gamma(v_1, v_2)$ \label{seq:initial}}{
          $\zeta_{r,j} = \zeta_{r,j} + 1, \; \forall \, [r,j] \in \ccalR_{1,2}$ \label{seq:counter_initial}\;
          $c = c + 1$ \label{seq:c_initial}\;
        }
        \Else{
          Formulate the GMRPP  \label{seq:ingredients}\;
          Solve the GMRPP for horizon $T$ or $T+1$ as in Section~\ref{sec:solution2mapp} to obtain paths $\tau'_{r,j}$. If no solution exists, increment $T$ by a constant\label{seq:mapp}\;
          \Comment*[r]{Update}
          \If{\upshape $v_2 = \vertex{accept}$  \label{seq:terminate_1}}{
            If $v_2$ has a self-loop, $\tau_{r,j} = \tau_{r,j} \cdot \tau'_{r,j}[1:T_e+1], \;\forall \,[r,j] \in \ccalR $, and repeat $T_e+1$ times the last waypoint in $\tau_{r,j}$ for robots in $[r,j] \in \{\ccalK_j\} \setminus \ccalR$; otherwise, add $\tau'_{r,j}[1:T_e]$ to $\tau_{r,j}$ and repeat $T_e$ times the last waypoint in $\tau_{r,j}$ \label{seq:finalpath}\;
            {\bf break}\;
          }
          %% \ElseIf{\upshape $v_2 = \vertex{accept}$ {\bf and} $\gamma(v_2) = \bot$ \label{seq:terminate_2}}{
          %%   $\tau_{r,j} = \tau_{r,j} \cdot \tau'_{r,j}[1:T_e], \;\forall \,[r,j] \in \ccalR $, and repeat $T_e$ times the last waypoint in $\tau_{r,j}$ for robots in $[r,j] \in \{\ccalK_j\} \setminus \ccalR$ \label{seq:finalpath}\;
          %%   {\bf break}\;
          %% }
           \Else{
            $\tau_{r,j} = \tau_{r,j} \cdot \tau'_{r,j}[1:T_e], \;\forall \,[r,j] \in \ccalR $, and repeat  $T_e$ times  the last waypoint in $\tau_{r,j}$ for robots in $[r,j] \in \{\ccalK_j\} \setminus \ccalR$ \label{seq:path}\;
            $t_{r,j}(\zeta) =  t_{r,j}(\zeta)  + T_e - (\vec{t}(c+1) - \vec{t}(c))$, $\forall \,\zeta \geq  \zeta_{r,j}$, and $ \forall\, [r,j] \in \{\ccalK_j\} $ \label{seq:timeline} \;
            $\vec{t}(c') = \vec{t}(c') + T_e - (\vec{t}(c+1) - \vec{t}(c))$, $ \forall \, c' \geq c+1$  \label{seq:axis}\;
            $\zeta_{r,j} = \zeta_{r,j} + 1, \; \forall \, [r,j] \in \ccalR_{1,2}$ \label{seq:counter}\;
            $c = c + 1$ \label{seq:c}\;
          }
        }
      }
      %% \If{\upshape close the loop for the suffix plan}{
      %%   Formulate the GMRPP by determining the set $\ccalR$ of robots required to move, the updated environment $E'$, sets of initial locations $X_I$ and target locations $X_G$, running constraint $\gamma_1^-$, and horizon $T$ \label{seq:ingredients_loop}\;
      %%   Solve the GMRPP for horizon $T$ as in Section~\ref{sec:solution2mapp} to obtain paths $\tau'_{r,j}$. If no solution exists, increment $T$ by a constant\label{seq:mapp_loop}\;
      %%    $\tau_{r,j} = \tau_{r,j} \cdot \tau'_{r,j}[1:T_e], \;\forall \,[r,j] \in \ccalR $ \label{seq:finalpath}\;
      %% }
\end{algorithm}}

 \subsubsection{Sequential solving of  GMRPP to find low-level paths that incur the simple pathx $\theta_\phi$:}
The algorithm to design executable paths based on GMRPP under the  partial-moving scheme is outlined in Alg.~\ref{alg:sequentialMAPP}.  We initialize all local counters and the global clock as 0 [line~\ref{seq:initilization}, Alg.~\ref{alg:sequentialMAPP}].
If the first subtask in the simple path $\theta_\phi$, that is, the edge label of the first subtask,  is satisfied by the initial  robot locations, we increase the local counters of robots that participate  and the global counter by 1 [lines~\ref{seq:initial}-\ref{seq:c_initial}, Alg.~\ref{alg:sequentialMAPP}]. Otherwise, we solve the corresponding GMRPP as in Section~\ref{sec:solution2mapp}.  We initialize $T$ by $\vec{t}(c+1) - \vec{t}(c)$,  which is the difference between the completion time of the immediately preceding subtask and the current one. Another instance of GMRPP is generated by incrementing $T$ until a solution is found and we denote by $T_e$  the final $T$ of the solution [line~\ref{seq:mapp}, Alg.~\ref{alg:sequentialMAPP}]. {Given a solution to the generalized mulri-robot planning problem, Alg.~\ref{alg:sequentialMAPP} proceeds with the following updates [lines~\ref{seq:path}-\ref{seq:c}, Alg.~\ref{alg:sequentialMAPP}].

{If the  end vertex $v_2$ of subtask $e$ is $\vertex{accept}$ and $\vertex{accept}$ has a self-loop, the iteration terminates since the associated GMRPP finds paths that satisfy the label $\gamma(\vertex{accept})$ at the final time $T_e + 1$ and the only remaining edge with label $\top$ is satisfied naturally (see Fig.~\ref{fig:sub-NBA}) [line~\ref{seq:terminate_1}, Alg.~\ref{alg:sequentialMAPP}]. For robot $[r, j] \in \ccalR$, we append the path segment $\tau'_{r,j}(t)$, for all $t = 1, \ldots, T_e+1$, to its already-executed path $\tau_{r,j}$, i.e.,  $\tau_{r,j} = \tau_{r,j} \cdot \tau'_{r,j}[1:T_e+1]$ where ``$\cdot$'' denotes the concatenation of two path segments. Then, for other robot $[r,j] \in \{\ccalK_j\}\setminus \ccalR$, we  append  $T_e+1$ times  the last waypoint of  $\tau_{r,j}$  to $\tau_{r,j}$, that is, these robots  remain idle for $T_e+1$ time instants [line~\ref{seq:finalpath}, Alg.~\ref{alg:sequentialMAPP}]. In the full-moving scheme, path segments of all robots will be provided by the solution of GMRPP. If the  end vertex $v_2$ of subtask $e$ is $\vertex{accept}$ and $\vertex{accept}$ does not have a self-loop, the iteration also terminates and  we take similar steps to append $T_e$ waypoints in the path segments to already-executed ones [line~\ref{seq:finalpath}, Alg.~\ref{alg:sequentialMAPP}].

Otherwise, if the end vertex $v_2$ is regular, first, for robot $[r, j] \in \ccalR$, we append the path segment $\tau'_{r,j}(t)$, for all $t=1,\ldots, T_e$, to its already-executed path $\tau_{r,j}$. Then, for other robot $[r,j] \in \{\ccalK_j\}\setminus \ccalR$, we  append  $T_e$ times the last waypoint of  $\tau_{r,j}$  to $\tau_{r,j}$ [line~\ref{seq:path}, Alg.~\ref{alg:sequentialMAPP}]. We only append the first $T_e$ waypoints so that the final waypoint of $\tau_{r,j}$ always corresponds to the completion of the current  subtask, which can always activate the next subtask at the next instance of GMRPP due to that the final waypoint will be the initial locations of the next instance of GMRPP and it  can transition to waypoints at time instant $T_e+1$ which activates the next subtask.  Morevoer, for each robot $[r,j] \in \{\ccalK_j\}$, we increase the time instants in $t_{r,j}$ with indices larger than or equal to  $\zeta_{r,j}$ by $T_e - (\vec{t}(c+1) - \vec{t}(c))$ [line~\ref{seq:timeline}, Alg.~\ref{alg:sequentialMAPP}], where $\vec{t}(c+1) - \vec{t}(c)$ is the time span of the current subtask  given by the high-level plan whereas $T_e$ is the time span given by the low-level executable path.
    Similarly, we increase the time instants in $\vec{t}$ with indices larger than or equal to  $c+1$ by $T_e - (\vec{t}(c+1)- \vec{t}(c))$.
    In this way, for all high-level plans, the subsequent parts that have not been executed are shifted into the future by the same amount in order to mantain the correct temporal relation (precedence or simultaneity) between visitation of waypoints in $\{p_{r,j}\}$. Next, we increase  the local counter by 1 for all robots in $\ccalR_{1,2}$, which captures progress towards completing their individual plans [line~\ref{seq:counter}, Alg.~\ref{alg:sequentialMAPP}]. Similarly, we increase the global counter $c$ by 1 [line~\ref{seq:c}, Alg.~\ref{alg:sequentialMAPP}].}


\begin{figure}
  \centering
  \subfigure[$t=4$]{
    \includegraphics[width=0.3\linewidth]{gridworld_4.pdf}
    \label{fig:frame4}
  }
  \subfigure[$t=8$]{
    \includegraphics[width=0.3\linewidth]{gridworld_8.pdf}
    \label{fig:frame8}
  }
  \subfigure[$t=15$]{
    \includegraphics[width=0.3\linewidth]{gridworld_15.pdf}
    \label{fig:frame15}
  }
  \caption{Key frames demonstrating the execution of low-level paths that satisfy the task~\hyperref[task:i]{\it {(i)}}. Fig.~\ref{fig:frame4} shows that at time instant 4, robots $[2,1]$ and $[3,1]$  reach the office building $\ell_2$, while robot $[2,2]$ are on the way to the road $\ell_4$. Fig.~\ref{fig:frame8} shows that at time instant 8, robot $[2,2]$ reaches the road $\ell_4$ while robots $[2,1]$ and $[3,1]$ head towards the open area $\ell_3$. Finally, they reach $\ell_3$ in Fig.~\ref{fig:frame15} at time instant 15.}
  \label{fig:frames}
  \end{figure}
\begin{cexmp}[(Low-level paths)]
  Continuing the task~\hyperref[task:i]{\it {(i)}}, Fig.~\ref{fig:frames} shows an array of 3 key frames where subtasks are completed. Note that task~\hyperref[task:i]{\it {(i)}} is completed at time instant 15, which is longer than 12 given by the high-level plan due to that the high-level plan considers the shortest travelling time between regions and  collision avoidance is tackled in the low-level paths.
\end{cexmp}
\subsection{Solution to the generalized multi-robot path planning}\label{sec:solution2mapp}

\begin{figure}[t]
  \centering
  \includegraphics[width=1\linewidth]{mapp.pdf}
  \caption{Time-expanded graph over horizon $T+1$} (modified from~\cite{yu2016optimal})
  \label{fig:mapp}
\end{figure}

\begin{figure}[t]
  \centering
  \includegraphics[width=0.5\linewidth]{gadget.pdf}
  \caption{Merge-split gadget for avoiding head-on collision} (from~\cite{yu2016optimal})
  \label{fig:gadget}
\end{figure}
{ Conventional multi-robot path planning on graphs finds collision-free and optimal paths for groups of robots starting from a set of initial locations and ending at a set of desired target locations; see, e.g., \cite{yu2016optimal} and the references therein. To find executable paths that satisfy the subtasks defined here, we generalize the mult-robot path planning problem in several ways. First, in the partial-moving scheme,  only a subset of robots that are involved in the current or future subtasks are allowed to move.  Second, we extend the notion of a single target location to a taget region such that reaching any cell in the target region suffices. Third, the path segments that complete the  subtask should satisfy the corresponding vertex label and edge label.


  In what follows, we adapt the method proposed in~\cite{yu2016optimal} to solve GMRPP under the partial-moving scheme with given horizon $T+1$.   The key idea is to construct a time-expanded graph $\ccalG_T = (\ccalV_T, \ccalE_T)$ of the environment which contains $T+2$ copies of the free cells in the environment $E'$; see Fig.~\ref{fig:mapp}. We organize the vertices and edges of this time-expanded graph $\ccalG_T$ in a matrix structure, so that each row corresponds to a free cell in the environment $E'$ and each column corresponds to a time instant $t\in \{0,\ldots,T+1\}$. Then, a vertex $u_t \in \ccalV_T$ that appears in the $t$-th column of this matrix structure indicates whether the cell $u\in E'$ is occupied by a robot at the time instant $t$. The edges in $\ccalG_T$ capture  adjacency relations between neighboring cells in $E'$ and consecutive time instants in $\{0,\ldots,,T+1\}$. Specifically, for any two adjacent cells $u$ and $v$ in $E'$, an ``X''-shape structure, referred to as a {\it merge-split gadget}, is created to capture the transition from vertex $u$ at time $t$ to vertex $v$ at time $t+1$; see also Fig.~\ref{fig:gadget}. In this way, robots traveling along a given row in the matrix structure corresponding to $\ccalG_T$ effectively remain idle at their current cell, while robots switching between different rows in $\ccalG_T$ transition between adjacent cells in $E'$. We say that a sequence of transitions in $\ccalG_T$ form $t=0$ to $t=T+1$ produces a robot path in the environment $E'$.

Next, we formulate an Integer Linear Programming (ILP) to solve the GMRPP. Let $s_{uvrj} \in\{0,1\}$ be the routing variable such that $s_{u_{t}v_{t+1}rj} = 1$ if robot $[r,j]$ traverses the edge $(u_t,v_{t+1}) \in \ccalE_T$. In what follows, we describe the constraints and objective of this ILP.


\subsubsection{Routing constraints:}
The constraint that each edge can be traversed by at most one robot at the given time is encoded as}
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}
  \sum_{[r,j] \in \ccalR} s_{u_t v_{t+1}rj} \leq 1, \quad \forall \,(u_t,v_{t+1}) \in \ccalE_T,
\end{align}
\endgroup
for all $t=0,\ldots, T$, where $[r,j]\in\ccalR$ means the summation is taken over all robots in $\ccalR$. Furthermore, the flow conservation constraint is encoded as,
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begingroup
  \begin{align}\label{equ:flow}
  \sum_{u_{t-1}:(u_{t-1}, v_t) \in \ccalE_T}   s_{u_{t-1} v_t rj} &  =   \sum_{w_{t+1}:(v_t, w_{t+1}) \in \ccalE_T} s_{v_t w_{t+1} rj},
  \end{align}
\endgroup
for all $[r,j]\in \ccalR$ and all $t=1,\ldots,T$. This means that every robot that arrives at a vertex in $\ccalG_T$ has to leave that vertex at the next time step. Next, the constraints at the initial time are encoded as,
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begingroup

\begin{subequations}\label{equ:source}
  \begin{align}
    \sum_{v_1:(u_0, v_1) \in \ccalE_T} s_{u_0v_1 rj} &  = 1,  \\
    \sum_{v_1:(w_0, v_1) \in \ccalE_T} s_{w_0v_1 rj} & = 0, \quad \forall\, w \in E'\setminus u,
  \end{align}
\end{subequations}
\endgroup
for all $[r,j]\in \ccalR$, where $u_0$ is the vertex that is associated with the cell $u = X_I(r,j)$ where robot $[r,j]$ is at the initial time. Constraints~\eqref{equ:source} say that robot $[r,j]$ has to depart from its initial location. Note that this departure is in the graph $\ccalG_T$ and is associated more with time than physical location.
\subsubsection{Collision-avoidance constraints:}
Avoiding head-on collision collisions at every  gadget, $\forall u, v \in E'$ with $u\not= v$ can be captured by the constraint
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begingroup
\begin{align}\label{eq:headon}
 \sum_{[r,j]\in \ccalR} \left( s_{u_t v_{t+1} r j } + s_{v_t u_{t+1} r j } \right) \leq 1, \; \forall \,(u_t, v_{t+1}) \in \ccalE_T,
\end{align}
\endgroup
for all $t=0,\ldots,T$. Moreover, avoiding meet collisions,  $\forall v \in E'$, can be captured by the constraint
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}\label{eq:meet}
 \sum_{[r,j]\in\ccalR}  \, \sum_{u_t: (u_t, v_{t+1}) \in \ccalE_T} s_{u_t v_{t+1} r j } \leq 1,  \; \forall \,(u_t, v_{t+1}) \in \ccalE_T,
\end{align}
\endgroup
for all $t=0,\ldots,T$.
\subsubsection{Target constraint:}
The general constraints that robot $[r,j]$ in $\ccalR_1, \ccalR_{1,2}$, $\ccalR_2$ and $\ccalR'_{2}$ arrives at a cell that is in the target region $X_G(r,j)$ at certain time instant $t$ can be encoded as
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begingroup
  \begin{align}\label{equ:sink}
  \sum_{v: v \in X_G(r,j) } \;\sum_{u_{t-1}:(u_{t-1}, v_{t}) \in \ccalE_T} s_{u_{t-1} v_{t} rj} &  = 1,
  \end{align}
  \endgroup
 Specifically, $t$ in constraint~\eqref{equ:sink} takes the value ranging from $1, \ldots, T-1$ when encoding the constraint that robot $[r,j] \in\ccalR_1$ reach or stay at the target region $X_G(r,j)$ to maintain the truth of  the vertex label of the current subtask.  For the constraint that robot $[r,j]\in\ccalR_{1,2}$ arrives at a cell in $X_G(r,j)$ at the time instant $T$ to complete the current subtask, we have $t = T$ in~\eqref{equ:sink}. Similarly,  the constraint that robot $[r,j] \in \ccalR_2$ arrives at a cell that is in the target region $X_G(r,j)$ at the time $T+1$ to activate the next subtask  can be encoded by assigning $T+1$ to $t$ in~\eqref{equ:sink}.

 \subsubsection{Running and terminal constraints:} The general running and terminal constraints that negative literals $\neg \ap{i}{j}{k}$ should be respected at certain time instant $t$ can be encoded as
   \begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}\label{equ:avoid}
  \sum_{[r,j]\in \ccalR \cap \ccalK_j} \sum_{v \in \ell_k \cap E'}   \sum_{u_{t-1}: (u_{t-1}, v_{t}) \in \ccalE_T} s_{u_{t-1} v_{t} r j } \leq i - 1,
\end{align}
\endgroup
where $[r,j] \in \ccalR \cap \ccalK_j$ means the summation is taken over all robots of type $j$ in $\ccalR$ and $v \in \ell_k \cap E'$ means the summation is taken over all cells in region $\ell_k$ that are not occupied by other robots that do not need to move. Then, the running constraint that any
negative literal $\neg\ap{i}{j}{k} \in \mathsf{lits}^-(\gamma_1^-)$ in the vertex label of the current subtask should be respected (excluding time instants $0, T$, $ T+1$), can be encoded by assigning to $t$ in constraint~\eqref{equ:avoid} values ranging from $1, \ldots, T-1$. Similarly, we encode the terminal constraint that the negative literal  $\neg\ap{i}{j}{k}$ in $\mathsf{lits}^-(\gamma_{1,2}^-)$ and $\mathsf{lits}^-(\gamma_{2}^-)$  should be satisfied at the time $T$ and  $T+1$, respectively, by letting $t$ in constraint~\eqref{equ:avoid} take the values of $T$ and $T+1$, respectively.
\subsubsection{ILP objective:} The ILP objective is to minimize the total travelling distance and is defined as
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begingroup
\begin{align}
  \text{min} \sum_{[r,j] \in \ccalR} \; \sum_{t\in \{0,\ldots, T\}} \sum_{(u_t, v_{t+1}) \in \ccalE_T} d_{uv} s_{u_{t} v_{t+1} r j}   .
\end{align}
\endgroup
where $d_{uv} \in \mathbb{N}$ is the distance between cells $u$ and $v$.

  The solution of this ILP provides  a collection of executable paths that satisfy  the current subtask at time $T$ and as well as the vertex label of the next subtask at time $T+1$. This means that these paths by construction enable the transition to the next subtask. The robot locations at time $T$ also serve as the initial locations for the next instance of GMRPP.


  \section{Correctness and Feasiblity}\label{sec:correctness}
  Given a discrete environment $E$, the initial robot configurations and the specification $\phi$ of which the set of restricted accepting runs is non-empty, it may be possible that some  words in the accepted language $\ccalL(\autop)$, that can incur restricted accepting runs, cannot be realized by physical paths in the discrete environment. Let $\ccalL_E^*(\autop)$ be the set that collect realizable words in $\ccalL(\autop)$ that can also incur restricted accepting runs. %% Moreover, given a pair of initial and accepting vertices, $v_0$ and $v_\text{accept}$, let $\ccalL^{v_0 \scriptveryshortarrow \vertex{accept}}_E(\autop)$ collect finite realizable words that can generate a run in $\autop$ from $v_0$ to $\vertex{accept}$ which is the prefix part of a restricted accepting run.
  Note that given a relaxed NBA or sub-NBA $\auto{}$ of $\autop$, we can always map a run  in $\auto{}$ to its counterpart in $\autop$. Similarly, we define $\ccalL_E(\auto{})$ as the set of relizable words in  $\ccalL(\auto{})$. Moreover,  we define $\ccalL^\phi_E(\auto{})$ as the set of realizable words in $\ccalL_E(\auto{})$ such that for the run in $\auto{}$ that is incurred by a realizable word in $\ccalL^\phi_E(\auto{})$, its corresponding run in $\autop$ is a restricted accepting run. In words, considering $\auto{} = \auto{subtask}^-$, if a path $\tau$ generates a word $w$ in $\ccalL_E^\phi(\auto{subtask}^-) \subseteq \ccalL_E(\auto{subtask}^-)$ and further $w$ incurs a run $\rho$ in $\auto{subtask}^-$, we have that its corresponding run $\rho_\phi$ in $\autop$ is a restricted accepting run, and we can attempt to modify $\tau$  to produce this run $\rho_\phi$ in $\autop$, satisfying the specification $\phi$.
  The following propositions show that feasibility of Problem~\ref{prob:1} is preserved under the proposed LTL-MRTA algorithm. The proofs are shown in the~\hyperref[sec:appendix]{Appendix}. The following proposition shows that the pruning steps in Section~\ref{sec:prune} do not affect the set of restricted accepting runs.
  \begin{prop}\label{prop:prune}
    Given a discrete environment $E$, the initial robot configurations and the specification $\phi$, after pruning steps in Section~\ref{sec:prune}, it holds that  $\ccalL_E^\phi(\autop^-) = \ccalL^*_E(\autop)$.
  \end{prop}
  %% Since $\autop^-$ is a sub-NBA of $\autop$, for any run in $\autop^-$, its counterpart in $\autop$ is itself.   Proposition~\ref{prop:prune} implies  that  pruning in Section~\ref{sec:prune} does not remove any realizable word  in $ \ccalL_E(\autop)$ that can incur a restricted accepting run,
    The proof can be found in Section~\ref{app:prune}. A direct consequence of Proposition~\ref{prop:prune} is that, any path that generates a word $w$ in  $\ccalL_E^\phi(\autop^-)$ satisfies the specification $\phi$, since the word $w$ belongs to $\ccalL^*_E(\autop)$. The following proposition shows that relaxation expands the set of accepting words.
  \begin{prop}\label{prop:inclusion}
 Given a discrete environment $E$, the initial robot configurations and the specification $\phi$, after the relaxation stage of replacing all negative literals with $\top$ in Section~\ref{sec:prune}, it holds that $\ccalL^\phi_E(\autop^-) \subseteq \ccalL^\phi_E(\auto{relax})$.
  \end{prop}
  The proof can be found in Section~\ref{app:inclusion}. Proposition~\ref{prop:inclusion} implies that a word $w$ in $\ccalL^\phi_E(\auto{relax})$ may not belong to $\ccalL^\phi_E(\autop^-)$, therefore, a path generating a word in $\ccalL^\phi_E(\auto{relax})$ may not satisfy the specficaition $\phi$, which is obvious since $\auto{relax}$ ignores the negative literals. The following corollary captures the difference between $\ccalL^\phi_E(\autop^-) $ and $\ccalL^\phi_E(\auto{relax})$ from the perspective of the runs they incur. First, we define $\ccalL^\phi(\auto{})$ as the set of  words in $\ccalL(\auto{})$ such that for the run in $\auto{}$ that is incurred by a word in $\ccalL^\phi(\auto{})$, its corresponding run in $\autop$ is a restricted accepting run. Apparently, $\ccalL_E^\phi(\auto{})  \subseteq \ccalL^\phi(\auto{})$.  Note that   $\auto{relax}$ is graphically equivalent to $\autop^-$ in terms of the vertex set and the edge set. We say that a run in $\auto{relax}$ is same as a run in $\autop^-$ if these two runs are the same sequence of vertices. Given a NBA $\auto{}$, Let $\Omega_E^\phi(\auto{})$ and $\Omega^\phi(\auto{})$ denote the set of runs in $\auto{}$ that are incurred by the words in $\ccalL_E^\phi(\auto{})$ and $\ccalL^\phi(\auto{})$, respectively.
    \begin{cor}\label{prop:equality}
Given a discrete environment $E$, the initial robot configurations and the specification $\phi$, after the relaxation stage of replacing all negative literals with $\top$ in Section~\ref{sec:prune}, it holds that $\Omega_E^\phi(\autop^-) \subseteq  \Omega_E^\phi(\auto{relax}) \subseteq \Omega^\phi(\autop^-)$.
    \end{cor}
    The proof can be found in Section~\ref{app:equality}. A direct consequence of Corollary~\ref{prop:equality} is that when all restricted accepting runs can be incurred by feasible paths, we get that $\Omega_E^\phi(\autop^-) =  \Omega_E^\phi(\auto{relax})$. In this case, given a path $\tau_{\text{relax}}$ that generates a word in $\ccalL_E^\phi(\auto{relax})$, there exists a path $\tau_{\phi^-}$ that generates a word in $\ccalL_E^\phi(\autop^-)$ such that the two runs incurred by these two words, one in $\auto{relax}$ and the other in $\autop^-$, are identical. The difference between $\tau_{\text{relax}}$ and $\tau_{\phi^-}$ is that $\tau_{\text{relax}}$ does not take the negative literals into account. According to Proposition~\ref{prop:prune}, $\tau_{\phi^-}$ satisfies the specification $\phi$. Therfore, given such a path $\tau_{\text{relax}}$ and its incurred run, we conclude that it can be modified to satisfy the specification $\phi$ while keeping the incurred run unchanged. This justifies our method in Section~\ref{sec:solution2mrta} to design low-level paths for $\autop^-$ by following the simple path  that is incurred by a high-level plan in $\auto{subtask}^-$ ($\auto{subtask}^-$ is a sub-NBA of $\auto{relax}$).

     Given a pair of initial and accepting vertices, $v_0$ and $v_\text{accept}$, let $\ccalL^{\phi, v_0 \scriptveryshortarrow \vertex{accept}}_E(\auto{})$ be the set that collects finite realizable words that can generate a run in $\auto{}$ from $v_0$ to $\vertex{accept}$ whose  correponding run in $\autop$ is the prefix part of a restricted accepting run. Furthermore, let $\tilde{\ccalL}^{\phi, v_0 \scriptveryshortarrow \vertex{accept}}_E(\auto{}) \subseteq \ccalL^{\phi, v_0 \scriptveryshortarrow \vertex{accept}}_E(\auto{})$ collect those words in $\ccalL^{\phi, v_0 \scriptveryshortarrow \vertex{accept}}_E(\auto{})$ that can be generated by paths that meet Assumption~\ref{asmp:same}. The following two proposition show that extraction and pruning of the sub-NBA do not empty the set of restricted accepting runs that can be incurred by feasible paths that meet the Assumption~\ref{asmp:same}. The detailed proof can be found in Section~\ref{app:nonempty} and~\ref{app:sub-NBA}, respectively.

  \begin{prop}\label{prop:nonempty}
    Given a discrete environment $E$, the initial robot configurations and the specification $\phi$, for a pair of initial and accepting vertices, $v_0$ and $\vertex{accept}$, after the extraction of the sub-NBA $\auto{subtask}$ in Section~\ref{sub-NBA:1}, it holds that  $\ccalL^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{relax}) = \ccalL^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask})$.
  \end{prop}

 \begin{prop}\label{prop:sub-NBA}
   Given a discrete environment $E$, the initial robot configurations and the specification $\phi$, for a pair of initial and accepting vertices, $v_0$ and $\vertex{accept}$, after the pruning steps in Section~\ref{sub-NBA:2}, it holds that $\ccalL^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-) \subseteq \ccalL^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask})$. Additionally, if $\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}) \not= \emptyset$, then $\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-) \not= \emptyset$.
 \end{prop}

 Consider a finite path $\tau$ that  generates a finite word $w \in\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-)$. Let $\rho$  denote the incurred run in $\auto{subtask}^-$ and $p$ denote the simple path obtained from $\rho$. This simple path exists due to condition~\hyperref[cond:a]{\it (a)} in Definition~\ref{defn:run}.  Assuming that the poset $P$ is inferred from the set of simple paths that contains $p$.  The following proposition shows that the MILP formulation for the prefix part that is based on the poset $P$ is feasible.


 \begin{prop}\label{prop:feasibility}
   If there exists a path $\tau$ that generates a finite word $w \in \tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-)$, and the word $w$ incurs a simple path that lies in the set of simple paths from which the poset $P$ is inferred,
   then the  MILP formulation  in Section~\ref{sec:milp} that is based on the poset $P$  is feasible with any positive integer $M_{\textup{min}}$.
 \end{prop}
\begin{proof}
    The detailed proof can be found in Section~\ref{app:feasibility}. In particular, the path $\tau$ that generates the word $w$ can give rise to a high-level plan  that satisfies constraints~\eqref{eq:1}-\eqref{eq:same} in Section~\ref{sec:milp}  with any positive integer  $M_{\textup{min}}$.
\end{proof}

\begin{prop}
  If there exists a finite word $w \in \ccalL^{\phi,\vertex{accept} \scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-)$ for which the essential word $w^*$ exists, then the formulation of MILP in Section~\ref{sec:milp} with any positive integer $M_{\textup{min}}$ is feasible. In particular, the path $\tau$ that generates the word $w$ can be slightly modified to provide a solution that satisfies constraints~\eqref{eq:1}-\eqref{eq:same} in Section~\ref{sec:milp} and constraints~\eqref{eq:same_suffix}-\eqref{eq:return_suffix} in Section~\ref{sec:suf} with any positive integer  $M_{\textup{min}}$.
\end{prop}

\begin{prop}

\end{prop}

 %% (i) determine the set of sets of atomic propositions $\sigma$'s in $w$ that enable the edge transitions in $\rho$. The set of atomic propositions $\sigma_e$ indexed by $e\in \mathbb{N}$  is such if $v_{e-1} \neq v_e$ in the run $\rho$; (ii) randomly select one clause in the edge label $\gamma(v_{e_1}, v_e)$ is satisfied by $\sigma_e$, then all literals in this clause also appear in $\sigma_e$. We collect these literals to construct the $e$-th set $\sigma^*_e$ in the essential word; (iii)
\section{Simulation Results}\label{sec:sim}
We present two case studies, implemented in Python 3.6.3 on a computer with 2.3 GHz Intel Core i5 and 8G RAM, that illustrate the correctness and efficiency of our method. The MILP is solved using Gurobi~\cite{gurobi} with $M_{\text{max}}=10^5$ and $M_{\text{min}}=1$. We generate a  $10\times 10$ grid world with 10 regions and 10 obstacles randomly placed in the world at each trial. The team of robots consists of of 5 types with $N$ robots of each type. The initial locations are randomly generated.
%% \begin{table}[t]
%%   \caption{Results with respect to the size of workspace}\label{tab:1}
%%   \centering
%%   \begin{tabular}{cccccc}
%%     \toprule
%%     $W$ & $T$(sec) & $W$ & $T$(sec) & $W$ & $T$(sec)\\
%%     10& 122.00 &  20 & 119.12& 50& 120.10\\
%%      \bottomrule
%%   \end{tabular}
%% \end{table}

%% \subsubsection{Case \RNum{1}}First, we consider a team of robots of 3 types, with each type including 4 robots. The LTL task captures a multi-agent travelling salesman problem (TSP)~\cite{bektas2006multiple},
%% %\vspace{-1em}

%% \endnotesize
%% \begin{align*}
%%   %% \phi = & \Diamond \ap{1}{1}{1} \wedge \Diamond \ap{1}{2}{2} \wedge \Diamond \ap{1}{3}{3} \wedge \Diamond \ap{1}{1}{4} \wedge \Diamond \ap{1}{2}{5} \wedge \Diamond \ap{1}{3}{6} \nonumber \\  & \wedge \Diamond \ap{1}{1}{7} \wedge \Diamond \ap{1}{2}{8} \wedge \Diamond \ap{1}{3}{9} \wedge \Diamond \ap{1}{1}{10} \\
%%   \phi_1=  \bigwedge\nolimits_{j\in [3]} (\Diamond \ap{1}{j}{j}) \wedge \bigwedge\nolimits_{j\in [3]} (\Diamond \ap{1}{j}{j+3}) \wedge \bigwedge\nolimits_{j\in [3]} (\Diamond \ap{1}{j}{j+6}) \wedge (\Diamond \ap{1}{1}{10})
%% \end{align*}
%% \normalsize
%% For simplicity, we define only $t^-_{vr}$ for vertices associated with edge labels, since $t^-_{vr} = t^+_{vr}$. The  MILP has 454 variables and 638 constraints. We vary  $W$ and the results are averaged over 5 runs for each $W$. Each time the solution attains the optimal allocation in terms of the sum of the travelling distance, i.e., $\sum_{(u,v)\in \ccalE_\ccalG}  \sum_{r \in \ccalM^\ccalV_{\ccalK}(v)} w_{uv} x_{uvr}$, which is verified by a brute-force search method.
%% For $W=10,20,50$, the average runtimes are $122.00,119.12, 120.10$ in seconds, respectively, which accounts for the time needed to build the  NBA all the way to extracting a solution. The runtimes are similar since only the shortest paths between pairwise regions are required and the MILP only generates a sequence of waypoints that is then augmented using the shortest paths.
\subsubsection{Case \RNum{1}} {The cooperative persistence coverage task is}

\small
\begin{align*}
  %% & \phi = \square \Diamond \ap{x}{1}{1} \wedge \square \Diamond \ap{x}{2}{2} \wedge \square \Diamond \ap{x}{3}{3}  \wedge \square \Diamond \ap{x}{4}{4} \wedge \square \Diamond \ap{x}{5}{5} \nonumber \\
  %% & \wedge \Diamond \square\ap{x}{1}{6} \wedge \Diamond \square\ap{x}{2}{7} \wedge \Diamond \square\ap{x}{3}{8} \wedge \Diamond \square\ap{x}{4}{9} \wedge \Diamond \square\ap{x}{5}{10}
   \phi_2 = \bigwedge\nolimits_{j\in[4]} \square \Diamond( \ap{x}{j}{j} \wedge \ap{x}{j+1}{j} ) ,
\end{align*}
\normalsize
where $x = N/3$. We vary $N$ and compare our method to the method for cLTL+ problems in~\cite{sahin2019multirobot} in terms of runtime and cost measured by~\eqref{eq:cost} with $w=0.5$. This task cannot be categorized as a cLTL problem since here robots are heterogeneous. {Although translating LTL to NBA is worst-case exponential w.r.t. the length of the formula, in practice the translation is quick (0.03 and 0.10 seconds for case \RNum{1} and \RNum{2}, respectively). Both NBAs $B$ and $\auto{relax}$ have 5 vertices and 14 edges (excluding self-loops). The size of $B$ is independent of the number of robots. There is one pair of initial and accepting vertices and  $\auto{subtask}^-$ has 5 vertices and 5 edges.} Since the method in~\cite{sahin2019multirobot} depends on the horizon $h$ of the plan, we vary $h$ between 5, 10, 15.\endnote{The SAT solver Z3 is used to solve the Integer Linear Programming since~\cite{sahin2019multirobot} addresses feasibility and all variables are binary.} The results  are shown in Table~\ref{tab:2} and are averaged over 10 trials for each $N$. Our method is two orders of magnitude faster than~\cite{sahin2019multirobot}. This is because it decomposes the problem so that first a sequence of waypoints is decided by solving a MILP and then a shortest path  between waypoints is computed. More importantly, our method outperforms~\cite{sahin2019multirobot} in terms of cost.  The feasibility-oriented formulation in~\cite{sahin2019multirobot} causes robots that are not assigned to any task to move aimlessly, while in our solution, such robots remain idle.

%% \begin{table}[t]
%%   \centering
%%   \caption{Comparative results w.r.t. the number of robots}\label{tab:2}
%%   \begin{tabular}{c|c|c|c|c}
%%    \toprule
%%    \multicolumn{2}{c|}{$N$} & 3 & 6 & 9 \\
%%    \midrule
%%    \multirow{4}{*}{\vtop{\hbox{\strut runtime}\hbox{\strut \;\,\,(sec)}}} & LTL-MRTA & {\bf 0.1}\bm{$\pm $}{\bf 0.0} & {\bf 0.9}\bm{$\pm$}{\bf 0.5} & {\bf 1.5}\bm{$\pm$}{\bf 0.7}\\
%%     & $h=5$ & 173.2$\pm$54.3 & 403.9$\pm$207.9 & 511.7$\pm$327.9\\
%%     & $h=10$ & 71.1$\pm$23.8 & 153.6$\pm$108.8  & 285.9$\pm$271.4\\
%%     & $h=15$ & 68.3$\pm$6.4 & 159.7$\pm$20.8 & 349.7$\pm$35.5\\
%%     \midrule
%%     \multirow{4}{*}{cost} & LTL-MRTA &  {\bf 19.9}\bm{$\pm$}{\bf 4.4} & {\bf 32.7}\bm{$\pm$} {\bf 3.4} & {\bf 46.9}\bm{$\pm$}{\bf 5.8}\\
%%     & $h=5$  & 63.0$\pm$8.0 & 118.7$\pm$22.7  & 156.5$\pm$32.7\\
%%     &$h=10$ & 64.4$\pm$5.7 & 126.6$\pm$14.5 & 189.2$\pm$18.8\\
%%     & $h=15$ & 92.5$\pm$5.4 & 185.2$\pm$ 6.5 & 268.7$\pm$16.5\\
%%         \bottomrule
%%   \end{tabular}
%% \end{table}

\subsubsection{Case \RNum{2}}We consider tasks where some locations are visited sequentially by the same set of robots. For instance, these can be tasks where objects are  picked up by several robots and then delivered to another location.
Let $N=5$. The LTL formula  considered is

\small
\begingroup
\begin{align*}
  \phi_3 = &  \square \Diamond (\pi^{\ell_1,0}_{3,1} \wedge \pi^{\ell_4, 0}_{4,4}) \wedge \Diamond ( \pi^{\ell_2,1}_{3,3} \wedge  (\pi^{\ell_2,1}_{3,3} \,\mathcal{U} \, \pi^{\ell_2,0}_{1,4})  \wedge \Diamond \pi_{4,3}^{\ell_3,0})   \nonumber \\ & \wedge \Diamond (\aap{2}{2}{\ell_7}{0} \wedge (\aap{3}{5}{\ell_8}{2} \vee \aap{3}{5}{\ell_{10}}{2}) \wedge \bigcirc  \Diamond  \aap{3}{5}{\ell_{9}}{2} ) \wedge \Diamond \square \aap{1}{2}{\ell_{10}}{0}
\end{align*}
\endgroup
\normalsize
The NBA $B$ has 31 vertices and 182 edges. There is one pair of initial and accepting vertices. The sub-NBA $\auto{subtask}^-$ has 25 vertices and 48 edges. The MILP has 3760 variables and 4477 constraints. The runtime over 10 trials is 4.8$\pm$2.2$s$. {An animation can be found in~\cite{ltlmrta}.} We observe that the paths satisfy the task. The methods in~\cite{schillinger2018decomposition,schillinger2018simultaneous,faruq2018simultaneous} can not address such cooperative tasks and~\cite{sahin2017provably,sahin2017synchronous,sahin2019multi,sahin2019multirobot} can not capture tasks where the same set of robots needs to visit different locations.


\section{Discussion}
The pruning of the NBA $B$ and the extraction of sub-NBA $\autop$ in~Section~\ref{sec:app} prunes the space of feasible solutions. Thus, optimality cannot be guaranteed. However, our method does not reduce the feasible set  too much. In particular, edges removed in step~\hyperref[prune:2]{2)} in Subsection~\ref{sec:prune} correspond to vertices with label $\bot$ that can not easily transition to next vertices {(weak terminal vertices in some sense)}. {In Subsection~\ref{sec:pregraph}, pairs of initial and accepting vertices with shorter total length are selected that lead to the  extraction of larger sub-NBA $\auto{subtask}^-$ {with more transitions} from $\auto{relax}$.} {The reason is that edge labels in shorter paths often contain conjunctions of several edge labels in longer paths}. Similarly, edges removed from $\auto{subtask}^-$ in step~\hyperref[sec:pregraph]{2)} {have alternatives simple paths} meaning that their corresponding subtasks can be decomposed into smaller sequential subtasks, {that is, same plan but different schedule}. Finally, in Subsection~\ref{sec:poset} the partial cover problem returns the poset that covers the largest set of linear plans, thus, keeping as many as transitions in $\auto{subtask}^-$. As a result, while optimality can not be guaranteed,  the solutions obtained from the proposed algorithm have low  enough cost. %% Finally, extension to the full class of LTL formulas including negative atomic propositions and consideration of mutual collision avoidance among robots will be our future direction.
\section{Conclusion}
We have proposed an efficient MILP solution to the LTL-MRTA problem. Numerical simulations show that our method outperforms existing methods in terms of runtime and quality of the solution.

\section{Appendix}\label{sec:appendix}
\subsection{Proof of Proposition~\ref{prop:prune}}\label{app:prune}
First, steps~\hyperref[prune:exclusion1]{\it 1)}-\hyperref[prune:violation2]{\it 6)} in Section~\ref{sec:prune} just merge redundant literals and remove infeasible clauses without removing vertices or edges  of the NBA. Given any clause $\ccalC$ in $\autop$, merging redundant literals results in a clause in $\autop^-$, denoted by $\ccalC'$, that is a subformula of the original one, therefore, the satisfaction of $\ccalC$ implies the satisfaction of $\ccalC'$. On the other hand, the satisfaction of a literal in $\ccalC'$ leads to the satisfaction of the same literal in $\ccalC$ and the merged literals because of this literal, therefore, the satifaction of $\ccalC'$ implies the satisfaction of $\ccalC$. Thus, $\ccalC$ and $\ccalC'$ are logically equivalent, which implies that $\autop$ and $\autop^-$ are logically equivalent after steps~\hyperref[prune:exclusion1]{\it 1)}-\hyperref[prune:violation2]{\it 6)}. Therefore, after steps~\hyperref[prune:exclusion1]{\it 1)}-\hyperref[prune:violation2]{\it 6)}, we conclude that  $\ccalL(\autop^-)= \ccalL(\autop)$ and further $\ccalL_E(\autop^-)= \ccalL_E(\autop)$. Next, we prove that $\ccalL_E^\phi(\autop^-) = \ccalL^*_E(\autop)$ after steps~\hyperref[prune:exclusion1]{\it 1)}-\hyperref[prune:violation2]{\it 6)}.

First, we show that $\ccalL_E^\phi(\autop^-) \subseteq \ccalL^*_E(\autop)$. Due to $\ccalL_E^\phi(\autop^-) \subseteq \ccalL_E(\autop^-)$ and $\ccalL_E(\autop^-)= \ccalL_E(\autop)$,  any word $w$ in $\ccalL_E^\phi(\autop^-)$ is also in  $ \ccalL_E(\autop)$. Furthermore, because $w \in \ccalL_E^\phi(\autop^-)$, the corresponding run in $\autop$ of the run $w$ incurs in $\autop^-$ is an restricted accepting run. This restricted accepting run  can be directly incurred by $w$ in $\autop$ since $w \in \ccalL_E(\autop)$ and $\autop^-$ and $\autop$ are logically equivalent, making $w \in \ccalL^*_E(\autop)$.
Thus, $\ccalL_E^\phi(\autop^-) \subseteq \ccalL^*_E(\autop)$. Next, we show that $\ccalL^*_E(\autop) \subseteq \ccalL_E^\phi(\autop^-)$. For any word $w \in \ccalL^*_E(\autop)$, we have that $w \in \ccalL_E(\autop)  = \ccalL_E(\autop^-)$. Since $w$ is in $\ccalL^*_E(\autop)$, the incured run in $\autop$ is a restrcited accepting run. We can map this run to $\autop^-$ and the mapped run can be incurred by $w$ as well, since $w = \ccalL_E(\autop^-)$ and $\autop$ and $\autop^-$ are logically equivalent. Thus, $w \in \ccalL_E^\phi(\autop^-)$ and $\ccalL^*_E(\autop) \subseteq \ccalL_E^\phi(\autop^-)$. Therefore, $\ccalL_E^\phi(\autop^-) = \ccalL^*_E(\autop) $.


As for the last step~\hyperref[prune:infeasible]{\it 7)}, removing infeasible transitions and unreachable vertices will not exclude any realizable words. Furthermore, according to condition \hyperref[cond:c]{\it c)} in Definiction~\ref{defn:run}, any restricted  accepting run  does not contain vertices without self-loops except the initial and accepting vertices, thus, removing such vertices in step~\hyperref[prune:infeasible]{\it 7)} will not affect the  set of restricted accepting runs of $\autop$. Similarly, because by condition~\hyperref[cond:d]{\it d)}, any edge whose label does not strongly imply its end vertex label, except that its end vertex is the accepting vertex,  can not appear in any restricted accepting run, removing such edges does not affect the set of restricted accepting runs, either.  Therefore, operations in step~\hyperref[prune:infeasible]{\it 7)} do not affect the set of restricted accepting runs in $\autop$, which leads to that the runs in $\autop^-$ that corrspond to these restricted accepting runs are not affected, either. Hence, $\ccalL^\phi_E(\autop^-)$ does not change in step~\hyperref[prune:infeasible]{\it 7)}. Due to that $\ccalL^*_E(\autop)$ is irrelevant to any processing of $\autop$, we conclude that $\ccalL^\phi_E(\autop^-) = \ccalL^*_E(\autop)$, completing the proof.
\subsection{Proof of Proposition~\ref{prop:inclusion}}\label{app:inclusion}
The inclusion is quite straightforward in that, given a clause $\ccalC$ in $\autop^-$, the clause $\ccalC'$ in $\auto{relax}$ obtained by replacing all negative literals in $\ccalC$ with $\top$ is a subformula of the original clause $\ccalC$, that is, the satisfaction of the original clause $\ccalC$ implies the satisfaction of $\ccalC'$ after replacement, which implies that any realizable word $w$ in $\ccalL_E(\autop^-)$ belongs to $\ccalL_E(\auto{relax})$. Thus, any word $w \in \ccalL^\phi_E(\autop^-)  \subseteq  \ccalL_E(\autop^-)$ belongs to $\ccalL_E(\auto{relax})$. Next, we prove that indeed any word $w \in \ccalL^\phi_E(\autop^-)$ belongs to  $\ccalL^\phi_E(\auto{relax})$ inside $ \ccalL_E(\auto{relax})$.

Since $w \in \ccalL^\phi_E(\autop^-)$, it can incur  a run in $\autop^-$ whose corresponding run in $\autop$ is a restricted accepting run. Since $w$ is also in $\ccalL_E(\auto{relax})$ and clauses in $\auto{relax}$ are the subformulas of the clauses in $\autop^-$, $w$ can incur the same run in $\auto{relax}$ as the run in $\autop^-$ (same sequence of vertices since $\auto{relax}$ and $\autop^-$ have identical vertex set and edge set). Additionally, these two runs correspond to the same restrcited accepting run in $\autop^-$. Therefore, $w \in \ccalL^\phi_E(\auto{relax})$, i.e.,  $\ccalL^\phi_E(\autop^-)\subseteq \ccalL^\phi_E(\auto{relax})$, completing the proof.

\subsection{Proof of Corollary~\ref{prop:equality}} \label{app:equality}
 We first show that  $\Omega_E^\phi(\autop^-) \subseteq  \Omega_E^\phi(\auto{relax})$. For any run $\rho$ in $\Omega_E^\phi(\autop^-)$, we denote by $w  \in  \ccalL^\phi_E(\autop^-)$ the word that incurs it.  Since $\ccalL^\phi_E(\autop^-) \subseteq \ccalL^\phi_E(\auto{relax})$, we have that $w \in\ccalL^\phi_E(\auto{relax})$. Furthermore, it can incur the same run in $\auto{relax}$ as $\rho$  in $\autop^-$ since clauses in $\auto{relax}$ are subformulas of clauses in $\autop^-$, that is, $\rho \in \Omega_E^\phi(\auto{relax}) $. Therefore, $\Omega_E^\phi(\autop^-) \subseteq  \Omega_E^\phi(\auto{relax})$.

   The inclusion relation $\Omega_E^\phi(\auto{relax}) \subseteq \Omega^\phi(\autop^-)$ is straightfoward considering that  any  run in  $\Omega_E^\phi(\auto{relax})$ will appear in $\Omega^\phi(\autop^-)$ due to $\auto{relax}$ and $\autop^-$ are graphically equivalent, completing the proof.

\subsection{Proof of Proposition~\ref{prop:nonempty}}\label{app:nonempty}
Given a pair of initial and accepting vertices, $v_0$ and $\vertex{accept}$, the correspondsing sub-NBA $\auto{subtask}$ is composed of all vertices and edges in $\auto{relax}$ that are in some paths that connect $v_0$ and $\vertex{accept}$, except that (i) all other initial and accepting vertices other than $v_0$ and $\vertex{accept}$ are removed; (ii) the self-loop of
$v_0$ (if exists) is removed if the initial robot locations do not satisfy its corresponding vertex label in $\autop^-$ along with the outgoing edges of the initial vertex if the initial robot locations do not satisfy their corresponding edge labels in $\autop^-$ (see Section~\ref{sub-NBA:1}).

First, according to condition \hyperref[cond:b]{\it b)} in the Definition of~\ref{defn:run}, any accepting run in the restricted set will not include more than one initial vertices and more than one accepting vertices. Since $\ccalL^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{relax})$ are related to the initial and accepting vertices $v_0$ and $\vertex{accept}$, removing other initial and accepting vertices will not affect $\ccalL^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{relax})$. Second, any word $w$ that, at the beginning, satisfies the label of the initial vertex $v_0$ whose self-loop is removed or labels of outgoing edges that are removed can not be generated by feasible paths since initial robot locations violate these labels. Therefore, any such word $w$ does not belong to $\ccalL^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{relax})$. Additionally, the removing of self-loops and outgoing edges only affect such words. Therefore, $\ccalL^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{relax})= \ccalL^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask})$, completing the proof.



\subsection{Proof of Proposition~\ref{prop:sub-NBA}}\label{app:sub-NBA}
First, the inclusion relation is trivial since $\auto{subtask}^-$ is obtained by removing edges from  $\auto{subtask}$  that is decomposable according to the sequential triangle property (see Definition~\ref{defn:st}). In what follows, we focus on the non-emptyness of $\ccalL^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-)$.

Considering 3 different vertices $v_1, v_2, v_3$ that have the ST property, we first  prove that, given a path segment $\tau_{\text{seg}}$ that completes the subtask $(v_1, v_3)$, that is, driving the transition to vertex $v_3$ while satisfying the vertex label $\gamma(v_1)$ en route, we can construct another path segment $\tau_{\text{seg}}'$ by simply repeating the last waypoint of $\tau_{\text{seg}}$ twice for each robot such that the path segment $\tau_{\text{seg}}'$ can incur a sub-run that traverse along edges $(v_1, v_2)$ and $(v_2, v_3)$ and visits $v_2$ at least twice (thus the vertex label $\gamma(v_2)$ is satisfied at least once to meet the condition~\hyperref[cond:e]{\it (e)} in the Definition~\ref{defn:run}).
Specifically, according to the Definition~\ref{defn:st} regarding ST property, since the path segment $\tau_{\text{seg}}$ satisfies the edge label $\gamma(v_1, v_3)$ at the final time  and the vertex label $\gamma(v_1)$ en route, and $\gamma(v_1, v_3) = \gamma(v_1, v_2) \wedge \gamma(v_2, v_3)$, we have that the path segment $\tau_{\text{seg}}$ satisfies the edge label $\gamma(v_1, v_2)$ and thus, $\tau_{\text{seg}}$ can drives the transition to vertex $v_2$. At the next time instant, if robots remain idle, i.e., remaining where they are at the end of $\tau_{\text{seg}}$, the vertex label $\gamma(v_2)$ can be satisfied since $\gamma_\phi(v_1, v_2) \simplies_s \gamma_\phi(v_2)$ and further $\gamma(v_1, v_2) \simplies_s \gamma(v_2)$. This is because all edges that do not stronly imply their end vertex labels (except $\vertex{accept}$) are removed in the pruning steps in Section~\ref{sec:prune}. Moreover, if robots remain idle for another time instant, the edge label $\gamma(v_2, v_3)$ can be satisfied as well since the last waypoint satisfies $\gamma(v_1, v_3)$. Therefore, the path segment $\tau_{\text{seg}}'$ can be constructed by concatenating $\tau_{\text{seg}}$ and two repetitions of its last waypoint. Furthermore, the construction of the path segment $\tau'_{\text{seg}}$ ensures that the Assumption~\ref{asmp:same} is met since the robots remain idle after satisfying the  edge label $\gamma(v_1, v_2)$.

If $\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}) \not= \emptyset$, then there exists a path $\tau$ that generates a word $w$ that incurs a run $\rho$ in $\auto{subtask}$ that connects $v_0$ and $\vertex{accept}$. We consider the case where  the run $\rho$ traverses a composite edge, otherwise, the run $\rho$ will exist in $\auto{subtask}^-$ and thus, $\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-) \ne \emptyset$. When the run $\rho$ traverses a composite edge, we can locate the path segment $\tau_\text{seg}$ in $\tau$ that enables this composite subtask and replace $\tau_\text{seg}$ with path segment $\tau'_{\text{seg}}$ constructed as above, then the new path $\tau'$ meets the Assumption~\ref{asmp:same} and will generate a word $w'$ that incurs a run $\rho'$ that traverses the two elementary edges that the composite edge corresponds to. Next, we prove that if the corresponding run $\rho_\phi$ in $\autop$ of the run $\rho$ is a prefix part of an accepting run in the restricted set, so is the run $\rho'_\phi$ that is the corresponding run of $\rho'$.

These two runs differ only in that $\rho$ traverse $v_1$ and $v_3$ while $\rho'$ traverses $v_1$, $v_2$ and $v_3$. Apparently, the run $\rho'_\phi$ meet the conditions~\hyperref[cond:a]{\it a)}-\hyperref[cond:c]{\it c)} of the restricted accpeting run. As discussed above, $\gamma_\phi (v_1, v_2) \simplies_s \gamma_\phi (v_2)$ and $\gamma_\phi(v_2, v_3) \simplies_s \gamma_\phi(v_3)$; otherwise, they are pruned in Section~\ref{sec:prune}. Thus, these two edges that $\rho'$ traverses satisfy the condition \hyperref[cond:d]{\it d)} regarding the strong implication in the Definition~\ref{defn:run}. Furthermore, $\rho'$ visits vertex $v_2$ twice, thus, condition \hyperref[cond:e]{\it e)} in the Definition~\ref{defn:run} is met. Morevoer, (i) if $v_3 \neq \vertex{accept}$, then $\rho'_\phi$ can be the prefix part of the same accepting run to which $\rho_\phi$ is the prefix part by concatenating the path $\tau'$ with the path behind $\tau$ that incurs this accepting run. Therefore, condition~\hyperref[cond:f]{\it f)} is met since it is met by the accepting run to which $\rho_\phi$ is the prefix part. In this case, $\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-) \neq \emptyset$. (ii) Otherwise, if $v_3= \vertex{accept}$, according to condition (e)  in Definition~\ref{defn:st}, $\gamma_\phi(v_3) = \top$ if $(v_1, v_3)$ is removed. In this case, the path $\tau'$ itself incurs a run $\rho'$ of which the corresponding $\rho'_\phi$ itself is a restricted accepting run. Thus, we also have $\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-) \neq \emptyset$. (iii) Finally, if $v_3 = \vertex{accept}$ and $\gamma_\phi(v_3)\neq \top$, we do not remove the subtask $(v_1, v_3)$. Therfore, $\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask})$ is not affected, which completes the proof.

\subsection{Proof of Proposition~\ref{prop:feasibility}}\label{app:feasibility}
To prove the feasiblity of the MILP formulation in Section~\ref{sec:milp}, we first obtain an {\it essential word} $w^*$ based on the word $w$ that is generated by the path $\tau$, such that the path $\tau$ can also generate the essential word and the essential word $w^*$ is the tightest word that can incur the same run $\rho$ as $w$ does; see Section~\ref{app:word}. Then, we show that the essential word $w^*$ can produce a graph that is a subgraph of the routing graph $\ccalG$ built in Section~\ref{sec:graph}; see Section~\ref{app:graph}. Given the run $\rho$ incurred by the word $w^*$, we can obtain a simpath path $p$ in $\auto{subtask}^-$ that connects $v_0$ and $\vertex{accept}$, which is a linear extension of the poset $P$ based on which the MILP is formulated. Furthermore, this simple path gives rise to a high-level plan that satisfies the MILP formulation based on the poset $P$; see Section~\ref{app:milp}.

\subsubsection{Construction of the essential word:}\label{app:word}
Consider a finite path $\tau$ that  generates a finite word $w = \sigma_0 \sigma_1 \sigma_2\ldots \sigma_k$ that belongs to  $\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-)$. Let $\rho=v_0 v_1 v_2\ldots \vertex{accept}$  denote the incurred run in $\auto{subtask}^-$ and $p$ denote the simple path obtained from $\rho$. Next we obtain  an {\it essential word}, denoted by $w^* =  \sigma^*_0 \sigma^*_1 \sigma^*_2\ldots \sigma^*_k$, such that  $\sigma^*_i \subseteq \sigma_i$ is the tightest subset of atomic propositions that enables one clause of the label $\gamma(v_i, v_{i+1})$ where $v_i$ and $ v_{i+1}$ are consecutive vertices in the run $\rho$, so that  removing any atomic proposition from $\sigma^*_i$ dissatisfies this clause. We identify the satisfied clause in the label $\gamma(v_i, v_{i+1})$  and put all positive literals in this clause  to $\sigma^*_i$. Note that clauses associated with  the same vertex labels are identical by the Assumption~\ref{asmp:same}. By default, $\sigma_i^* = \{\top\}$ if $\gamma(v_i, v_{i+1})=\top$.  In this way,  we have that $w^* \in \ccalL^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-)$
since it incurs the same run $\rho$ as $w$ does, and that the path $\tau$ generating the word $w$ is also a path that can generate the word $w^*$.

\subsubsection{Constrcution of a subgraph of the routing graph:}\label{app:graph}

Given the essential word $w^*$, we can divide it into parts by locating the components where edges in the incurred run $\rho$ in $\auto{subtask}^-$ are traversed; see also Fig.~\ref{fig:word}, where green columns represent single time instants, e.g., $t_{e-1}$ and $t_{e}$, when edges  are traversed, that is, subtasks are completed, and the white area between any two green columns represents the time intervalss, e.g., $t_{e-1}+1, \ldots, t_{e}-1$ , when the vertex labels are respected. Note that $t_{e+1}-1 \geq t_e+1$, since according to condition~\hyperref[cond:e]{\it e)} in Definition~\ref{defn:run}, the accepting run traverses any vertex at least twice, leading to that $t_{e} \geq t_{e-1}+2$. In this way,  the time interval $t_{e-1}+1, \ldots, t_{e}-1$ and the time instant $t_e$ make up the time span of the  subtask $e$ in the simple path $p$. Thus, given the path $\tau$, we can obtain an array of time spans of subtasks in the simple path $p$ such that every time span is disjoint with each other and subtasks are completed sequentially.

\paragraph{(i) Construction of the vertex set:} To build a graph $\ccalG_{w^*}$ based on the divied  essential word  $w^*$, we begin with the vertex set. First, we create the vertex set $\ccalV_{\text{init}}$ that corresponds to initial robot locations, as in Section~\ref{sec:vertex} for $\ccalG$.
We assign visit time 0 to these vertices. Then, considering a time instant $t_e$ when the edge of a subtask  $e = (v_1, v_2)$ in the path $p$ is traversed. The set $\sigma_{t_e}^*$ of atomic propositions  contains all literals appearing in the single clause that is satisfied in the edge label $\gamma(v_1, v_2)$. If $\gamma(v_1, v_2) = \top$, then $\sigma_{t_e}^* = \{\top\}$ and we do not create any vertex, as in Section~\ref{sec:vertex}. Otherwise, for each atomic proposition $\ap{i}{j}{k,\chi}$ in $\sigma_{t_e}^*$, we know that there are $i$ robots of type $j$ at region $k$ in the $t_e$-th state of the path $\tau$, and we also know which are within these $i$ robots by checking the path $\tau$. Similar to building the routing graph $\ccalG$ in Section~\ref{sec:vertex}, we construct $i$ vertices pointing to region $k$. Recall that we associate the whole fleet of robots of type $j$ with these $i$ vertices in $\ccalG$. However, for $\ccalG_{w^*}$, we have the information about which specific $i$ robots of type $j$ visit region $\ell_k$ at $t_e$ by checking the path $\tau$. Thus, we can have a one-to-one correspondence between these $i$ robots with these $i$ vertices. In this way, each vertex is visited by one robot. These robots are referred to as the essential robots in Section~\ref{sec:run}. Furthermore, the time that the specific  robot $r$ visits its assigned vertex $v$ is $t_e$, which is denoted by $t_{vr}^- = t_{vr}^+ = t_e$. Following this logic, we create vertices for other atomic propositions in $\sigma_{t_e}^*$, which only correspond to one single clause that is satisfied in $\gamma(v_1, v_2)$. Recall that when building the vertex set of $\ccalG$ in Section~\ref{sec:vertex}, given a label, we build such vertices for each clause. Therefore, the vertex set in $\ccalG_{w^*}$ for the edge label satisfied at $t_e$ is a subset of the vertex set in $\ccalG$ for the same edge label. Following this logic, we can build the vertex set for the satisfied clause in the starting vertex label of $e$. According to the Assumption~\ref{asmp:same}, the clauses satisfied remain the same, that is, $\sigma^*_t$'s remain the same for all $t= t_{e-1}+1, \ldots, t_{e}-1$. Also, it is the same fleet of robots satisfy this clause. Likewise, we can associate each vertex with one single robot, and the visit time interval is set as $[t_{e-1}+1, t_{e}-1]$. That is, the robot $r$ remains at its assigned vertex $v$  within this time interval,
%% needs to visit its assigned vertex $v$ at the time instant  no later than  $t_{e-1}+1$ and leave its assigned vertex at the time instant no earlier than $t_{e}-1$,
which are denoted by $t_{vr}^- = t_{e-1}+1$ and $t_{vr}^+ = t_{e}-1$. Recall also that, the routing graph $\ccalG$ creates vertices for all clauses in the vertex label.  Furthermore, we do not create vertices for labels either $\top$ or $\bot$, same as in Section~\ref{sec:vertex}. Therefore, we can conclude that the vertex set of $\ccalG_{w^*}$ is a subset of that of $\ccalG$.

\begin{figure}[!t]
  \centering
  \includegraphics[width=\linewidth]{word.pdf}
  \caption{The diviede essential word $w^*$.}
  \label{fig:word}
\end{figure}

\paragraph{(ii) Construction of the edge set:} Next, we prove that the edge set in $\ccalG_{w^*}$ is also a subset of the edge set in $\ccalG$. Still, consider the edge label that is satisfied at the time instant $t_e$. For a vertex $v$ among those associated with this edge label, we already know the robot $r$ that visits the vertex $v$. Our goal is to determine from which vertex in $\ccalG_{w^*}$ the robot $r$ comes. Let $\tau_{r,j}$ denote by the path of robot $r$ of type $j$. Tracing backward from the $(t_{e}-1)$-th waypoint in $\tau_{r,j}$ (included), we find the most recent time instant $t$  when the robot $r$ takes part in the satisfaction of a literal $\ap{i}{j}{k,\chi}$ that appears in the set $\sigma^*_{t}$ of atomic propositions (Given the path $\tau$, we know the fleet of robots that satisfy one certain aotmic proposoition in $\sigma^*_t$). (a) If such $t$ does not exist, then we create an edge starting from the vertex $u$ that points to the initial location of robot $r$ and ending at vertex $v$. We assign the travelling time  $t_e$ to the edge $(u,v)$. According to step~\hyperref[sec:a]{\it (i)} in Section~\ref{sec:edge_set}, the edge $(u,v)$ is  also  created in $\ccalG$. (b) If such time instant $t$ exists, let $e'$ denote the subtask this literal $\ap{i}{j}{k,\chi}$ corresponds to. If $e\neq e'$, we have that $e'$ occurs before $e$ in the given path $\tau$, since time spans of subtasks are disjoint and $t < t_e$. Thus, $e' \in X_{<_P}^{e} \cup X_{\|_P}^e$. We locate the vertex $u$ in $\ccalG_{w^*}$ that corresponds to the literal $\ap{i}{j}{k,\chi}$ and is visited by robot $r$, then an edge starting from $u$ and ending at $v$ can be created. Furthermore, we assign the weight $t_{vr}^- - t_{ur}^+$ to this edge ($t_{vr}^-=t_e$), which is the travelling time the robot $r$ takes between these two consecutive subtasks it undertook. We state that the edge $(u, v)$ also exists in $\ccalG$, since both $u$ and $v$ exist in $\ccalG$, they are associated with the same robot $r$, thus, same robot type, and $u$ is associated with a prior subtask $e'$ of $e$. According to the step~\hyperref[sec:b]{\it (ii)} regarding leaving vertices from prior subtasks in Section~\ref{sec:edge_set}, the edge $(u,v)$ will be created in $\ccalG$. (c) If $e'=e$, in this case, the vertex $u$ that robot $r$ visits is associated with the starting edge label of $e$. We create the edge $(u,v)$ and assign the travelling time  $t_{vr}^- - t_{ur}^+$. This edge will be created in $\ccalG$ following the step~\hyperref[sec:c]{\it (iii)} in Section~\ref{sec:edge_set}. Therefore, all edges in $\ccalG_{w^*}$ with the end vertice being assocaited with edge labels exist in $\ccalG$.

Following the same way, we create edges that are associated with the vertex label of subtask $e$. We deal with vertex labels that are netierh $\top$ nor $\bot$. Given a vertex $v$ in $\ccalG_{w^*}$ that is associated with the vertex label $\gamma(v_1)$ of the subtask $e$,  we find  the associated robot $r$ of type $j$. (a) If $e$ is the first completed subtask in the path $\tau$, then the initial locatons should satisfy the vertex label. Recall that in Section~\ref{sub-NBA:1}, we remove the self-loop of the initial vertex if the initial locations do not satisfy its label. We locate the vertex $u$ pointing to the initial location of the robot $r$ of type $j$, create an edge starting from vertex $u$ and ending at $v$ and assign the travelling time 0. This edge will be created in steps~\hyperref[edge:vertex1]{\it (a)} or ~\hyperref[edge:vertex2]{\it (b)} in Section~\ref{sec:edge_set}.
(b) If $v_1 \neq \vertex{accept}$ and the subtask $e$ is not the first completed subtask, we start tracing backward from the $t_{e-1}$-th waypoint (the completion time of the subtask immediately preceding subtask $e$) in the path $\tau_{r,j}$ to find the most recent time instant $t$ this robot joins another subtask. Condition~\hyperref[asmp:c]{\it (c)} implies that $t$ should be identical to $t_{e-1}$ since the path $\tau$ satisfies the Assumption~\ref{asmp:same}. That is, the robot $r$ should undertake the immediately preceding subtask and remain there after the completion. We locate the vertex $u$ associated with the edge label of subtask $e-1$ that robot $r$ visits, create an edge between $u$ and $v$ and assign the travelling time 0 to the edge. This edge will also be created in step~\hyperref[edge:vertex2]{\it (b)} in Section~\ref{sec:edge_set}. (c) If $v_1 = \vertex{accept}$, then subtask $e$ is the last completed subtask in the path $\tau$ since $\tau$ respects the partial order. We start tracing backward from the $t_{e-1}$-th waypoint in the path $\tau$ and create the edge by following case (b) when creating edges for the edge labels. This edge will also be created in step~\hyperref[edge:vertex3]{\it (c)} in Section~\ref{sec:edge_set}. Thus, the edge set of in $\ccalG_{w^*}$ is a subset of the edge set of $\ccalG$. Finally, we can conclude that the graph $\ccalG_{w^*}$ based on the essential word $w^*$ is a subgraph of the routing graph $\ccalG$ based on which the MILP is formulated.


The graph $\ccalG_{w^*}$ has the property that there are no cycles and any two paths in $\ccalG_{w^*}$, starting from vertices pointing to initial robot locations  and ending at a vertices without outgoing edges, do not share the same vertex, since each path is associated with a specific robot and aligns with the underlying path. Therefore, every vertex except the starting and end vertices in one path has indegree 1 (number of incoming edges) and outdegree 1 (number of outgoing edges). What's more, vertices in $\ccalG_{w^*}$ are associated with the tightest visit time intervals of the specific robot. Consequently, starting from the vertex correponding to the initial location of robot $r$ of type $j$, we can extract a high-level plan $p_{r,j}$ for this robot by traversing along edges, which is a concise description of the underlying path $\tau_{r,j}$. Observe that, given a feasible solution to the MILP, we can build a subgraph of $\ccalG$ by removing any vertices and edges that are not visited by any robots and associating robots and visit time with the remaining vertices. In some sense, such subgraph can be viewed as the graphical depiction of the solution to the MILP. In what follows, we show that the graph $\ccalG_{w^*}$ can be one of such graphs, that is, it can give rise to a feasible solution to the constraints~\eqref{eq:1}-\eqref{eq:same}.

\subsubsection{Satisfaction of MILP constraints:}\label{app:milp}
\paragraph{(i) Routing constraints:} Any vertex in $\ccalG_{w^*}$ is visited by a single robot of certain type, thus, constraint~\eqref{eq:1} that each vertex is visited by at most one robot of certain type can be  satisfied. That is, we can assign values to variables in constraint~\eqref{eq:1}. Specially, given a vertex $v$, its associated robot $r$ and unique vertex $u$ that is connected to $v$, we set $x_{uvr}=1$  and $x_{uvr'}=0$ for other robots $r'$ of the same type as $r$. In what follows, we omit the assignment analysis when it is clear to recognize. Furthermore, each vertex outside $\ccalV_{\text{init}}$  is either a sink veretex (indegree is 1, outdegree is 0) or a vertex with indegree equaling outdegree. Therefore, the flow constraint~\eqref{eq:2} is satisfied. For each vertex in $\ccalV_\text{init}$, its outdegree is either 0 or 1, thus, constraint~\eqref{eq:2.5a} is satisfied. Each vertex in $\ccalV_\text{init}$ is associated with a unique robot, thus, constraint~\eqref{eq:2.5b} is also satisfied.
\paragraph{(ii) Scheduling constraints:} Since the visit time of each vertex  is non-negative and the visit time associated with the vertices in $\ccalV_{\text{init}}$ is 0, constraints~\eqref{eq:3} and~\eqref{eq:3.5} are satisfied trivially. Recall that we assign the tavelling time $T_{uv}$  between connected vertices $u$ and $v$ as $t_{vr}^- - t_{ur}^+$, which is the acutual time the robot $r$ takes to travel between regions associated with $u$ and $v$. Obviously, $T_{uv}$ is no less than  the shortest travelling time between these two regions, thus, the scheduling constraint~\eqref{eq:4b} is satisfied. That is, when robot $r$ travels the edge $(u, v)$, i.e., $x_{uvr}=1$, constraint~\eqref{eq:4b} holds since $t^+_{ur} + T^*_{uv} \leq t^+_{ur} + T_{uv} = t^-_{vr}$. Next, constraint~\eqref{eq:4a} can be satisfied if all robots  are frozen for $M_{\text{min}}$ time instants within the time interval $[t_{ur}^+, t_{vr}^-]$, The elongated path can still generate a word belonging to $\ccalL^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-)$. (a) If vertex $u$ is associated with a vertex label, recall that we assign $t_e-1$ to $t_{ur}^+$ when constructing the edge set, that is, the time instant right before a subtask is completed, thus, the run has not left a vertex in $\auto{subtask}^-$ at the time instant $t_{ur}^+$. We can repeat $M_{\text{min}}$ times the locations of all robots in the path $\tau$ at the time instant $t_{ur}^+$  so that the run visits the same vertex  $M_{\text{min}}$ more times. (b) Similarly, if $v$ is assocaited with a vertex label, recall that we assign $t_{e-1}+1$ to $t_{vr}^-$ when constructing the edge set, that is, the time instant right after a subtask is completed. The vertex label is satisfied at $t_{vr}^-$ since the run in the resreicted set satisfies each vertex at least once. Thus, we can repeat $M_{\text{min}}$ times the locations of all robots in the path $\tau$ at the time instant $t_{vr}^-$  so that the run visits the same vertex  $M_{\text{min}}$ more times. (c) If both $u$ and $v$
are associated with edge labels, then these vertices must correspond to two different subtasks. Furthermore, there must be a vertex with self-loop between these two subtasks in the simple path $p$, since according to condition~\hyperref[cond:b]{\it b)} only initial and accepting vertices can have no self-loops but they can not be between two edges in the path $p$ if they do not have self-loops. In this case, robots can remain idle for $M_{\text{min}}$ times  when a vertex label is true. Finally, the modified path still produces a prefix part of an accepting run in the restricted set. Note that robots remaining idle for a period of time does not affect the satisfaction of other constraints since the relative temporal order of subtasks are not affected.

\paragraph{(iii) Logical constraints:} Each set $\sigma^*_i$ of atomic propositions in the essential word $w^*$ collects all literals inside one clause, and all $\sigma^*_i$'s that are associated with the same vertex label collect literals of the same clause. Therefore, constraint~\eqref{eq:c} that one and only one clause is true is satisfied. Although the path $\tau$ can satisfy more than one clauses in a label, we construct the essential word by selecting one clause and further  build the graph $\ccalG_{w^*}$ and select the essential robots based on $w^*$. In this sense, we can state that only one clause is true on the graph $\ccalG_{w^*}$. Moreover, because every vertex in $\ccalG_{w^*}$ corresponding to the same clause is visited by one robot, constraint~\eqref{eq:6} is satisfied. Recall that when constructing the vertex set of $\ccalG_{w^*}$, we associate each vertex $v$ corresponding to the same edge label with time $t_{vr}^- = t_{vr}^+ = t_e$, therefore, the simultaneous visitation constraint~\eqref{eq:7} is satisfied.

\paragraph{(iv) Temporal constraints:}
\paragraph{(a) Temporal constraints on one subtask:} As said before, each vertex $v$ in $\ccalG_{w^*}$ corresponding to the same edge label is associated with time $t_{vr}^- = t_{vr}^+ = t_e$, and only one clause is true, therefore, constraint~\eqref{eq:edgetime} regarding the computation of the completion time is satisfied. When constructing the vertex set of $\ccalG_{w^*}$, we assocaite each vertex $v$ corresponding to the same vertex label (neither $\bot$ nor $\top$) with the same arriving time $t_{vr}^- = t_{e-1}+1$ and the same leaving time $t_{vr}^+ = t_{e}-1$, where $t_e$ is the completion time of the subtask that the vertex label corresponds to and $t_{e-1}$ is the completion time of the subtask immediatedly preceding it in the simple path $p$. We have that $t_{vr}^- = t_{e-1}+1\leq t_e$, since subtasks/edges in $p$ are sequentially completed, which shows that the left side of constraint~\eqref{eq:17} holds. The right side holds trivially since $t_e = t_e-1+1$. Next, if the initial vertex does not have a self-loop, and if the outgoing edge in the simple path $p$ is labeled with $\top$, there is no vertex in $\ccalG_{w^*}$ that corresponds to this edge. We can just define the completion time of this edge label as 0, as stated by~\eqref{eq:tis0}. Otherwise, if the label of the outgoing edge is not $\top$, then the initial robot locations will satisfy it, that is, the set $\sigma^*_0$ of atomic propositions include literals therefore, vertices are created for these literals and are associated with completion time 0, same as the index of $\sigma_0^*$. Thus, in this case~\eqref{eq:tis0} also holds.

\paragraph{(b) Temporal constraints on the completion of two sequential subtasks:}
Since the simple path $p$ in $\auto{subtask}^-$, induced by the path $\tau$, is a linear extension of the poset $P$, so the linear order of subtasks in $p$ respects the partial order in the poset $P$. Thus, given a subtask $e$ in $p$, any subtask $e'\in p$ with $e' \prec_P e$, that is, $e'$ should be completed prior to $e$ and $e'$ can occurs immediately before $e$, is completed before $e$ by the path $\tau$. Therefore, $t_{e'} <t_e$. Furthermore, according to condition~\hyperref[cond:e]{\it e)} in the Definition~\ref{defn:run}, the accepting run in the restricted set traverses a vertex with self-loop at least twice. Therefore, at least $t_{e'} + 2 \leq t_e$ and constraint~\eqref{eq:12} with $M_{\text{min}}$ is satisfied by the path $\tau$. Additionally, since the accepting run satisfies the vertex label of subtask $e$ at the time instant $t_e-1$, we can modify the path $\tau$ by freezing all robots for $M_\text{min}$ time instants after $t_e-1$ as discussed in the satisfaction of the scheduling constraints, which implies that constraint~\eqref{eq:12} with any positive integer $M_{\text{min}}$ can be satisfied.
\paragraph{(c) Temporal constraints on the completion of the
current substask and the activation of subsequent
substasks:}
For each subtask $e$ except the last one in the simple path $p$, the subtask $e'$ immediately following it in $p$  belongs to the set $X_{\succ P}^e \cup X_{\|_P}^e$. If $X_{\succ P}^e \neq \emptyset$, since there is only one subtask in the simple path $p$ that immediately follows $e$, constraint~\eqref{eq:bafter} holds. Otherwise, If $X_{\succ P}^e = \emptyset$, since subtask $e'$ follows $e$, subtask $e$ is not the last one, constraints~\eqref{eq:afterparallel_a} and~\eqref{eq:afterparallel_b} are satisfied by setting $b_{ee'}=1$. The completion time  of subtasks $e'$ immediately following  $e$ in the simple path is larger than that of $e$, therefore, constraint~\eqref{eq:after} is satisfied. For each vertex $v$ associated with the edge label of subtask $e'$, we associate it with the arriving time $t_{vr}^- = t_{e}+1$, which satisfies the constraint~\eqref{eq:20}. As for the last subtask in the simple path, there are no constraints regarding the last subtask, thus, $b_{ee'}$ in~\eqref{eq:afterparallel_c} can be 0.
\theendnotes

%%Harvard (name/date)
\bibliographystyle{SageH}
\bibliography{xl_bib}
\end{document}
