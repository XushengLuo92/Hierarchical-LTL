\documentclass[Afour,sageh,times]{sagej}

\usepackage{moreverb,url}
\usepackage{setspace}
\usepackage[colorlinks,bookmarksopen,bookmarksnumbered,citecolor=red,urlcolor=red]{hyperref}

\newcommand\BibTeX{{\rmfamily B\kern-.05em \textsc{i\kern-.025em b}\kern-.08em
     T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\newtheorem{thm}{Theorem}[section]
\newtheorem{cor}[thm]{Corollary}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{asmp}[thm]{Assumption}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{problem}{Problem}
\newtheorem{exmp}{Example}
%\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition}
%\theoremstyle{remark}
\newtheorem{rem}[thm]{Remark}
%\numberwithin{equation}{section}
% MATH -----------------------------------------------------------
\newcounter{listcounter}
\newenvironment{noindlist}
 {\begin{list}{(\alph{listcounter})~~}{\usecounter{listcounter} \labelsep=0em \labelwidth=0em \leftmargin=0em \itemindent=0em}}
 {\end{list}}
\newcounter{mycounter}
%\renewcommand{\themycounter}{\alph{noindlist}}
\newcommand{\norm}[1]{\left\Vert#1\right\Vert}
\newcommand{\abs}[1]{\left\vert#1\right\vert}
\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\Real}{\mathbb R}
\newcommand{\eps}{\varepsilon}
\newcommand{\To}{\longrightarrow}
\newcommand{\BX}{\mathbf{B}(X)}
\newcommand{\A}{\mathcal{A}}
\newcommand\T{\rule{0pt}{2.9ex}}
\newcommand\B{\rule[-1.4ex]{0pt}{0pt}}
\newcommand{\ltl}{ {\it LTL}$_{-\bigcirc}$ }
\renewcommand{\topfraction}{0.98}
\renewcommand{\textfraction}{0.01}
\renewcommand{\floatpagefraction}{0.97}
\newcommand{\clause}[1]{\mathsf{cls}(#1)}
\newcommand{\cp}[2]{\ccalC_{#1}^{#2}}
\newcommand{\lk}[2]{\ell_{#1}^{(#2)}}
\newcommand{\auto}[1]{\ccalA_{\textup{#1}}}
\newcommand{\autop}{\ccalA_{\phi}}
\newcommand{\vertex}[1]{v_{\textup{#1}}}
\newcommand{\ag}[2]{\langle#1,#2\rangle}
\newcommand{\simplies}{\DOTSB\Longrightarrow}
\newcommand{\minus}{\scalebox{0.75}[1.0]{-}}

\usepackage{stmaryrd}
% The following packages can be found on http:\\www.ctan.org
\usepackage{graphicx} % for pdf, bitmapped graphics files
%% \graphicspath{{figures/}}
\usepackage{bbm}
\usepackage{bm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{epstopdf}

\usepackage[noend,ruled,linesnumbered,resetcount]{algorithm2e}
\SetKwComment{Comment}{$\triangleright$\ } {}
\usepackage{multirow}
\usepackage{rotating}
\usepackage{subfigure}
\usepackage{color}
\usepackage{mysymbol}
\usepackage{url}
\usepackage{ltlfonts}
%\usepackage{caption}
%\usepackage[skip=0.5\baselineskip]{caption}
\usepackage{tabularx,ragged2e,booktabs}
\usepackage[normalem]{ulem}
\usepackage[utf8x]{inputenc}
\usepackage{multirow}
\renewcommand{\ttdefault}{pcr} % selects Courier font
\renewcommand{\ap}[3]{\mathcal{\pi}_{{#1},{#2}}^{#3}}
\newcommand{\aap}[4]{\mathcal{\pi}_{{#1},{#2}}^{#3,#4}}
\newcommand{\Qb}{\mathcal{Q}_{B}}
\newcommand{\qb}{q_{{B}}}
\newcommand{\vect}[1]{\boldsymbol{\mathbf{#1}}}
\newcommand{\wf}{\mathcal{W}_{\text{free}}}
\newcommand{\w}{\mathcal{W}}
\newcommand{\te}[1]{\mathcal{#1}_T}
\newcommand{\x}[1]{\vect{x}^{\text{#1}}}
\newcommand{\q}[2]{{q}_{#1}^{\text{#2}}}
\newcommand{\pn}{\ccalQ_P^{\text{near}}}
\newcommand{\RNum}[1]{\uppercase\expandafter{\romannumeral #1\relax}}
\newcommand{\wn}{\mathcal{W}^{N}}
\newcommand{\state}[1]{(\vect{x}^{#1}, q_B^{#1})}
\newcommand{\statex}[1]{\vect{x}^{#1}}
\newcommand{\stateb}[1]{q_B^{#1}}
\newcommand{\pre}{\text{pre}}
\newcommand{\suf}{\text{suf}}
\newcommand{\ball}[1]{B_{n,!#1}}
\newcommand{\llabel}[1]{L(\vect{x}^{#1})}
\newcommand{\node}[1]{V_{n}^{\text{#1}}}
\newcommand{\colorblue}[1]{\textcolor{blue}{#1}}
\newcommand{\colorred}[1]{\textcolor{red}{#1}}
\newcommand{\ba}{\texttt{int}(\mathcal{B}_{\delta(\vect{x}^0)}(\vect{x}^0))}
\newcommand{\baa}{\mathcal{B}_{\delta(\vect{x}^0)}(\vect{x}^0)}
\newcommand*\diff{\mathop{}\mathrm{d}}
\newcommand{\rrts}{pRRT$^* $}
\newcommand{\rrt}{pRRT}
\newcommand{\grrt}{\ccalG^{\text{TL-RRT}}}
\newcommand{\xx}{\overline{\bbx_{i}\bbx_{i}'}}
\newcommand{\domanda}[1]{\subsubsection*{#1}}
\usepackage[hang,flushmargin]{footmisc}
\makeatletter
\newcommand{\algorithmendnote}[2][\footnotesize]{%
  \let\old@algocf@finish\@algocf@finish% Store algorithm finish macro
  \def\@algocf@finish{\old@algocf@finish% Update finish macro to insert "endnote"
    \leavevmode\rlap{\begin{minipage}{\linewidth}
    #1#2
    \end{minipage}}%
  }%
}
\makeatother

\makeatletter
\newcommand{\pushright}[1]{\ifmeasuring@#1\else\omit\hfill$\displaystyle#1$\fi\ignorespaces}
\newcommand{\pushleft}[1]{\ifmeasuring@#1\else\omit$\displaystyle#1$\hfill\fi\ignorespaces}
\makeatother

\makeatletter
  \setbox0\hbox{$\xdef\scriptratio{\strip@pt\dimexpr
    \numexpr(\sf@size*65536)/\f@size sp}$}
\newcommand{\scriptveryshortarrow}[1][3pt]{{%
    \hbox{\rule[\scriptratio\dimexpr\fontdimen22\textfont2-.2pt\relax]
               {\scriptratio\dimexpr#1\relax}{\scriptratio\dimexpr.4pt\relax}}%
   \mkern-4mu\hbox{\let\f@size\sf@size\usefont{U}{lasy}{m}{n}\symbol{41}}}}

\makeatother

\newenvironment{cexmp}
{\addtocounter{exmp}{-1}\begin{exmp}}
  {\end{exmp}}

  \setcounter{secnumdepth}{3}
  % \hypersetup{draft}
  \usepackage{etoolbox}
\makeatletter
\patchcmd\@combinedblfloats{\box\@outputbox}{\unvbox\@outputbox}{}{\errmessage{\noexpand patch failed}}
\makeatother

\usepackage{graphicx,calc}
\newlength\myheight
\newlength\mydepth
\settototalheight\myheight{Xygp}
\settodepth\mydepth{Xygp}
\setlength\fboxsep{0pt}
\newcommand*\inlinegraphics[1]{%
  \settototalheight\myheight{Xygp}%
  \settodepth\mydepth{Xygp}%
  \raisebox{-0.7\mydepth}{\includegraphics[height=\myheight]{#1}}%
}


\begin{document}

\runninghead{Luo and Zavlanos}

\author{Xusheng Luo\affilnum{1} and Michael M. Zavlanos\affilnum{1}}

\affiliation{\affilnum{1} Department of Mechanical Engineering and Materials Science, Duke University, Durham, NC 27708, USA}

\corrauth{Xusheng Luo, Department of Mechanical Engineering and Materials Science, Duke University, Durham, NC 27708, USA}

\email{xusheng.luo@duke.edu}

\title{Temporal Logic Task Allocation and Motion Planning in Multi-Robot Systems}

\begin{abstract}
  In this paper we consider the problem of optimally allocating tasks, expressed as a global Linear Temporal Logic (LTL) specification, to teams of mobile robots. Each robot is capable of one task and each task may require multiple robots. Our goal is to design a set of  paths that are capable of executing the assigned tasks.
  To obtain a scalable solution to this complex assignment problem, we propose an approximate method that first synthesizes a high-level plan  that exploits the structure of a relaxed version of the Nondeterministic Buchi Automaton (NBA) that captures the LTL specification and then convert the plan into executable paths by tackling a sequence of generalized multi-robot path planning instances. Specifically, we first prune the NBA and relax it by removing all negative atomic propositions in the NBA. Then, we decompose the relaxed NBA into simpler sub-NBA. The sequences of edges in these sub-NBA give rise to sequences of subtasks that the robots need to accomplish in order to satisfy the relaxed NBA. We capture these temporal relations between subtasks using partial orders and formulate a Mixed Integer Linear Problem (MILP) to allocate subtasks to robots that are subject to these partial order constraints. Next, after obtaining a high-level plan, we return back to the original NBA so as to satisfy the global LTL task. The relaxation is corrected and the high-level plan is concretized, both of which are achieved by solving a sequence of generalized multi-robot path planning. Finally, we provide theoretic analysis on the correctness of the results and present numerical simulations that show our method can generate plans with lower cost, much faster than existing methods.

   tackle the state-space explosion problem o
\end{abstract}

\keywords{Linear temporal logic, robotics, task allocation, multi-agent path planning}
\maketitle
\section{Introduction}


%% Control synthesis for robots under Linear Temporal Logic (LTL) tasks has received considerable attention recently~\cite{smith2011optimal,chen2012formal,kantaros2015intermittent,vasile2013sampling,kantaros2017sampling,kantaros2018sampling,kantaros2018text,kantaros2018temporal,kantaros2018distributedOpt,wolff2014optimization,shoukry2017linear}. If optimality is not required, then model checking theory~\cite{baier2008principles} can be used to find feasible paths~\cite{smith2011optimal,chen2012formal,kantaros2015intermittent}. On the other hand, if optimality is of interest, optimal control synthesis methods can be used to find optimal robot plans that either draw from sampling-based planning methods in robotics~\cite{vasile2013sampling,kantaros2017sampling,kantaros2018sampling,kantaros2018text,kantaros2018temporal,kantaros2018distributedOpt}, or formulate the LTL planning problem as an optimization problem~\cite{wolff2014optimization,shoukry2017linear} using existing solvers.

{M}{otion} planning traditionally consists of generating robot trajectories that reach a  goal region from a starting point while avoiding obstacles \citep{lavalle2006planning}. More recently, {new planning approaches have been proposed that} can handle a richer class of tasks, than the classical point-to-point navigation, and can capture temporal goals. Such tasks can be, e.g., sequencing or coverage \citep{fainekos2005temporal}, data gathering \citep{guo2017distributed}, intermittent communication \citep{kantaros2018distributed}, or persistent surveillance \citep{leahy2016persistent}, and can be captured using formal languages, such as Linear Temporal Logic (LTL) \citep{baier2008principles},  developed in concurrency theory.  An suvery on formal specification for robotic systems  is available in~\cite{luckcuck2019formal}.


In this paper, we consider a heterogeneous robotic system under a global LTL task that requires robots of different types to visit different locations in space. The specific robot to visit a location is immaterial as long as it is a robot of the desired type. Consider the emergency response as a motivating example. Such LTL can specify tasks like: {\it two robots of type 1 visits region $A$ to assist in evacuating the injured, before that, 3 robot of type 2 must reach the region $B$ to repair the road for mass evacuation. Furthermore,  no more than 2 robots  can be present at region $B$ at the same time in order to protect the roadbase.} In this task, several robots are required to work cooperatively, present simultaneously at the same place. Several aspects contribute to the complexity of this problem. First, all tasks for robots are interwined in the global specification that does not assign tasks explicitly to individual robots. Hence, the global specification needs to be decomposed into multiple tasks. Second, there may be many ways to alloate these smaller tasks to different robots with certain capabilities. Third, there can be complex temporal constraints between smaller tasks, including precedence and simultaneous relations. Finally, the solution should scale well with respect to the size of robots and environment.

We refer to this problem as the Multi-Robot Task Allocation under temporal logic tasks, in short, LTL-MRTA. A popular  control synthesis metods, for example~\cite{guo2015multi}, for temporal logic specficiations builds a product of the automaton, graphical representation of the specification, and the team model, which itself is a product of indivual robot model. This method will encoutner the notorious state-space explosion as the size of robot team grows. To mitigate the computational burden, we leverage techniques from formal method, multi-robot task allocation and multi-robot path planning to propose a new MILP formulation, so that state-of-the-art solvers are available to solve this optimization formulation efficiently.

Specifically, our approach adopts a hierarchical framework. The high level works on the task allocation and plan generation. We extract subtasks from the Nondeterministic Buchi Automaton (NBA) by identify transitions that make progress towards the task completion,  then we infer a partial orde relation capturing the temporal constraints imposed by the LTL, and next we propose a MILP formulation inspired by the vehicle routing problem to allocate subtasks to robots while respecting the temporal order  between subtasks. The solution to the MILP can generate a high-level plan for each robot which is a sequence of critical  waypoints that the robot needs to visit along the timeline. To reduce the number of subtasks, we prune the NBA and deal with a sub-NBA at one time.  To leverage the power of MILP, in the high level, we temporally ignore such constraints in the LTL that put limit on the number of robots in order to achieve linear ocnstraints. Therefore, we also refer to this step as the {\it relaxation} stage. The low level seeks to concretize the high-level plan into executable paths while taking into account the ignored constraints in the high-level. So we refer to this step as the {\it correction} stage. To achieve this, we generate a sequence of generalized multi-robot path planning (GMRPP) problems where each instance of GMRPP deals with one subtask. The concatenation of paths satisfy the LTL specfication.

\paragraph{Contribution:} The contribution of our work can be summarized as follows: (1) We decompose the global specificaition into multiple subtasks  and infer a partial order  to capture their relations.  (2) We propose a hierarchical framework where the high level allocates sbutasks to robots and obtain a high-level plan for each robot which guides the low-level path generation. (3) We provide the theorectical analysis to demonstrate the correctness and completeness of our method. (4) We conduct extensive simulations to show the effcacy and scalablility of our method.

\subsection{Related work}
High-level specification over a multi-robot sytem can be provided in different forms. In~\cite{guo2015multi,tumova2016multi} local specifications are pre-defined for each robot, and each local specification  can involve other robots to request for assistance. In most works, e.g., \cite{loizou2004automatic,smith2011optimal,saha2014automated,kantaros2015intermittent,kantaros2017sampling,kantaros2018sampling,kantaros2018text,kantaros2018temporal,kantaros2018distributedOpt,xluo_CDC19,luo2019abstraction}, global specifications that capture the collective behavior of all robots are given, which explicitly assign tasks to individual robots. Furthermore, global specifications that do not explictly assign tasks are considered in~\cite{kloetzer2011multi,shoukry2017linear,moarref2017decentralized,lacerda2019petri}, as in our work, where methods are designed to  determine which robots to participate in the task.

Multi-robot task allocation  problems  have been long studied in the robotics literature~\citep{korsah2013comprehensive,nunes2017taxonomy,gini2017multi}. A popular approach to solve these problems is using market-based methods which center on the concept of auctions~\cite{zavlanos2007distributed,zavlanos2008distributed,zavlanos2008dynamic,michael2008distributed}. Another line of work, e.g.,~\cite{gombolay2013fast,jones2011time} leverages the optimization-based method, such as Mixed Integer Linear Programming (MILP) formulations and genetic algorithms  due to the similarity of the MRTA problem with multiple traveling salesman problem. The common setting in this field is that the set of tasks are pre-defined, which is not the case when tasks are captured by high-level specifications.

Decomposing global temporal logic specifications can lead to computationally efficient algorithms.~\cite{tumova2015decomposition,kantaros2016distributed} seek to decompose a global specification directly into local specfications and assign them to individual robots.~\cite{camacho2017non,xluo_CDC19,camacho2019ltl,schillinger2019hierarchical} decompose a global specification into multiple subtasks by exploiting the structure of the finite automata. Particularly,~\cite{camacho2017non} converts temporal planning problems to standard planning problems by defining actions based on the transitions in the NBA.~\cite{xluo_CDC19} identifies transitions in a NBA as subtasks and store synthesized plans for subtasks in a library so that they can be reused to synthesize plans fast for new LTL formulas.~\cite{camacho2019ltl} converts formal languages to reward machines that capture the structure of the task to be used for reinforcement learning.~\cite{schillinger2019hierarchical} associate each transition in the automaton with a subtask and uses the reinforcement learning to execute subtasks under uncertainty. In this work, we follow along this line to recognize each transition in the NBA as a subtask. What differs us from the rest is that we provide the notion of equivalent subtasks which leads to inferring termporal orders between subtasks.

In what follows, to the best of our knowledge, we present the most relevant temporal logic task allocation methods. As in our work, most works do not explicitly assign tasks to individual robots.~\cite{karaman2011linear} combines the vechicle routing problem with metric temporal logci specification and leverage the mixed integer linear programming to solve it. however, they  deal with finite horizon tasks and do not take the low-level executable paths into account. In this sense, they only address the high-level plan generation in our work.~\cite{chen2011formal,leahy2015distributed} decompose a global automaton to assign an automaton to each robot and then  build a synchronous product of automata to synthesize parallel plans. However, the size of synchronous product grwos exponentially with respect to the number of robots. Also, the requirement on parallel plans limits its applicability to cooperative tasks since a large number of tasks lack the parallel executions. Furthermore, when a request is made to robots of certain type, all robots of this type  are required to participate, whereas here we can allow only a part of robots to responde.~\cite{ulusoy2013optimality} continue along this line but
the global specification assigns tasks to individual robots. \cite{lacerda2019petri,kloetzer2020path} leverage the Petri net to model the team of homogeneous robots, whereas we consider heterogeneous robots.~\cite{lacerda2019petri} tackle the job allocation under safe temporal logic specification, but they do not consider ``eventually'' operator so the liveliness property that something good will happen in future can not be addressed. Additionally, they only solve the robot coordination at the task level without considering execution. \cite{kloetzer2020path}  select multiple shortest accepting run in the NBA and for each accepting run, find whether an executable plan exists. It remains questionable whether the Petri net can handle heterogeneous robots. \cite{schillinger2018decomposition,schillinger2018simultaneous,faruq2018simultaneous} automatically decompose the automaton representation of the LTL formulas into independent subtasks that can be fulfilled by different robots. However, they only cosider LTL formulas that can be satified by finite trajectories of robots, which limits the applicability the proposed method to tasks such as recurrent sequencing and persistent monitoring. The major drawback of this line of works is that they can not address cooperative tasks that require the collaboration of multiple robots, and subtasks that are subject to precedence relations can only be executed by a single robot. Common in the above work is that they do not consider cooperative tasks where robots of the same or different types meet somewhere at the same time to complete one task, which gives rise to strong synchronization between robots.

To handle cooperative tasks,~\cite{moarref2017decentralized} design specifications that capture the behaviors of robotic swarms on the swarm and individual levels, but they can not impose restrictions on  the number of robots that should be present at one place at the same time or put limit on the number of present robots.~\cite{sahin2017provably,sahin2017synchronous,sahin2019multirobot} employ the counting linear temporal logic (cLTL+/cLTL) to capture constraints on the number of robots that must be present at different regions. They  propose  an Integer Linear Programming (ILP) formulation inspired by Bounded Model Checking techniques~\citep{biere2006linear}. However, these methods only focus on feasibility of the resulting paths. Furthermore, cLTL+/cLTL cannot specify such tasks where two different regions need to be visited by the same set of robots sequentially, as demonstrated in Section~\ref{sec:sim}. To capture the time duration of take completion, \cite{JoLeVaSaSeTrBe-ISRR-2019} extend this to specification with precise timing requirement, the size of environment has a large effect on the computation time. To mitigate the size of the environment on the scalablility of the proposed method,~\cite{sahin2019multi} resort to a hierarchical framework that first abstracts the environment by aggregating states with the same observations. As shown in Section~\ref{sec:sim}, our proposed method still scale better than the method in \cite{sahin2019multi}.

The rest of the paper is organized as follows. %% %% In Section~\ref{sec:prel}, we provide a brief onverview of LTL and then,
In Section~\ref{sec:preliminaries} and~\ref{sec:problem} we present preliminaries and the problem formulation, respectively. We describe the high-level part in  Section~\ref{sec:app} and \ref{sec:solution}, where we process the NBA, identify subtasks from the NBA and infer temporal orders between them in Section~\ref{sec:app} and formualte the MILP to obtain the high-level plan in Section~\ref{sec:solution}, respectively. In Section~\ref{sec:solution2mrta} we study the low-level part to obtain the executable paths that satisfies the specification.  Furthermore, we examine their correctness and completenss  in Section~\ref{sec:correctness}. Simulation results and extension remarks are presented in Sections~\ref{sec:sim} and~\ref{sec:extension}, respectively.


\section{Preliminaries}\label{sec:preliminaries}
\subsection{Linear temporal logic}\label{sec:ltl}
%% In this part, we describe Linear Temporal Logic (LTL) by presenting its syntax and semantics. Also, we briefly review preliminaries of automata-based LTL model checking.
Linear temporal logic~\cite{baier2008principles} is composed of a set of atomic propositions $\mathcal{AP}$, the boolean operators, conjunction $\wedge$ and negation $\neg$, and temporal operators, next $\bigcirc$ and until $\mathcal{U}$. LTL formulas over $\mathcal{AP}$ follow the grammar $\phi:=\top~|~\pi~|~\phi_1\wedge\phi_2~|~\phi_1\vee\phi_2~|~\neg\phi~|~\bigcirc\phi~|~\phi_1~\mathcal{U}~\phi_2$, where $\top$ is unconditionally true.   Other temporal operators, e.g., \textit{eventually} $\lozenge$, \textit{always} $\square$, can be derived from $\mathcal{U}$, where $\Diamond \phi = \top \mathcal{U} \phi$ means $\phi$ will be satisfied sometime in the future, and $\square \phi = \neg \Diamond \neg \phi$ means $\phi$ is always satisfied from now on. %% In this paper, we restrict our attention to LTL that excludes the ``next'' temporal operator, denoted by LTL$_{-X}$ in \cite{kloetzer2008fully}, since the property of asymptotic optimality requires the path generated by the planning algorithm to completely coincide with the optimal path, whereas the ``next'' operator violates the continuity of the underlying path.

An infinite \textit{word} $w$ over the alphabet $2^{\mathcal{AP}}$ is defined as an infinite sequence  $w=\sigma_0\sigma_1\ldots\in (2^{\mathcal{AP}})^{\omega}$, where $\omega$ denotes an infinite repetition and $\sigma_k\in2^{\mathcal{AP}}$, $\forall k\in\mathbb{N}$. The language $\texttt{Words}(\phi)=\left\{w|w\models\phi\right\}$ is defined as the set of words that satisfy the LTL formula $\phi$, where $\models\subseteq (2^{\mathcal{AP}})^{\omega}\times\phi$ is the satisfaction relation. An LTL $\phi$ can be translated into a NBA  defined as follows \citep{vardi1986automata}:
\begin{defn}[(NBA)]\label{def:nba}
  A \textit{Nondeterministic B$\ddot{\text{u}}$chi Automaton} $B$ is defined as a tuple $B=\left(\ccalQ_{B}, \ccalQ_{B}^0,\Sigma,\rightarrow_B,\mathcal{Q}_B^F\right)$, where $\ccalQ_{B}$ is the set of states; $\ccalQ_{B}^0\subseteq\ccalQ_{B}$ is a set of initial states; $\Sigma=2^{\mathcal{AP}}$ is an alphabet;  $\rightarrow_{B}\subseteq\ccalQ_{B}\times \Sigma\times\ccalQ_{B}$ is the transition relation;
%% For a transition $(q_B,\pi,q'_B)\in\rightarrow_{B}$, $\pi\in \Sigma$ is called a state label if $q_B=q'_B$, otherwise a transition label;
and $\ccalQ_B^F\subseteq\ccalQ_{B}$ is a set of accepting states.
\end{defn}

An \textit{infinite run} $\rho_B$ of $B$ over an infinite word $w=\sigma_0\sigma_1\sigma_2\dots$, $\sigma_k\in\Sigma$, $\forall k\in\mathbb{N}$, is a sequence $\rho_B=q_B^0q_B^1q_B^2\dots$ such that $q_B^0\in\ccalQ_B^0$ and $(q_B^{k},\sigma_k,q_B^{k+1})\in\rightarrow_{B}$, $\forall k\in\mathbb{N}$.
%% , where we call $\pi_k$ a \textit{state label} if $q_B^k=q_B^{k+1}$, otherwise a \textit{transition label} if $q_B^k \not= q_B^{k+1}$.
An infinite run $\rho_B$ is called \textit{accepting} if $\texttt{Inf}(\rho_B)\cap\ccalQ_B^F\neq\varnothing$, where $\texttt{Inf}(\rho_B)$ represents the set of states that appear in $\rho_B$ infinitely often. An accepting run can be written in the prefix-suffix structure such that the prefix part (connecting an initial state to an  accepting state) is traversed only once and the suffix part, which is a cycle around the accepting state, is traversed infinitely often.
The words $\sigma$ that produce an accepting run of $B$ constitute the accepted language of $B$, denoted by $\ccalL_B$. Then~\cite{baier2008principles} proves that the accepted language of $B$ is equivalent to the words of $\phi$, i.e., $\ccalL_B=\texttt{Words}(\phi)$.

\subsection{Partial orders}\label{sec:partial}
A finite partially ordered set or poset $P = (X, <_P )$  is a pair consisting of a finite base set $X$ and a binary relation $<_P \subseteq X \times X$ that is reflexive, antisymmetric, and transitive. Let  $x, y \in X$ be two distinct elements, we write $x <_P y$ if $(x,y) \in <_P$, while $x$ and $y$ are incomparable, written $x \|_P y$. Moreover, $x$ is covered by $y$ or $y$ covers $x$, denoted by $x \prec_P y$, if $x<_P  y$ and there is no $z \in X$ such that $x  <_P  z <_P y$. Anantichain is a subset of a poset such that any two distinct elements in this subset are incomparable. The width of a poset is the cardinality of a maximum antichain. %% Similarly, the height of a poset is defined as the maximum cardinality of a chain.

A linear order $L_X=(X, <_L)$ is a poset such that $x <_L y$, $x = y$ or $y <_L x$ holds for any pair of  $x, y \in X$. A linear extension  $L_P = (X, <_L)$ of a poset $P$ is a linear order such that $x <_L y$ if $x <_P y$. That is, a linear order that preserves the partial order. A poset can be seen as a generative model for its linear extensions.
We define $\ccalL_P$ as the set of all linear extensions of $P$. Note that a poset and its linear extensions share the same base set. Given a collection of linear orders $\Xi$, the poset cover problem focuses on reconstructing a single poset $P$ or a set of posets $P = \{P_1,\ldots,,P_k\}$ such that $L_P = \Xi$ or $\cup_{i\in[k]}L_{P_i} = \Xi$. As shown in~\cite{heath2013poset} the poset cover problem is NP-complete. Furthermore, the partial cover problem focuses on finding a poset $P$ such that $\ccalL_P$ contains the maximal number of linear orders in $\Xi$, i.e., $\ccalL_P \subseteq \Xi$ and   $\nexists P'$ s.t. $\ccalL_{P'} \subseteq \Xi$ and $|\ccalL_{P'}| > |\ccalL_{P}|$.~\cite{heath2013poset} shows that the partial cover problem can be solved in polynomial time.



\section{Problem Formulation and Outline}\label{sec:problem}
\subsection{Transition system}\label{sec:ts}
 Consider a discrete environment filled with regions and obtacles, where each region or obstacles can span multiple free cells in the environment. We define $l\in \mathbb{N}^+$ disjoint or partially overlapping labeled regions of interest in free space and denote by $\mathcal{L}=\{\ell_k\}_{k=1}^{l}$ the set that collects these labeled regions. Furthermore, we represented the environment by a graph $E = (S, \to_E)$ where $S$ is the finite set of vertices corresponding to free cells and $\to_{E} \subseteq S \times S$ captures the adjacency relation.

 We consider a team of heterogeneous robots with different capabilities that work in the environment. Given a collection of $n$ robots belonging to $m$ types, we assume that every robot belongs to exactly one type. Moreover, let $\mathcal{K}_j, j\in[m]$ where $[m]$ is the shorthand notation for  $\{1,\ldots,m\}$, denote the set that  collects all robots of type $j$, so that $\sum_{j\in [m]} |\ccalK_j| = n$ and $\ccalK_{j} \cap \ccalK_{j'} = \emptyset$ if $j \not= j'$, where $|\cdot|$ is the cardinality of a set. Finally, we define $[r,j]$ to represent robot $r$ of type $j$, where $r\in \ccalK_j, j\in [m]$. To capture the mobility of robot $[r,j]$ in the environment, we define the { transition system} as follows:

\begin{defn}[(TS)]\label{def:ts}
  A { Transition System} for robot $[r,j]$, denoted by TS$_{r,j}$, is a tuple TS$_{r,j} = \{S, s_{r,j}^0, \to, \Pi_{r,j}, L_{r,j}\}$ where: (a) $S$ is the set of locations of robot $[r,j]$, and we denote by $s_{r,j}^t \in S$ its location at time $t$; (b) $s_{r,j}^0$ is the initial location; (c) $\to \subseteq \to_{E} \cup_{s\in S} \{(s,s)\} $ is the transition relation, that is, the robot can be allowed to remain idle or transition between adjacent cells; (d) $\Pi_{r,j} = \cup_{k\in [l]}\{p_{r,j}^k\} \cup \{\epsilon\}$ where the atomic proposition $p_{r,j}^{k}$ is true if robot $[r,j]$ is at labeled region $\ell_k$, and $\epsilon$ means empty label; (e) and $L_{r,j}: S \to 2^{\Pi_{r,j}} $ is the labeling function that returns the set of atomic propositions that are satisfied at location $s_{r,j}^t$.
\end{defn}

Given the definition of a TS, we define the {product transition system}, which captures all possible combinations of robot behaviors captured by their respective TS$_{[r,j]}$, as follows:
\begin{defn}[(PTS)]\label{def:pts}
  Given $n$ transition systems TS$_{r,j} = \{S, s_{r,j}^0, \to, \Pi_{r,j}, L_{r,j}\}$, the product transition system $\text{PTS}$ is a tuple $\text{PTS} = (S^n, s^0, \to, \Pi, L)$ where (a) $S^n = S\times \cdots \times S$ is the finite set of collective locations. We let $s^t = (s_{1,1}^t, \ldots, s_{|\ccalK_1|,1}^t, \ldots, s_{1,m}^t, \ldots, s_{|\ccalK_m|, m}^t) \in S^n$ collect all robot locations at time $t$%% , which requires that no more than one robots occupy the same free cell
  ; (b) $s^0$ is the initial locations of robots; (c) $\to \subseteq S^n \times S^n$ is the transition relation in which each robot follows its individual transition relation, i.e., $(s^t, s^{t+1}) \in \to$ if $s^t_{r,j}\rightarrow_{r,j} s^{t+1}_{r,j}$ for all $r\in \ccalK_j, \forall \,j \in [m]$;
  %% Specifically, $(s^t, s^{t+1}) \in \to$ if $s^t_{r,j}\rightarrow_{r,j} s^{t+1}_{r,j}$ for all $r\in \ccalK_j, \forall \,j \in [m]$ and there do not exist any two robots $[r,j]$ and $[r',j']$ such that $s^{t+1}_{r,j} = s^{t}_{r',j'}$ and $s^{t+1}_{r',j'} = s^{t}_{r,j}$. In words, each robot follows its transition relation and no two robots switch their locations;
  (d) $\Pi = \cup_{i\in[|\ccalK_j|], j\in [m], k\in [l]}\{\pi_{i,j}^k\} \cup \{\epsilon\}$, where the atomic proposition $\ap{i}{j}{k}$ is true if at least $i$ robots of type $j$, denoted by $\ag{i}{j}$, are at labeled region $\ell_k$ at time $t$, i.e., $\ap{i}{j}{k} \Leftrightarrow |\{r\in \ccalK_j: L_{r,j}(s_{r,j}^t) = p_{r,j}^k \}| \geq i$, where $|\cdot|$ is the cardinality of a set; (e) and $L: S^n \to 2^{\Pi}$ is the labeling function that returns the set of atomic propositions satisfied by all robots at time $t$.
\end{defn}
\subsection{Task specification}
In this paper, we consider MRTA problems where the tasks are globally described by  a fragment of LTL formulas called \ltl that excludes the operator ``next''. Since formulas such as  $\bigcirc \ap{i}{j}{k}$ enforces $\ap{i}{j}{k}$ to be true at the next immediate step, which equivalently requires $\langle i,j \rangle$ to stay next to or at region $\ell_k$ at the current step. This requirement  is time-critical and can be easily violated if robots are allowed to stutter~\citep{sahin2019multirobot}. Moreover, we consider tasks where the same group of robots of certain types  need to visit different regions in sequence, e.g., to deliver objects between those locations. To capture such tasks, we  define {\it induced} atomic propositions over $\Pi$ (see Definition~\ref{def:pts})  as follows.


\begin{defn}[(Induced atomic propositions)]
   For each atomic proposition $\ap{i}{j}{k} \in \Pi$, we associate an infinite set of  {induced} atomic propositions $\{\ap{i}{j}{k,\chi}\}_{\chi\in \mathbb{N}}$, where $\chi$ is a {\it connector} that binds the truth of  atomic propositions with the same $i$ and $j$. Specifically, when $\chi=0$, $\ap{i}{j}{k,\chi}$ is reduced to $\ap{i}{j}{k}$, whose truth is state-dependent. On the other hand, if $\chi \neq 0$, the truth of $\ap{i}{j}{k,\chi}$ is state-and-path-dependent, and it additionally depends on other induced atomic propositions that share the same $i,j$ and $\chi$. That is, both $\ap{i}{j}{k,\chi}$ and $\ap{i'}{j'}{k',\chi'}$, with $\chi\not=0$, are true if the same group of $i$ robots of type $j$ visit regions $\ell_k$ and $\ell_{k'}$. Furthermore, the truth of the negative atomic proposition  $\neg \ap{i}{j}{k,\chi}$ is equivalent to its basic counterpart $\neg \ap{i}{j}{k}$, irrespective of  $\chi$. That is, less than $\ag{i}{j}$ are at location $\ell_k$.
\end{defn}
We collect all basic and induced atomic propositions in the set $\Sigma$.  For the rest of this work, we omit the superscript $\chi$ when $\chi=0$.
\begin{defn}[(Implication between atomic propositions)]\label{defn:literalimplication}
  Given two positive atomic propositions $\ap{i}{j}{k,\chi}$ and $\ap{i'}{j'}{k',\chi'}$, we say that $\ap{i}{j}{k,\chi}$ implies $\ap{i'}{j'}{k',\chi'}$, i.e., the satisfaction of $\ap{i}{j}{k,\chi}$ leads to the satisfaction of $\ap{i'}{j'}{k',\chi'}$,
  %% denoted by $\ap{i}{j}{k,\chi} \simplies \ap{i'}{j'}{k',\chi'}$,
  if they are identical or $i\geq i', j= j', k=k'$ and $\chi'=0$,  since if $\ag{i}{j}$ are at region $\ell_k$, then $\ag{i'}{j}$ are at region $\ell_k$.   Similarly, negative atomic proposition $\neg \ap{i}{j}{k}$ implies $\neg \ap{i'}{j'}{k'}$ if they are identical or $i\leq i', j= j', k=k'$.
\end{defn}

 Next, we define the notion of {\it valid} temporal logic tasks.
 \begin{defn}[(Valid temporal logic task)]\label{defn:valid}
A temporal logic task specified by a\ltl formula is valid if atomic propositions with the same non-zero connector $\chi$ involves the same number of robots of the same robot type.
 \end{defn}

 \begin{figure}[!t]
    \centering
    \includegraphics[width=0.7\linewidth]{gridworld.pdf}
    \caption{Illustration of the environment and initial robot configurations for the emergencey response tasks.}\label{fig:workspace}
\end{figure}
\begin{exmp}[(Emergencey response)]\label{exmp:1}
  Consider an emergencey response scenario (see Fig.~\ref{fig:workspace}) where 3 robots of type 1 (indicated by \inlinegraphics{star.pdf}) and 2 robots of type 2 (indicated by \inlinegraphics{bluedot.pdf}) are located at region $\ell_1$, $\ell_2$ is an office building where personnel got injured, $\ell_4$ is the damaged road that leads to the open area $\ell_3$. We consider the following two rescue tasks: {\it (i)} \label{task:i} 2 robots of type 1 visit building $\ell_2$ to transport injured personnel to safe open area, and 1 robot of type 2 should visit $\ell_4$ to clear the road before robots of type 1 reach the safe area. {\it (ii)} \label{task:ii} 1 robot of type 1 travel between the building $\ell_2$ and the open area $\ell_3$ back and forth to transport valuable equipments. The considered tasks is complex compared to the conventional task allocation  in the sense that temporal terms exist like ``before'' and ``back and forth''.
\end{exmp}


 \begin{cexmp} [(Valid and invalid formulas)]
Observe that in Fig.~\ref{fig:workspace}, the satisfied atomic propsitions in $\Sigma$ are $\ap{3}{1}{1}$ and $\ap{2}{2}{1}$.   The valid formulas to specify the tasks \hyperref[task:i]{\it (i)} and \hyperref[task:ii]{\it (ii)} are: $\Diamond \Large((\ap{2}{1}{2,1}\wedge \neg \ap{2}{1}{3}) \wedge  \Diamond \ap{2}{1}{3,1}\Large)  \wedge \Diamond \ap{1}{2}{4} \wedge \neg \ap{2}{1}{3} \,\mathcal{U}\, \ap{1}{2}{4}$ and $\square \Diamond (\ap{1}{1}{2,1} \wedge \Diamond \ap{1}{1}{3,1})$, respectively. However, formulas $\Diamond (\ap{1}{1}{2,1} \wedge \Diamond \ap{2}{1}{3,1})$ and $\Diamond (\ap{2}{2}{2,1} \wedge \Diamond \ap{2}{1}{3,1})$ are two invalid formulas due to different number of robots and robot types, respectively.
 \end{cexmp}

 A $h$-length path $\tau = s^0 \ldots s^h$ that captures the collective behavior of the team is such that $s^{t-1}\to s^{t}, \forall t\in[h]$%% , which is {\it collision-free} since all robots do not collide with obstacles or each other according to Definition~\ref{def:ts}
 .  Given a valid\ltl formula $\phi$, a  path $\tau$ that satisfies $\phi$ can be written in a prefix-suffix structure $\tau=\tau^{\text{pre}}[\tau^{\text{suf}}]^\omega$, where the prefix part  $\tau^{\text{pre}}=s^0 \dots s^{h_1}$ is executed once followed by the indefinite execution of the suffix part $\tau^{\text{suf}}=s^{h_1} \dots s^{h_1+h_2} s^{h_1+h_2+1}$, where $s^{h_1+h_2+1}=s^{h_1}$ \citep{baier2008principles}. We say a path $\tau$ satisfies $\phi$ if {\it (i)} the trace, defined as $\texttt{trace}(\tau):=L(s^0)\dots L(s^{h_1})[L(s^{h_1})\dots L(s^{h_1+h_2+1})]^{\omega}$  belongs to $\texttt{Words}(\phi_0)$, where $\phi_0$ is obtained by replacing all induced atomic propositions in $\phi$ with their counterparts with zero connector; {\it (ii)} it is the same $\ag{i}{j}$ that satisfy the induced atomic proposition $\ap{i}{j}{k,\chi}$ in $\phi$ with the same non-zero connector $\chi$. Not only do the satisfaction conditions take into account the collective labeling of the paths, as in {\it (i)}, but differentiate exactly which robots participate, as in {\it (ii)}. When there is no atomic proposition in $\phi$ with non-zero connector, the satisfaction condition only considers {\it (i)}, which is identical to the conventional case in Section~\ref{sec:ltl}. Now, let $\tau_{r,j} = s_{r,j}^0, s_{r,j}^1, \ldots, s_{r,j}^h$ denote a $h$-length path  for robot $[r,j]$. We define the cost of $\tau_{r,j}$  as $J(\tau_{r,j}) = \sum_{t=0}^{h-1} d(s_{r,j}^{t}, s_{r,j}^{t+1})$, where $d: S\times S \to \mathbb{R}^+\cup\{0\}$ maps a pair of free cells to the distance between them. Therefore, the cost of the path $\tau$ that combines all robot paths $\tau_{r,j}$ of length $h$ can be defined as
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}
  J(\tau) = \sum_{{r \in \ccalK_j, j \in [m]}} J(\tau_{r,j}),
\end{align}
\endgroup
For  plans written in prefix-suffix form, we get
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}\label{eq:cost}
J(\tau) = \beta J(\tau^{\text{pre}}) + (1-\beta) J(\tau^{\text{suf}}),
\end{align}
\endgroup
where $\beta\in [0,1]$ is a user-specified parameter.

\subsection{NBA}\label{sec:nba}
Given $n$ transition systems of robots and a \ltl formula $\phi$, to find a (sub-)optimal satisfying path, we operate on the corresponding NBA $\autop = (\ccalV, \ccalE)$, which can  be constructed using the tools, such as LTL2BA developed in~\cite{gastin2001fast}; see also Fig.~\ref{fig:nba_iii} for tasks~\hyperref[task:i]{\it (i)} and~\hyperref[task:ii]{\it (ii)}. Note that the NBA in Definition~\ref{def:nba} is essentially a graph. For the rest of the work, we refer to the NBA by the graph $\autop$ for notational convenience. In what follows, we process the NBA $\autop$ to obtain an ``equivalent'' NBA in the sense that we do not lose any feasible path that satisfies the specification $\phi$, which prepares us for imposing restrictions on the NBA we cope with in the formal problem definition in Section~\ref{sec:formulation}. Before that, we introduce some necessary notations.

For a transition $(q_B, \gamma, q'_B)\to_B$ in the NBA $\autop$, we assume that the propositional formula $\gamma$ is  in {\it disjunctive normal form} (DNF), i.e,
$ \gamma = \bigvee_{p\in \ccalP} \bigwedge_{q\in \ccalQ_p} (\neg)\ap{i}{j}{k,\chi}$, where the negation operator can only precede the atomic propositions. Note that any propositional formula has an equivalent formula in DNF~\citep{baier2008principles}. We call  $\ccalC_p^{\gamma}=\bigwedge_{q\in \ccalQ_p}(\neg) \ap{i}{j}{k,\chi}$ the $p$-th {\it clause} of $\gamma$ that includes a set $\ccalQ_p$ of positive and negative {\it literals} and each positive literal is an atomic proposition $\ap{i}{j}{k,\chi}\in \Sigma$. Let $\mathsf{cls}(\gamma)$ denote the set of clauses $\ccalC_p^{\gamma}$ in $\gamma$, and let $\mathsf{lits}^+(\ccalC_p^{\gamma})$ and $\mathsf{lits}^-(\ccalC_p^{\gamma})$ be the {\it positive subformula} and {\it negative  subformula}, respectively,  of all positive literals and all negative literals in the clause $\ccalC_p^\gamma$, which, by default, are $\top$ if the corresponding literals do not exist. Furthermore, we call the propositional formula $\gamma$ a {\it vertex label} if $q_B=q'_B$, otherwise, an {\it edge label}. In what follows, we do not consider self-loops when we refer to edges in $\autop$, since self-loops can be captured by vertices.   With a slight abuse of notation, let {$\gamma: \ccalV \to  2^\Sigma $} and {$\gamma: \ccalV \times \ccalV \to 2^\Sigma$} be the functions that map a vertex and edge in the NBA to its vertex label and edge label, respectively. Next, we are ready to process the NBA $\autop$.  In particular, for every vertex label or edge label $\gamma$ in $\autop$:
\paragraph{(1) Mutual exclusion in $\mathsf{lits}^+(\cp{p}{\gamma})$:}\label{prune:exclusion1} We delete the clause $\cp{p}{\gamma} \in \mathsf{cls}(\gamma)$ (replacing it with $\bot$) if there exist two positive literals $\ap{i}{j}{k,\chi}, \ap{i}{j}{k',\chi} \in \mathsf{lits}^+(\cp{p}{\gamma})$ such that $k\not= k'$ and $\chi\not=0$, since the same group of robots cannot be at different regions at the same time.
 \paragraph{(2) Mutual exclusion in $\mathsf{lits}^+(\cp{p}{\gamma})$  and $\mathsf{lits}^-(\cp{p}{\gamma})$:} \label{prune:exclusion2} We delete the clause $\cp{p}{\gamma} \in \mathsf{cls}(\gamma)$ (replacing it with $\bot$) if there exist a positive literal $\ap{i}{j}{k,\chi} \in \mathsf{lits}^+(\cp{p}{\gamma})$ and a negative literal $\neg \ap{i'}{j}{k} \in \mathsf{lits}^-(\cp{p}{\gamma})$ such that $i' \leq i$ since they are mutually  exclusive.
 \paragraph{(3) Absorption in $\mathsf{lits}^+(\cp{p}{\gamma})$:} \label{prune:absorption1} For each clause $\cp{p}{\gamma} \in \clause{\gamma}$, we delete the positive literal $\ap{i'}{j'}{k',\chi'} \in \mathsf{lits}^+(\cp{p}{\gamma})$ (replacing it with $\top$), if another literal $\ap{i}{j}{k,\chi} \in \mathsf{lits}^+(\cp{p}{\gamma})$ exists in the same clause such that $\ap{i}{j}{k,\chi}$ implies $\ap{i'}{j'}{k',\chi'}$; see Definition~\ref{defn:literalimplication}.
 \paragraph{(4) Absorption in $\mathsf{lits}^-(\cp{p}{\gamma})$:} \label{prune:absorption2} Similarly, we delete the negative literal $\neg \ap{i'}{j'}{k'} \in \mathsf{lits}^-(\cp{p}{\gamma})$ (replacing it with $\top$), if another $\neg \ap{i}{j}{k} \in \mathsf{lits}^-(\cp{p}{\gamma})$ exists in the same clause such that $\neg \ap{i}{j}{k}$ implies $\neg \ap{i'}{j'}{k'}$.


       \paragraph{(5) Violation of team size:} \label{prune:violation1}  For each clause $\cp{p}{\gamma} \in \clause{\gamma}$, let $\mathsf{lits}^+(j')$ denote literals in $\mathsf{lits}^+(\cp{p}{\gamma})$ that involve robots of type $j'$, i.e., $\mathsf{lits}^+(j') = \{\ap{i}{j}{k,\chi} \in \mathsf{lits}^+(\ccalC_p^\gamma): j = j'\}$. We delete the clause $\cp{p}{\gamma}$ (replacing it with $\bot$) if the required total number of robots of the same type exceeds the provided number, i.e., if there exists $j\in[m]$ such that $ \sum_{\ap{i}{j}{k,\chi}\in\mathsf{lits}^+(j)}   i > |\ccalK_{j}|$.
       \paragraph{(6) Violation of region size:} \label{prune:violation2} Similarly, for each clause $\cp{p}{\gamma} \in \clause{\gamma}$, let $\mathsf{lits}^+(k)$ denote literals in $\mathsf{lits}^+(\cp{p}{\gamma})$ that involve region $\ell_{k}$. We delete the clause $\cp{p}{\gamma}$ (replacing it with $\bot$) if the required total number of robots  visiting region $\ell_{k}$ exceeds the number of free cells it covers, i.e., if there exists $k\in[l]$ such that $ \sum_{\ap{i}{j}{k,\chi}\in\mathsf{lits}^+(k)}   i > |\ell_k|$.

       It is worthy of noting that these processing steps  merely  remove infeasible clauses and merge redundant literals, which does not compromise any accepting word in $\ccalL(\autop)$ that can be generated by a feasible path. Therefore, with a slight abuse of notation, we continue use $\autop$ to refer to the NBA of specification $\phi$ after processing steps~\hyperref[prune:exclusion1]{\it (1)}-\hyperref[prune:violation2]{\it (6)}.


 \begin{figure}[!t]
   \centering
   \subfigure[NBA for the task {\it (i)}]{
     \label{fig:nba_i}
     \includegraphics[width=0.8\linewidth]{nba_i.pdf}}
   \subfigure[NBA for the task {\it (ii)}]{
     \label{fig:nba_ii}
     \includegraphics[width=0.6\linewidth]{nba_ii.pdf}}
   \caption{NBA for the tasks \hyperref[task:i]{\it (i)} and \hyperref[task:ii]{\it (ii)}.}
   \label{fig:nba_iii}
 \end{figure}

 \begin{cexmp}[(Key observations on the NBA)]
   The pre-processing NBA corresponding to tasks \hyperref[task:i]{\it (i)} and \hyperref[task:i]{\it (ii)} are shown in Fig.~\ref{fig:nba_iii}. The vertex label is placed in the square bracket next to each vertex. After the processing, the NBA $\autop$ for the task~\hyperref[task:i]{\it (i)} does not change whereas some labels in the NBA $\autop$ for the task \hyperref[task:i]{\it (ii)} become $\bot$ due to step~\hyperref[prune:exclusion1]{\it (1)}, which are highlighted in orange.

   In Fig.~\ref{fig:nba_i}, $\vertex{init}$ is the initial vertex and $v_6$ is the accepting vertex. Observe that all vertices have self-loops except the initial vertex $\vertex{init}$. Furthermore, each accepting run contains the initial vertex $\vertex{init}$ and the accepting vertex $v_6$. In every accepting run, the satisfaction of the label of an edge implies the satisfaction of the label, if exists, of its end vertex. For instance, the label $\ap{2}{1}{2,1} \wedge \neg\ap{2}{1}{3}$ of the edge $(v_1, v_2)$ implies the label $\neg\ap{2}{1}{3}$ of vertex $v_2$, and  the label $\neg\ap{2}{1}{3}$ of the edge  $(\vertex{init}, v_1)$ implies the label $\neg\ap{2}{1}{3}$ of  its end vertex $v_1$. This is because once the transition over the edge occurs, the label of its end vertex should be satisfied at the next time instant, otherwise, the progression in the NBA $\autop$ gets stuck.

   The same observation also applies to NBA in Fig.~\ref{fig:nba_ii} where vertex $\vertex{init}$ is both an initial and accepting vertex and $v_3$ is another accepting vertex.  The accepting run $\vertex{init}, v_2, v_3, (v_1, v_2, v_3)^\omega$ includes one pair of initial and accepting vertices, $\vertex{init}$ and  $v_3$, and the accepting run $\vertex{init}, v_2, v_1, \vertex{init}^\omega$ (although infeasible) includes one pair of initial and accepting vertices, $\vertex{init}$ and $\vertex{init}$. Note that we view $\vertex{init}$'s different, one as the intial vertex and the other as the accepting vertex. Furthermore, the label $\ap{1}{1}{3,1}$ of the edge $(v_1, v_2)$  implies the label $\top$ of its end vertex $v_2$, so are the edge $(v_2, \vertex{init})$ and its end vertex $\vertex{init}$ (although infeasible). It is noteworthy that, even though the accepting vertex $v_3$ does not have a self-loop, the satisfaction of the label $\ap{1}{1}{2,1}$ of its incoming edge $(v_2, v_3)$ implies the label $\top$ of its outgoing edge $(v_3, v_1)$. Without this implication, the progression will get stuck at $v_3$ since the label $\ap{1}{1}{2,1} \wedge \ap{1}{1}{3,1}$ of edge $(v_3, \vertex{init})$ is infeasible and it takes more than one time instant between regions $\ell_2$ and $\ell_3$, making the label $\ap{1}{1}{3,1}$ of edge $(v_3, v_2)$ infeasible, as well.
 \end{cexmp}

 Inspired by key observations about the NBA $\autop$ in the Example~\ref{exmp:1}, we first introduce the notion of implication and strong implication between two propositional formulas and based on this, we define the {\it restricted accepting runs} in the NBA $\autop$ that are in the prefix-suffix structure. In the formal problem formulation in Section~\ref{sec:formulation}, we require that the set of restricted accepting runs of a NBA $\autop$ is non-empty.

 \begin{defn}[(Implication and strong implications between propositional formulas)]\label{defn:implication}
   Given two propositional formulas $\gamma$ and $\gamma'$, we say that formula  $\gamma$ implies $\gamma'$, denoted by $\gamma \simplies \gamma'$, if for each clause $\ccalC_{p}^{\gamma} \in \clause{\gamma}$, there exists a clause $\ccalC_{p'}^{\gamma'} \in \clause{\gamma'}$ such that for every literal in $\ccalC_{p'}^{\gamma'}$, there exists a literal in $\ccalC_{p}^{\gamma}$ that implies it (see Definition~\ref{defn:literalimplication}). In this case, $\ccalC_{p}^{\gamma}$ implies $\ccalC_{p'}^{\gamma'}$. Furthermore, formula $\gamma$ strongly implies $\gamma'$, denoted by $\gamma \simplies_s  \gamma'$, if $\gamma$ implies $\gamma'$, and for each clause $\ccalC_{p'}^{\gamma'} \in \clause{\gamma'}$, there exists a clause $\ccalC_{p}^{\gamma} \in \clause{\gamma}$  such that for every literal in $\ccalC_{p'}^{\gamma'}$, there exists a literal in $\ccalC_{p}^{\gamma}$ that implies it.
 \end{defn}

 Intuitively, given two propositional formulas $\gamma$ and $\gamma'$ such that $\gamma \simplies \gamma'$, robot locations that satisfy $\gamma$ lead to the satisfaction of $\gamma'$.

\begin{defn}[(Restricted accepting runs)]\label{defn:run}
  Given a NBA $\autop$ (after processing) that corresponds to a \ltl formula, we define  any accepting run, in the prefix-suffix structure of $v_0, \ldots, \vertex{prior}, \vertex{accept} (\vertex{next}, \ldots, \vertex{prior}', \vertex{accept})^\omega$ (see Fig.~\ref{fig:lasso}), as   the restricted accepting run,   if it  meets the following conditions:
  \begin{noindlist}
    \setlength\itemsep{0em}
  \item \label{cond:a} Even if $v_0 $ and $ \vertex{accept}$ refer to the same vertex, they are viewed as different vertices.  There does not exist a  second  different vertex between any two identical vertices  in the prefix part  $v_0, \ldots, \vertex{prior}, \vertex{accept}$. That is, the prefix part does not return to a vertex after leaving it. Similarly, there does not exist a second different vertex  between any two identical vertices in the suffix part  $\vertex{next}, \ldots, \vertex{prior}', \vertex{accept}$, either. Moreover,  $\vertex{accept}$ appears only once  in the prefix and suffix parts, respectively.
  \item \label{cond:b} There only exist one initial vertex $v_0$ and one  accepting vertex $\vertex{accept}$ in the accepting run (they can appear multiple times in a row), but different accepting runs can have different pairs of initial and accepting vertices;
  \item \label{cond:c} In the prefix part, only initial and accepting vertice, $v_0$ and $\vertex{accept}$, can be allowed to not have  self-loops, that is, their vertex labels  can be $\bot$, and in the suffix part,  only the accepting vertex $\vertex{accept}$ can be allowed to not have a self-loop;
 \item  \label{cond:d} For any two consecutive vertices $v_1$, $v_2$ in the accepting run, if $v_1 \neq v_2$, $v_2\neq \vertex{accept}$ and $v_2$ has a self-loop, then the edge label $\gamma(v_1, v_2)$  strongly implies  the end vertex label $\gamma(v_2)$, i.e., $\gamma(v_1, v_2) \simplies_s \gamma(v_2)$;
   %% \item \label{cond:e} For any three consecutive vertices $v_1, v_2$ and $v_3$ in the accepting run, if $v_2 \neq v_{\vertex{accept}}$ and $v_2$ has a self-loop, then either $v_1 = v_2$ or $v_2 = v_3$, that is, the label of  vertex $v_2$ should be satisfied at least once;
   \item \label{cond:e} In the suffix part, if $\vertex{accept} = \vertex{next}$ (this happens when $\vertex{accept}$ has a self-loop), then the suffix part $\vertex{next}, \ldots, \vertex{prior}', \vertex{accept}$ is reduced to $ \vertex{accept}$, that is, the suffix part only consists of  $\vertex{accept}$. Meanwhile, the label of the edge $(\vertex{prior}, \vertex{accept})$ strongly implies the label of the vertex $\vertex{accept}$, i.e., $\gamma(\vertex{prior}, \vertex{accept}) \simplies_s  \gamma(\vertex{accept})$;
 \item \label{cond:f} In the suffix part, if $\vertex{accept} \neq \vertex{next}$ (this can happen when $\vertex{accept}$  does not have a self-loop), then, the label of the edge $(\vertex{prior}, \vertex{accept})$ implies the label of the edge $(\vertex{accept}, \vertex{next})$, i.e., $\gamma(\vertex{prior}, \vertex{accept}) \simplies  \gamma(\vertex{accept}, \vertex{next})$. Meanwhile, the label $\gamma(\vertex{prior}, \vertex{accept})$ implies the label of the edge $(\vertex{prior}', \vertex{accept})$, i.e., $\gamma(\vertex{prior}, \vertex{accept}) \simplies  \gamma(\vertex{prior}', \vertex{accept})$. Note that $\vertex{prior}$ and $\vertex{prior}'$ can be different.
  \end{noindlist}

  %% (d)\label{cond:d}  If the accepting vertex $\vertex{accept}$ in the accepting run does not have a self-loop, then, the label of the edge $(\vertex{prior}', \vertex{accept})$ where $\vertex{prior}'$ is the vertex right before $\vertex{accept}$ in the prefix part, implies the label of the edge $(\vertex{accept}, \vertex{next})$ where $\vertex{next}$ is a vertex right after $\vertex{accept}$ in the suffix part, i.e., $\gamma(\vertex{prior}', \vertex{accept}) \simplies  \gamma(\vertex{accept}, \vertex{next})$.
  %% the establishment of ``$\simplies$'' also requires that, for any clause of  $\gamma(\vertex{accept}, \vertex{next})$,  all literals with non-zero connectors appearing in this clause appear in a single clause of $\gamma(\vertex{prior}, \vertex{accept})$.   Meanwhile, $\gamma(\vertex{prior}', \vertex{accept})$ also implies the label of vertex $\vertex{next}$, i.e., $\gamma(\vertex{prior}', \vertex{accept}) \simplies  \gamma(\vertex{next})$. At the same time, the label $\gamma(\vertex{prior}', \vertex{accept})$ implies the label of the edge $(\vertex{prior}, \vertex{accept})$ where $\vertex{prior}$ is the vertex right before $\vertex{accept}$ in the suffix part, i.e., $\gamma(\vertex{prior}', \vertex{accept}) \simplies  \gamma(\vertex{prior}, \vertex{accept})$. Note that $\vertex{prior}$ and $\vertex{prior}'$ can be different; see Fig.~\ref{fig:lasso}.
 \end{defn}

\begin{figure}[t]
  \centering
  \includegraphics[width=0.7\linewidth]{lasso.pdf}
  \caption{Graphical depiction of the accepting run in the prefix-suffix structure when $\vertex{accept}$ does not have a self-loop, which resembles a lasso. The shaded blue line and the orange loop represent the prefix and suffix part, respectively. The arrow indicates the progression direction. The gray circles indicate the self-loops.}
  \label{fig:lasso}
\end{figure}

The definition of restricted accepting runs is not restrictive, since these  conditions in Definition~\ref{defn:run} can be met by many accepting runs in the NBA for temporal logic tasks in the robotics application, such as coverage, sequencing, recurrent sequencing and so on.
For condition~\hyperref[cond:a]{\it (a)}, as $v_0$ and $\vertex{accpet}$ mark different advancement towards the satisfaction of the specification, it is reasonable to treat them  differently. The cycle segment is redundant if the run traverses back after leaving it.  In Section~\ref{sec:solution} and~\ref{sec:solution2mrta}, we remove such cases from our solutions.  Furthermore, the prefix and suffix parts end once the accepting vertex $\vertex{accept}$ is reached, as in work~\cite{smith2010optimal}.
      For condition~\hyperref[cond:b]{\it (b)}, the definition of the accepting run in Section~\ref{sec:ltl} is based on a pair of initial and accepting vertices. In Section~\ref{sec:app}, we will extract the sub-NBA from the NBA $\autop$ for each pair of iniital and accepting vertices, reducing the complexity of the sub-NBA.

      For condition~\hyperref[cond:c]{\it (c)}, if a vertex does not have a self-loop, then one of its incoming edge labels  and one of its outgoing edge labels  should be enabled at two consecutive time instants. For instance, observing edges $(v_2, v_3)$ and $(v_3, v_2)$ in Fig.~\ref{fig:nba_ii}, subformula $\ap{1}{1}{3,1}$ should be satisfied right after $\ap{1}{1}{2,1}$, which means a robot  should visit region $\ell_3$ at the next instant while staying at $\ell_2$ right now. These subtasks can be represented by LTL subformula $\Diamond(\ap{1}{1}{2,1} \wedge  \bigcirc \ap{1}{1}{3,1})$. This temporal property is not in align with the semantics of temporal operators like $\ccalU$, $\Diamond$ and $\square$. Based on condition \hyperref[cond:c]{\it (c)}, we will remove some vertices without self-loops from the NBA in Section~\ref{sec:prune}, further reducing its complexity.

      Moreover, conditions \hyperref[cond:d]{\it (d)} and \hyperref[cond:e]{\it (e)} are similar to~\hyperref[cond:c]{\it (c)} in the sense that  the satisfaction of the edge label $\gamma(v_1, v_2)$ should faciliate the satisfaction of the end vertex label $\gamma(v_2)$, since the end vertex label need to be satisfied immediately after the edge label. Furthermore, in Section~\ref{sec:app} and~\ref{sec:solution}, we will first consider a relaxed NBA where all negative literals are ignored, and then re-consider negative literals in Section~\ref{sec:solution2mrta}. The conditions \hyperref[cond:d]{\it (d)} and \hyperref[cond:e]{\it (e)} ensure that the plan obtained by only considering the positive subformulas can be modified to accomadate the ignored negative subformula by preventing the mutual exclusions between positive and negative subformulas.

      Finally, prefix and suffix parts of an accepting run can be addressed separately based on condition~\hyperref[cond:f]{\it (f)}, since  $\gamma(\vertex{prior}, \vertex{accept}) \simplies  \gamma(\vertex{accept}, \vertex{next})$  ensures that in Section~\ref{sec:suf} the final robot locations of the satisfying path for  the prefix part can transition seamlessly to the suffix part of the accepting run. Otherwise, the progression may get stuck since these two edge labels need to be satisfied at two consecutive time instants. Also, since the suffix part of a satisfying path is a loop, robots need to return to the initial locations of the suffix part, which are also  finial locations of the prefix part, after finishing one round of the suffix part. The implication $\gamma(\vertex{prior}, \vertex{accept}) \simplies  \gamma(\vertex{prior}', \vertex{accept})$ indicates that the initial locations of the suffix part enable the transition  $(\vertex{prior}', \vertex{accept})$, which ensures that robots can travel back to initial locations of the suffix part  to make trajectories loops and at the same time, drive the transition in the NBA $\autop$ back to the accepting vertex $\vertex{accept}$ to repeat the suffix part.



%% \end{cexmp}
We highlight that the definition of the restricted  accepting runs only takes into account the structrue of the  NBA and logical implication relations. How the robot paths induce such a restricted accepting run  is beyond the scope of the definition. Next, we make assumptions regarding the robot paths that induce a restricted accepting run.
\begin{asmp}[(Satisfying paths of a restricted accepting run)]\label{asmp:same}
  Given $n$ transition systems and the specification $\phi$, if the robot paths induce a restricted accepting run, then we assume that
  (a)\label{asmp:a} every time the label of a vertex is satisfied, it is always the same clause in this vertex label that is satisfied; (b)\label{asmp:b} the satisfied clause in an edge label implies the satisfied clause in its end vertex label if its end vertex label is satisfied at least once by the paths, and further if the end vertex label is neither $\top$ nor $\bot$, %% %% both the satisfied clause in the label of an edge stronly implies the satisfied clause in its end vertex label and its end vertex is not the accepting vertex,
  the fleet of robots that satisfy the positive subformula of the clause in the end vertex label comes from the fleet of robots that satisfy the positive   subformula of the clause in this edge label;
 (c)\label{asmp:c} robot locations that enable the edges $(\vertex{accept}, \vertex{next})$ and  $(\vertex{prior}', \vertex{accept})$ in the suffix part are identical to robot locations that enable the edge $(\vertex{prior}, \vertex{accept})$ in the prefix part.
\end{asmp}

Assumption~\ref{asmp:same} can be easily met by restricted accepting runs. Specifically, by condition~\hyperref[cond:a]{\it (a)} in the Definition~\ref{defn:run}, each vertex in a restricted accepting run can only be visited within a consecutive time period.  Once locations of a fleet of robots satisfy a  vertex label, they can remain idle to maintain the satisfaction of the same clause in this vertex label, meeting the condition~\hyperref[asmp:a]{\it (a)} in Assumption~\ref{asmp:same}. Furthermore, once locations of a fleet of  robots satisfy an edge label, they can remain idle at the next time instant, leading to the satisfaction of the clause in the end vertex label that the satisfied clause in the edge label implies. Thus, condition~\hyperref[asmp:b]{\it (b)} is  met. As for condition~\hyperref[asmp:c]{\it (c)}, the robot locations that enable the edge $(\vertex{prior}, \vertex{accept})$ in the prefix part is the initial locations of the suffix part. Therefore, condition~~\hyperref[asmp:c]{\it (c)} demands that robots travel along a loop when advancing the infinite number of repetitions of the suffix part.
\subsection{Problem Formulation}\label{sec:formulation}
Finally, based on the restricted accepting runs and Assumption~\ref{asmp:same}, the problem addressed in this paper can be formally defined as follows.

\begin{problem}\label{prob:1}
Considering  a discrete environment with labeled regions and obstacles, a team of $n$ robots of $m$ types with $n$ transition systems, and a valid \ltl specification $\phi$ for which the set of restricted accepting runs is non-empty. Furthermore, assuming a collective path  exists that induces a restricted  accepting run  and meets the Assumption~\ref{asmp:same}, plan a path for each robot such that $\phi$ is satisfied and the sum of the path costs in~\eqref{eq:cost} is minimized.
\end{problem}

We refer to Problem~\ref{prob:1} as multi-robot task allocation under LTL specifications, in short, LTL-MRTA, which is a single-task robot and multi-robot task (ST-MR) problem, where a robot is capable of one task and a task may require multiple robots. Since the ST-MR problem is NP-hard~\citep{korsah2013comprehensive,nunes2017taxonomy}, so is the LTL-MRTA problem. Consequently, an exact method will be impractical for large-scale applications. In what follows, we propose an approximate method to solve LTL-MRTA efficiently.

\begin{rem}
The proposed method in Section~\ref{sec:app} and~\ref{sec:solution2mrta} is not limited to  LTL$_{-\bigcirc}$ formulas. It can also be applied to  formulas that include ``next'' operator but have non-empty restricted set of accepting runs, such as $\Diamond(\ap{1}{1}{2,1} \wedge \bigcirc (\ap{1}{1}{2,1} \,\ccalU\, \ap{1}{2}{2}))$ and $\Diamond (\ap{1}{1}{2}  \wedge \bigcirc \Diamond \ap{1}{2}{2})$.
\end{rem}

\subsection{Outline of the LTL-MRTA Algorithm}
%% { \begin{algorithm}[t]
%%       \caption{Outline of the LTL-MRTA Algorithm}
%%       \LinesNumbered
%%       \label{alg:frame}
%%       \KwIn {workspace $\ccalW$,  robot team $\{\ccalK_j\}$\\ \quad \quad \quad
%%        \ltl formula $\phi$}
%%       Translate $\phi$ into a NBA $B_o$ \label{frame:nba}\Comment*[r]{\ref{sec:prune}}
%%       Prune $B_o$ and do replacing to get $B_r$ \label{frame:prune}\Comment*[r]{\ref{sec:prune}}
%%       Sort pairs of initial and accepting vertices in ascending order by the total length\label{frame:sort} \Comment*[r]{\ref{sec:pregraph}}
%%       \For{each pair in the sorted order}{
%%         \Comment*[r]{Find robot prefix paths}
%%         Extract the sub-NBA $B_s$\ and prune $B_s$ \label{frame:sub-NBA}\Comment*[r]{\ref{sec:pregraph}}
%%         Extract subtasks from $B_s$ and infer the poset with the largest width \label{frame:poset}\Comment*[r]{\ref{sec:poset}}
%%         Build the MILP graph; see also Alg.~\ref{alg:milpgraph} \label{frame:milpgraph}\Comment*[r]{\ref{sec:graph}}
%%         Formulate the MILP and solve it \label{frame:milp} \Comment*[r]{\ref{sec:milp}}
%%         Extract high-level plans  \label{frame:path} \Comment*[r]{\ref{sec:path}}
%%         Identify the accepting run in $B_r$ \label{frame:run} \Comment*[r]{\ref{sec:run}}
%%         Solve generalized  multi-robot path planning to obtain executable paths\label{frame:mapp} \Comment*[r]{\ref{sec:mapp}-\ref{sec:solution2mapp}}
%%         \Comment*[r]{Find robot suffix paths
%%         }
%%         Repeat lines~\ref{frame:sub-NBA}-\ref{frame:mapp} \label{frame:suffix} \Comment*[r]{\ref{sec:suf}}
%%       }
%% Select the plan with the lowest cost according to~\eqref{eq:cost} \label{frame:cost}
%%  \end{algorithm}}
 \begin{figure*}[!t]
   \centering
\includegraphics[width=\linewidth]{overview.pdf}
   \caption{Schematic overview of the proposed method.  The first 5 boxes correspond to the relaxation stage and the last two constitute the correction stage.}
\label{fig:overview}
 \end{figure*}
     {The schematic overview of our proposed  method is shown in Fig.~\ref{fig:overview}, which consists of relaxation and correction stages.  The adoption of this relaxation-and-correction scheme comes from the observation that MILP formulation is a well-studied approach in the literatute of task allocation and  vehicle routing problems and there are also powerful  multi-robot path planning methods in the existing work. To leverage the formulation of MILP, we first ignore the negative literals in the NBA $\autop$ and the collision avoidance among robots. In this way, temporal relations among subtasks can be better exploited  and existing work on vehicle routing problems can inspire scalable techniques to solve the allocation of subtasks; and then the negative literals and collision avoidance is considered in the low-level executable path generation by leveraging the state-of-art multi-robot plath planning techniques.

       Specifically, the first stage is referred to as the {\it relaxation} stage, which produces a high-level plan that abstracts out negative literals appearing in the NBA and low-level collision avoidance among robots; see also the first 5 blocks inside the orange box in~Fig.~\ref{fig:overview}. To this end, we first prune the NBA by deleting infeasible transitions and remove  the negative atomic propositions in the NBA corresponding to the formula $\phi$ so that the satisfaction of the transitions (referred to also as subtasks) in the relaxed NBA requires multi-robots to visit certain regions; see Section~\ref{sec:prune}. Then we extract a sub-NBA, corresponding to a pair of initial and accepting states, from the relaxed NBA that covers at many transitions as possible; see Section~\ref{sec:pregraph}, Next, by associating each transition in the sub-NBA with a subtask, we extract a set of subtasks from the sub-NBA and infer the temporal relation by mining a set of posets; see Section~\ref{sec:poset}. What follow are the construction of the routing graph that captures the regions that robots need to visit to satisfy the subtasks and the temporal order of the visitation; see Sections~\ref{sec:graph}, and the formulation of a MILP based on the vehicle routing problem; see Section~\ref{sec:milp}. In this way, a high-level plan  provides a sequence of regions that each robot needs to visit in order; see Section~\ref{sec:path}. Next, as shown in the last 2 blocks inside the green box in Fig.~\ref{fig:overview}, the {\it correction} stage follows  where the high-level plan is adjusted and concretized to be low-level executable paths by solving a sequence of generalized multi-robot path planning problems that account for the collision avoidance and the satisfaction of the  original specification; see Section~\ref{sec:solution2mrta}.

   \red{On the other hand, similar to~\cite{sahin2019multi}, we adopt a hierarchical approach which first searches for an abstract high-level plan that indicates the sequence of regions that robots should visit in a proper order and then implementing the plan by finding low-level paths between consecutive regions in the plan. However, our work differs from~\cite{sahin2019multi} in the way how the high-level plans  and   executable paths are generated. More significantly,~\cite{sahin2019multi} stops with a feasible plan while we end up with a plan with better quality.}


\section{Extracting Subtasks and Infer the Temporal Order from the NBA}\label{sec:app}
In this section, we conduct the relaxation stage by only considering positive literals in the NBA $\autop$. Our goal is to extract a set of subtasks from the relaxed NBA  and then infer the temporal order, sequential or simultaneous, among these subtasks, which corresponds to blocks 1 and 2 in Fig.~\ref{fig:overview}.
\subsection{{Pruning and relaxation of the NBA}}\label{sec:prune}

We begin with pruning and relaxing the NBA $\autop$. Given a NBA $\autop$, the following initial steps are taken to prune $\autop$ by  removing infeasible transitions. As later we will introduce the notion of subtasks based on edges in the NBA, pruning can reduce the number of subtasks that need to be considered.

Specifically, we delete all edges associated with $\bot$ label, as they cannot be enabled.  We also delete all vertices without self-loops except the initial and accepting vertices, which is justified by condition \hyperref[cond:c]{\it (c)} in Definition~\ref{defn:run}. Furthermore, by condition~\hyperref[cond:d]{\it (d)}, for any vertex other than the accepting vertex, we delete any of its incoming edges if the corresponding edge label does not strongly imply the label of this vertex. Finally, we delete every vertex, except the initial vertex, that cannot be reached by other vertices.
%\end{noindlist}

We denote by $\autop^-$ the resulting NBA.    It is worthy of noting that  this pruning process does not compromise any feasible solutions  to Problem~\ref{prob:1} that induces a restricted accepting run in $\autop$, as shown in Proposition~\ref{prop:prune} in Section~\ref{sec:correctness}. Given the pruned NBA $\autop^-$, we further relax it by replacing each negative literal in vertex or edge labels with $\top$. Let $\auto{relax}$ denote the relaxed NBA. Apparently, when the specification $\phi$ does not involve negative atomic propositions, we have that $\auto{relax} = \autop^-$.  Furthermore, proposition~\ref{prop:inclusion} states that the language accepted by $\autop^-$ is included in the language accepted by $\auto{relax}$, so we do not remove feasible solutions to Problem~\ref{prob:1}, either. In other words, $\auto{relax}$ is an over-approximation of $\autop^-$. This is why the correction stage in Section~\ref{sec:solution2mrta} is reguired to modify the solution obtained from $\auto{relax}$ in order to satisfy $\autop^-$.  Note that $\autop^-$ and $\auto{relax}$  are sub-NBA  of $\autop$ in terms of vertices and edges, thus for components, such as labels, runs in $\autop^-$ and $\auto{relax}$, we can project them onto $\autop$ to obtain the corresponding components. For the rest of the paper, given a notion in any NBA, e.g., $\auto{relax}$,  that is derived from $\autop$, we denote by $(\cdot)_{\phi}$ its counterpart in $\autop$. For instant, for a specific edge label $\gamma$ in $\auto{relax}$, we denote by $\gamma_{\phi}$ the corresponding label in $\autop$ (including the negative literals).

\begin{figure}
  \centering
  \subfigure[$\auto{relax}$ for task {\it (i)}]{
    \includegraphics[width=0.5\linewidth]{nba_i_relax.pdf}\label{fig:nba_i_relax}}
   \subfigure[$\auto{relax}$ for task {\it (ii)}]{
    \includegraphics[width=0.35\linewidth]{nba_ii_prune.pdf}\label{fig:nba_ii_prune}}
   \caption{The relaxed NBA $\auto{relax}$ for tasks~\hyperref[task:i]{\it (i)} and~\hyperref[task:ii]{\it (ii)}.}
   \label{fig:relax}
\end{figure}


\begin{cexmp}[(Pruning and relaxation of the NBA $\autop$)]
   The pruned NBA $\autop^-$ of the NBA  for the task \hyperref[task:i]{\it (i)} is the same as its orignal NBA in Fig.~\ref{fig:nba_i}. The relaxed NBA $\auto{relax}$ is shown in Fig.~\ref{fig:nba_i_relax}. The pruned NBA $\autop^-$ for the task \hyperref[task:ii]{\it (ii)} is the same as the relaxed NBA $\auto{relax}$ which is shown in Fig.~\ref{fig:nba_ii_prune}. Particularly, $\auto{relax}$  is obtained from $\autop$ in Fig.~\ref{fig:nba_ii} by removing edges $(v_1, \vertex{init}), (v_2, \vertex{init}),  (v_3, \vertex{init})$ and replacing $\gamma(\vertex{init})$ with $\bot$.
\end{cexmp}



  \subsection{Extraction of sub-NBA \upshape  $\auto{subtask}$ {\it from} $\auto{relax}$}\label{sec:pregraph}
  In  this section, we first introduce the notion of subtasks, and then exploit the structure of the NBA $\auto{realx}$ by decomposing the it into sub-NBA such that each sub-NBA corresponds to one pair of sorted initial and accepting vertices (see also block 1 in Fig.~\ref{fig:overview}), and then extract subtasks along with infering  their temporal order  in  Section~\ref{sec:poset}. In Section~\ref{sec:solution}, the extracted subtasks with inferred temporal order are used to synthesize a high-level plan that can induce a path in $\auto{realx}$ that connects the   pair of initial and accepting vertices and a cycle around the accepting vertex.
\subsubsection{Subtasks:}\label{sec:subtask}
Consider an edge $e = (v_1, v_2) $  and its starting vertex $v_1$ in a NBA $\auto{}$, e.g., $\autop^-$ or $\auto{relax}$.  Assume that the current vertex of $\auto{}$ is $v_1$. To transition to $v_2$, certain robots need to simultaneously reach certain regions to make $\gamma(v_1, v_2)$ true, while maintaining  $\gamma(v_1)$ true en route. We assume that the transition to $v_2$ occurs immediately once $\gamma(v_1, v_2)$ becomes true. Based on this interpretation, we formally define the subtask below.
\begin{defn}[(Subtask)]\label{defn:subtask}
 {A subtask is equivalent to an edge $(v_1, v_2)$ in the NBA $\auto{}$.}
\end{defn}

The goal of this subtask is to generate a transition leading to vertex $v_2$. Informally speaking, an edge $e$ in $\auto{}$ captures a subtask that specifies a set of \textit{target regions} that should be visited by robots of certain types. Subtasks can be viewed as generalized reach-avoid tasks where  specific types of robots are driven to desired target regions (the "reach" part of the task) while satisfying the vertex label along the way (the "avoid" part of the task. Avoidance here is defined in a more general way compared to the conventional definition that requires robots to stay away from given regions in space). Note that it is the label of the starting vertex $v_1$ and the label of the edge $(v_1, v_2)$ that define the subtask.
Next we give  the notion of equivalent subtasks.
\begin{defn}[(Equivalent subtasks)]\label{defn:eq}
 Subtasks $(v_1, v_2)$ and $(v'_1, v'_2)$ in a NBA $\auto{}$ are equivalent, denoted by $(v_1, v_2) \sim (v'_1, v'_2)$, if $\gamma(v_1) = \gamma(v'_1)$, $\gamma(v_1, v_2)=\gamma(v_1', v'_2)$ and they  are not in the same path that connects the same  pair of initial and accepting vertices.
\end{defn}

 The last condition in Definition~\ref{defn:eq} is necessary since two subtasks in the same path mark different progress towards task completion, even if they have identical labels.
\begin{cexmp}[(Subtasks)]
  The relaxed NBA  $\auto{relax}$ captures high-level plans that are composed of subtasks that need to be satisfied in specific orders to reach the accepting vertex. For instance, the path $\vertex{init}, v_1, v_4, v_3, v_6$ in Fig.~\ref{fig:nba_i_relax} represents a high-level plan where first $\langle1,2\rangle$ visit region $\ell_4$, then $\langle2,1\rangle$ visits region $\ell_2$ and finally the same two robots of type 1 visit region $\ell_3$. By the interpretation of task \hyperref[task:i]{\it (i)}, the temporal order between these subtasks specifies that the time when $\langle1,2\rangle$ visits region $\ell_4$ is independent from the time when $\langle2,1\rangle$ visit region $\ell_2$, and that $\langle1,2\rangle$ visiting region $\ell_4$ and $\langle2,1\rangle$  visiting region $\ell_2$ should occur prior to $\langle2,1\rangle$ visiting region $\ell_3$.
\end{cexmp}

In the rest of Section~\ref{sec:app} and in Section~\ref{sec:solution}, we focus on the relaxed NBA $\auto{relax}$ and design high-level plans that ignore collision avoidance between robots and only specify the sequence of regions that the robots should visit and the corresponding timing.



%% \subsubsection{Revisit of the prefix-suffix structure of accepting runs}\label{sec:presuf}
%% \blue{Recall in Section~\ref{sec:ltl} that the prefix part connects an initial vertex $v_0$ to an accepting vertex $\vertex{accept}$, and the suffix part connects the accepting vertex $\vertex{accept}$ to itself. In what follows, assisted by Fig.~\ref{fig:lasso}, we discuss the prefix-suffix structure of accepting runs in the NBA $\auto{relax}$ in two cases based on the presence or absence of the vertex label of  $\vertex{accept}$.
%%   \domanda{(i) Presence of \upshape$\gamma(\vertex{accept})$}\label{sec:presence} If the robots reach locations that drive the transition in NBA $\auto{relax}$ to the accepting vertex $\vertex{accept}$ with $\gamma(\vertex{accept})\neq\bot$ and remain idle thereafter, the suffix part of the accepting run of $\auto{relax}$ only contains $\vertex{accept}$; see Fig.~\ref{fig:lasso}.
%%   \domanda{(ii) Absence of \upshape $\gamma(\vertex{accept})$}\label{sec:absence} For the suffix part, not only do the transitions in the NBA $\auto{relax}$ occur along a cycle around $\vertex{accept}$, but also robots need to travel back to some locations to make their trajectories loops, thus, synchronizing and restarting the inifite execution. Let $v_{\text{prior}}$ and $v_{\text{next}}$ denote the vertices that right before and after $v_{\text{acccept}}$ in a cycle around $\vertex{accept}$, and $v'_{\text{prior}}$ denote the vertex right before $\vertex{accept}$ in the prefix part; see also Fig.~\ref{fig:lasso}. If  the edge label $\gamma(\vertex{accept}, v_{\text{next}})$ in $\auto{relax}$ is not $\top$, then robots need to satisfy $\gamma(\vertex{accept}, v_{\text{next}})$ immediately after the satisfcatoin of the edge label $\gamma(v'_{\text{prior}}, \vertex{accept})$ (due to $\gamma(\vertex{accept}) = \bot$) and further satisfy the vertex label $\gamma(v_{\text{next}})$ at the next time instant. Thus, if these two edges are addressed separately such that one is considered when designing the prefix plan and  the other is considered  when desinging the suffix plan, it is possible that robots can not visit regions that satisfy $\gamma(\vertex{accept}, v_{\text{next}})$ immediately after the satisfaction of $\gamma(v'_{\text{prior}}, \vertex{accept})$ and further $\gamma(v_{\text{next}})$ at the next time instant. That is, the termination of the prefix part cannot successfully transition to the activation of the suffix part.  The same issue occurs to the case where one round of cycle ends up at $\vertex{accept}$ and the the satisfaction of $\gamma(v_{\text{prior}}, \vertex{accept})$ might not lead to the satisfaction of $\gamma(\vertex{accept}, v_{\text{next}})$. To overcome this issue, we extend the prefix plan and let the last part of the prefix plan drive the transition one step further to $v_{\text{next}}$ and the final locations of the prefix plan satisfy its vertex label $\gamma(v_{\text{next}})$; see also the shaded prefix plan in Fig.~\ref{fig:lasso}, In this way, the prefix part and the cycle partially overlap.}

%%   %% first need to satisfy $\gamma(\vertex{accept}, v_{\text{next}})$ immediately after the satisfcatoin of the edge label $\gamma(v_{\text{prior}}, \vertex{accept})$ (due to $\gamma(\vertex{accept}) = \bot$) when they are about to finish one round along the cycle, and what's more, they also need to travel back to initial locations of the suffix part, i.e., final locations of the prefix part that drives the transition to the accepting state $\vertex{accept}$, to close the trajectory loop and synchronize. However, the issue is that it is possible that robots can not visit regions that satisfy $\gamma(\vertex{accept}, v_{\text{next}})$ immediately after the satisfaction of $\gamma(v_{\text{prior}}, \vertex{accept})$ if they are addressed . Even so, travelling back to initial locations might violate the vertex label $\gamma(v_{\text{next}})$. To overcome this issue, we extend the prefix plan and let the last part of the prefix plan drive the transition one step further to $v_{\text{next}}$ and the final locations of the prefix plan satisfy its vertex label $\gamma(v_{\text{next}})$; see also the shaded prefix plan in Fig.~\ref{fig:lasso}, so that the edge label $\gamma(\vertex{accept}, v_{\text{next}})$ is satisfied while robots head towards their initial locations.

  \subsubsection{Sorting the pairs of initial and accepting vertices by path length:}\label{sec:sort}  As stated in the condition \hyperref[cond:b]{\it (b)} of Definition~\ref{defn:run}, each restricted accepting run  contains  one pair of initial and accepting vertices. In what follows, we sort the pairs of initial and accepting vertices in terms of the shortest length of the accepting run.  Then in Section~\ref{sub-NBA:1} we extract a sub-NBA for each pair by following the order. It is beneficial to deal with sub-NBA one at a time other than the whole NBA $\auto{relax}$ due to the reduced complexity.
  \paragraph{(1) Computation of the shortest simple path:} Given a pair of initial vertex $v_0$ and accepting vertex $\vertex{accept}$ in $\auto{relax}$, we first compute the number of edges/subtasks in the shortest simple path from  $v_0$ to $\vertex{accept}$ where a simple path does not contain any  repeating vertices, echoing with the condition~\hyperref[cond:a]{\it (a)} in the Definition~\ref{defn:run} that no cycle exists in the prefix-suffix structure.
  To this end, we first remove all other initial vertices and accepting vertices from $\auto{relax}$. This will not affect those restricted  accepting runs that contain $v_0$ and $\vertex{accept}$ due to condition \hyperref[cond:b]{\it (b)}  in Definition~\ref{defn:run}.  Then, for the initial vertex $v_0$, we continue depending on whether it has a self-loop:
  \stepcounter{mycounter}
  \paragraph{(\Alph{mycounter}$_1$) if $v_0$ does not have a self-loop, i.e., $\gamma(v_0)=\bot$:}\label{sec:initial} In this case, for each outgoing edge of $v_0$ in $\auto{relax}$ with label $\gamma$,  we remove this edge  if the initial robot locations do not satisfy the corresponding edge label $\gamma_{\phi}$ (including the negative literals) in $\autop$. We highlight that the satisfaction check should be conducted in the NBA $\autop$, since if initial robot locations can not enable an edge starting from $v_0$ in $\autop$, there is no point in considering this edge in any NBA that is obtained from $\autop$.
\paragraph{(\Alph{mycounter}$_2$) if $v_0$ has a self-loop, i.e., $\gamma(v_0)\neq\bot$:} We check whether the initial robot locations satisfy $\gamma_{\phi}(v_0)$. If yes, we do nothing; otherwise, this case is the  same as case~\hyperref[sec:initial]{\it (a)} and thus, we remove the self-loop of $v_0$ and
remove any of its  outgoing edges  from $\auto{relax}$ if the initial robot locations do not satisfy the corresponding edge label $\gamma_{\phi}$ in $\autop$.

Next, the shortest simple path connecting $v_0$ and $\vertex{accept}$ can be found using Dijkstra's algorithm.  Note that if a vertex is both an initial and accepting vertex, we view it differently, one as the initial vertex and one as the accepting vertex, although it appears twice in the shortest simple path.
\paragraph{(2) Computation of the shortest simple cycle:} Next, we compute the number of edges in the shortest simple cycle around the given accepting vertex $v_\text{accept}$ in $\auto{relax}$, where in a simple cycle, repeating vertices only appear at the first and last. Note that this $\auto{relax}$ is a copy of the original one that is obtained from $\autop^-$, thus, operations used to  find the shortest simple  path will not affect this $\auto{relax}$. If $\vertex{accept}$ in $\auto{relax}$ has a self-loop, the length of the shortest simple cycle is 0. Otherwise, similar to finding the shortest simple path, we first remove all other accepting vertices from~$\auto{relax}$ and then remove all initial vertices (including $v_0$) if they do no have self-loops.  In this way, the only vertex that does not have a self-loop is the accepting vertex $\vertex{accept}$.  This will not affect those restricted accepting runs that are related to  $v_0$ and $\vertex{accept}$  due to conditions \hyperref[cond:b]{\it (b)} and \hyperref[cond:c]{\it (c)} in Definition~\ref{defn:run}.


  By default, if no simple path or cycle exists, the length is infinite. After obtaining the shortest simple path and cycle, we assign their total length to the given pair of initial and accepting vertices.  Finally,  we sort all pairs of initial and accepting vertices in an ascending order in terms of the total length. We prefer the pair with the shorter length since it contains fewer subtasks to be completed.}
%% \begin{figure}[!t]
%%   \centering
%%   \subfigure[$\gamma(\vertex{accept}) \neq \bot$]{
%%       \label{fig:presence}
%%       \includegraphics[width=0.3\linewidth]{presence.pdf}}
%%   \subfigure[$\gamma(\vertex{accept}) = \bot$]{
%%       \label{fig:absence}
%%       \includegraphics[width=0.6\linewidth]{absence_presuf.pdf}}
%%   \caption{Fig.~\ref{fig:presence} depicts the sub-NBA for the prefix and suffix parts with the presence of $\gamma(\vertex{accept})$ and Fig.~\ref{fig:absence} depicts the sub-NBA for the prefix and suffix parts, respectively, with the absence of $\gamma(\vertex{accept})$.}
%%   \label{fig:presuf}
%% \end{figure}


  \subsubsection{Extraction of the sub-NBA \upshape $\auto{subtask}$:}\label{sub-NBA:1}
  We iterate over the sorted pairs of initial and accepting vertices. Given a pair of vertices  $v_0$ and $v_\text{accept}$ whose total length is not infinite, we seek to find a high-level plan that induces  a path in $\auto{relax}$ that connects this pair $v_0$ and $\vertex{accept}$, and a cycle around $\vertex{accept}$. To do this,  we extract one sub-NBA for the prefix part and one for the suffix part, respectively, from the NBA $\auto{relax}$.  Here, we discuss the prefix sub-NBA. The suffix sub-NBA is similar and will be  discussed in Section~\ref{sec:suf}.

  Given the pair of vertices $v_0$ and $\vertex{accept}$, we construct a prefix sub-NBA $\auto{subtask}$ in the following 4 steps and the resulting NBA $\auto{subtask}$ are shown Fig.~\ref{fig:prefix}.

  \stepcounter{mycounter} {\it (\Alph{mycounter}$_1$)} We first follow similar procedures as those in Section~\ref{sec:sort} when computing the shortest simple path, including removing the self-loop of $v_0$ and its outgoing edges from $\auto{relax}$ if the initial robot locations do not satisfy them and further removing all other initial and accepting vertices.  Note that when $v_0 = \vertex{accept}$ in $\auto{relax}$, i.e., the initial vertex is also the accepting vertex, we remove the self-loop of $v_0$ (acting as the initial vertex) when the initial robot locations do not satisfy its label, but this will not affect the self-loop of $\vertex{accept}$ (acting as the accepting vertex) since  we view $v_0$ and $\vertex{accept}$ differently following condition~\hyperref[cond:a]{\it (a)} in Definition~\ref{defn:run}. Fig.~\ref{fig:prefix_self_loop}  and~\ref{fig:prefix_no_self_loop} show   $\auto{subtask}$  when the label $\gamma_{\phi}(v_0)$ is satisfied and not satisfied  by the initial robot locations, respectively.

  {\it (\Alph{mycounter}$_2$)} Then, if $\vertex{accept}$ has a self-loop, based on condition~\hyperref[cond:e]{\it (e)} in Definition~\ref{defn:run}, we remove any of its incoming edges if the incoming edge label in $\autop$ does not strongly  imply its label $\gamma_{\phi}(\vertex{accept})$. Still, the implication is checked in $\autop$. In this way, if the NBA $\auto{relax}$ advances to $\vertex{accept}$ by traversing the remaining edges, then the label of $\vertex{accept}$ is satisfied automatically, making the suffix part a single vertex. Fig.~\ref{fig:prefix_self_loop}  and ~\ref{fig:prefix_no_self_loop} show   $\auto{subtask}$  when $\vertex{accept}$ has or does not have a self-loop,  respectively. Specifically, all incoming edges of $\vertex{accept}$ are preserved in Fig.~\ref{fig:prefix_self_loop} due to $\gamma_{\phi}(\vertex{accept})=\bot$, whereas in Fig.~\ref{fig:prefix_no_self_loop} only edges with labels that imply $\gamma_{\phi}(\vertex{accept})$ are preserved.

  {\it (\Alph{mycounter}$_3$)} Next, we remove all outgoing edges from $\vertex{accept}$ if $\vertex{accept} \not=v_0$, because we focus on the prefix part.

  {\it (\Alph{mycounter}$_4$)} Finally, let $\ccalV_{\text{s}}$ denote the set that contains all remaining vertices in $ \auto{relax}$ that belong to a path that connects $v_0$ and $\vertex{accept}$, then we construct a sub-NBA $\auto{subtask}=(\ccalV_{\text{s}}, \ccalE_\text{s})$ from $\auto{relax}$ that includes all edges between vertices in $\ccalV_{\text{s}}$; see also Fig.~\ref{fig:prefix}. We highlight that, for a run $\rho$  connecting $v_0$ and $\vertex{accept}$ in $\auto{relax}$ and its corresponding run $\rho_{\phi}$ in $\autop$ is the prefix part of a restricted accepting run,  if the run $\rho$ can  be induced by robot paths, then it will exist in the sub-NBA $\auto{subtask}$, as shown in Proposition~\ref{prop:nonempty} in Section~\ref{sec:correctness}.

%% Based on the vertex label  $\gamma(\vertex{accept})$, we operate on $\auto{subtask}$ in two manners.

\begin{figure}
  \centering
  \subfigure[$\gamma_{\phi}(v_0)\neq \bot$ is satisfied by initial robot locations and $\gamma_{\phi}(\vertex{accept}) = \bot$]{
    \includegraphics[width=0.41\linewidth]{prefix_self_loop.pdf}\label{fig:prefix_self_loop}}
  \hspace{0.5em}
  \subfigure[$\gamma_{\phi}(v_0)$ is not satisfied by initial robot locations and $\gamma_{\phi}(\vertex{accept})\neq \bot$]{
    \includegraphics[width=0.45\linewidth]{prefix_no_self_loop.pdf}\label{fig:prefix_no_self_loop}}
  \caption{$\auto{subtask}$ for the prefix part.}\label{fig:prefix}
\end{figure}

%% When the accepting vertex $\vertex{accept}$ has a self-loop, we solve the prefix and suffix part at the same time, since if robot configurations satisfy the vertex label $\gamma(\vertex{accept})$ and remain idle, the progression will stay at $\vertex{accept}$ forever.
%% In particular, we add a vertex $v'_{\text{accept}}$ with label $\top$ and an edge $(\vertex{accept}, v'_{\text{accept}})$ with label $\top$ to $\auto{subtask}$, so that the edge $(\vertex{accept}, v'_{\text{accept}})$ will be treated as a subtask in Section~\ref{sec:app} and its vertex label $\gamma(\vertex{accept})$ will be enabled when designing high-level and low-level plans in Section~\ref{sec:solution2mrta}; see also Fig.~\ref{fig:prefix_self_loop}.  Note that when $v_0 = \vertex{accept}$ in $\auto{relax}$, that is, when the initial vertex is also the accepting vertex, we remove the self-loop of $v_0$ (acting as the initial vertex) when the initial robot locations do not satisfy its label, but this will not affect the self-loop of $\vertex{accept}$ (acting as the accepting vertex) since  we view $v_0$ and $\vertex{accept}$ differently. Furthermore, we only connect $v'_{\text{accept}}$ to $\vertex{accept}$ that acts as the accepting vertex; see Fig.~\ref{fig:prefix_no_self_loop}.
%% \domanda{\it (ii) Absence of \upshape$\gamma(\vertex{accept})$} This case corresponds to case~\hyperref[sec:absence]{\it (ii)}. If $\gamma(\vertex{accept})$ does not exist, we connect $\vertex{accept}$ to $v_{\text{next}}$ that immediately follow $\vertex{accept}$ in $\auto{relax}$, and build a sub-NBA $\auto{relax}$ for each selection of $v_{\text{next}}$. We sort the set of vertices $v_{\text{next}}$ in an ascending order according to the length of the propositional formula $\gamma(\vertex{accept}, v_{\text{next}})$. The length of formula $\top$ is 0 by default. Intuitively, the shorter the formula is, the easier it can be satisfied. As discussded in~case~\hyperref[sec:absence]{\it (ii)}, the vertex label of $v_{\text{next}}$ should be satisfied at last (it has a vertex label since we remove all vertices without lables except initial and accepting vertices in step~\hyperref[prune:3]{{\it 6)}} in Section~\ref{sec:prune}). Similar to~\hyperref[i:presence]{{\it i)}}, we add a new vertex $v'_{\text{next}}$ with label $\top$ and a new edge $(v_{\text{next}}, v'_{\text{next}})$ with label $\top$  to $\auto{subtask}$; see also the left figure in Fig.~\ref{fig:absence}.

     \begin{figure}
       \centering
       \subfigure[$\auto{subtask}$ for task~{\it (i)}]{
         \includegraphics[width=0.4\linewidth]{nba_i_subtask.pdf}\label{fig:nba_i_subtask}}
       \hspace{2em}
       \subfigure[$\auto{subtask}$ for task~{\it (ii)}]{
         \includegraphics[width=0.2\linewidth]{nba_ii_subtask.pdf}\label{fig:nba_ii_subtask}}
       \caption{Sub-NBA $\auto{subtask}$ for the prefix part of tasks~\hyperref[task:i]{\it (i)} and~\hyperref[task:i]{\it (ii)}.}
       \label{fig:auto_subtask}
     \end{figure}

     \begin{cexmp}
       The sub-NBA $\auto{subtask}$ for the prefix part of tasks~\hyperref[task:i]{\it (i)} and~\hyperref[task:i]{\it (ii)} are shown in~Fig.~\ref{fig:auto_subtask}. For task~\hyperref[task:i]{\it (i)}, given the pair $\vertex{init}$ and $v_6$ in the relaxed NBA $\auto{relax}$ in Fig.~\ref{fig:nba_i_relax}, the total length is $3+0=3$ (edges $(\vertex{init}, v_3), (\vertex{init}, v_4), (\vertex{init}, v_5)$ were removed). The NBA $\auto{subtask}$, shown in  Fig.~\ref{fig:nba_i_subtask} is obtained by removing edges $(\vertex{init}, v_3), (\vertex{init}, v_4), (\vertex{init}, v_5), (v_5, v_3),  (v_5, v_6)$ and vertex $v_5$ from $\auto{relax}$ and further adding vertex $v_{6'}$ and the edge $(v_6, v_{6'})$ due to $\gamma(v_6)\neq \bot$. For task~\hyperref[task:i]{\it (ii)}, given the pair $\vertex{init}$ and $\vertex{init}$,  there is no cycle leading back to $\vertex{init}$, so the total length is infinite and there is no corresponding sub-NBA $\auto{relax}$. The total legnth for the pair $\vertex{init}$ and $v_3$ is $2+2=4$, and $\auto{subtask}$ is shown in  Fig.~\ref{fig:nba_ii_subtask}.
     \end{cexmp}

Observe that the sub-NBA $\auto{subtask}$ in Fig.~\ref{fig:nba_i_subtask} still costitutes a large portion of  $\auto{relax}$ in Fig.~\ref{fig:nba_i_relax}, which is typical due to that the ratio of the number of edges to the number of initial and accepting vertices is not small and the \ltl formulas permit the existence of self-loops of most vertices. Therefore, in what follows, we further prune the NBA $\auto{subtask}$  by exploiting its structure.

\begin{figure}
  \centering
  \subfigure[ID property]{
    \includegraphics[width=0.6\linewidth]{id.pdf}\label{fig:id}}
  \subfigure[ST property]{
    \includegraphics[width=0.36\linewidth]{st.pdf}\label{fig:st}}
  \caption{ID and ST properties.}\label{fig:property}
\end{figure}
  \subsubsection{Prune the sub-NBA \upshape $\auto{subtask}$:} \label{sub-NBA:2}
Recall that for task~\hyperref[task:i]{\it (i)}  some visitation of certain regions can be executed in parallel. To capture this, We define the independent diamond (ID) property adapted from~\cite{stefanescu2006automatic}  and sequential triangle (ST) property over vertices; see also Fig.~\ref{fig:property}.
\begin{defn}[(Independent diamond property)]\label{defn:id}
  Given 4 different vertices $v_1, v_2, v_3, v_4$ in the NBA $\auto{subtask}$, we say that these 4 vertices have the ID property if (a) $\gamma(v_1) = \gamma(v_2) = \gamma(v_4)$, (b) $v_1 \xrightarrow{\gamma}_B v_2 \xrightarrow{\gamma'}_B v_3$, (c) $v_1 \xrightarrow{\gamma'}_B v_4 \xrightarrow{\gamma}_B v_3$,  (d) $v_1 \xrightarrow{\gamma \wedge \gamma'}_B v_3$, and (e) $\gamma_{\phi}(v_3) = \top$ if $v_3 = \vertex{accept}$.
\end{defn}
Intuitively, if vertices have the ID property (see Fig.~\ref{fig:id}), we have equivalent subtasks $(v_1, v_2) \sim (v_4, v_3)$ and $(v_1, v_4) \sim (v_2, v_3)$ in $\auto{subtask}$ according to conditions {\it (a)-(c)}, and the occurence order is arbitrary according to conditions {\it (b)-(d)}.  We refer to $(v_1, v_3)$ as the {\it composite} subtask and $(v_1, v_2)$, $(v_1, v_4)$ as the {\it elementary} subtasks.  Although both can lead to vertex $v_3$, elementary subtasks are preferred since subtasks $(v_1, v_2)$ and $(v_1, v_4)$ can be executed independently, making it easier to satisfy and more flexible to implement, when compared to the composite subtask that requires that two subtasks are accomplished at the same time. It's worth noting that the $\top$-check in condition {\it (e)} are conducted in $\autop$ for the sake of condition~\hyperref[cond:f]{\it (f)} in the Definition~\ref{defn:run}. The presence of condition~\hyperref[cond:f]{\it (f)} guarantees that the non-emptiess of the set of restricted accepting runs will not be affected if the edge $(v_1, \vertex{accet})$ is removed,  as shown in Proposition~\ref{prop:sub-NBA} in Section~\ref{sec:correctness}. Specifically, if $\gamma_{\phi}(v_3) \ne \top$ when $v_3 = \vertex{accept}$, and further if a restricted accepting run traverses edges $(v_1, \vertex{accept})$ and $(\vertex{accept}, \vertex{next})$ where $\vertex{accept}\neq \vertex{next}$, condition~\hyperref[cond:f]{\it (f)} in the Definition~\ref{defn:run} impplies  that $\gamma_{\phi}(v_1, \vertex{accept}) \simplies \gamma_{\phi}(\vertex{accept}, \vertex{next})$, but $\gamma_{\phi}(v_2, \vertex{accept})$ and $\gamma_{\phi}(v_4, \vertex{accept})$ may not be able to imply $\gamma_{\phi}(\vertex{accept}, \vertex{next})$ since they are subformulas of $\gamma_{\phi}(v_1, \vertex{accept})$. Therefore, in this case, removing the composite subtask $(v_1, \vertex{accept})$ can be at the risk of emptying the  set of restricted accepting runs.


\begin{defn}[(Sequential triangle property)]\label{defn:st}
  Given 3 different vertices $v_1, v_2, v_3$ in the NBA $\auto{subtask}$, we say that these 3 vertices $v_1, v_2, v_3$ have the ST property if %% {\it (i)} $\gamma(v_1) = \gamma(v_2)$,
(a) $v_1 \xrightarrow{\gamma}_B v_2 \xrightarrow{\gamma'}_B v_3$,  (b) $v_1 \xrightarrow{\gamma \wedge \gamma'}_B v_3$, and (c) $\gamma_{\phi}(v_3) = \top$ if $v_3 = \vertex{accept}$.
\end{defn}

If vertices have the ST  property (see Fig.~\ref{fig:st}), subtask $(v_1, v_2)$ should be satisfied no later than $(v_2, v_3)$, according to conditions {\it (a)} and {\it (b)}. Observe that if vertices $v_1, v_2, v_3, v_4$ have the ID property, then $v_1, v_2, v_3$ and $v_1, v_4, v_3$ have the ST property. Based on these two properties, for any edge $(v_1, v_3)$ in $\auto{subtask}$, we delete it if there exists  vertex $v_2$ such that combined they have  ST property. We denote by $\auto{subtask}^-$ the pruned $\auto{subtask}$.

Note that a composite subtask can be an elementary subtask of another composite subtask at a higher layer, therefore, removing composite subtasks  is vital for reducing the size of $\auto{subtask}$. Similar to the pruning of $\autop$ to get $\autop^-$, feasibility of Problem~\ref{prob:1} is not compromised by pruning the NBA $\auto{subtask}$, as shown in Proposition~\ref{prop:sub-NBA} in Section~\ref{sec:correctness}. %% \red{ This also justifies the method to sort a pair of initial and accept vertices. The shortest path usually results in longer labels that can be decomposed into multiple shorter labels, hence more subtasks but each one can be fulfilled easily.}
\begin{figure}[t]
    \centering
    \subfigure[$\auto{subtask}^-$]{
      \label{fig:sub-NBA}
      \includegraphics[width=0.2\linewidth]{nba_i_subtask_prune.pdf}}
    \hspace{2em}
    \subfigure[Subtasks]
    {\label{fig:subtask}
      \includegraphics[width=0.5\linewidth]{subtask_i.pdf}}
        \caption{The NBA $\auto{subtask}^-$ and corresponding subtasks.} \label{fig:subtask_prune}
\end{figure}
\begin{cexmp} [(ID and ST properties and NBA $\auto{subtask}^-$)]
  In the NBA $\auto{subtask}$ for task~\hyperref[task:i]{\it (i)}, shown in Fig.~\ref{fig:nba_i_subtask}, instances of the ID and ST properties are the set of 4 vertices $v_1, v_2, v_3, v_4$ and the set of 3 vertices $v_2, v_3, v_6$, respectively. So we delete $(v_1, v_3)$ and $(v_2, v_6)$. The obtained $\auto{subtask}^-$ is shown in Fig.~\ref{fig:sub-NBA}. The NBA $\auto{subtask}^-$ of task~\hyperref[task:ii]{\it (ii)} is the same as $\auto{subtask}$ since there are no composite subtasks.
\end{cexmp}

\begin{rem}
  The last conditions {\it (e)} in the definition of ID property and {\it (c)} in the definition of ST property are necessary for establishing the theorectical guarantee in Proposition~\ref{prop:sub-NBA}  on the non-emptiess of  set of restricted accepting runs after the prunning of composite subtasks. However, these conditions are not necessary in practice when implementating the prunning process. We found that in the simulations in Section~\ref{sec:sim}, with condition {\it (c)} being omitted, only checking conditions {\it (a)} and {\it (b)} of Definition~\ref{defn:st} in $\auto{subtask}$  does not compromise  the performance.
\end{rem}


%% \begin{figure}[t]
%%   \centering
%%   \includegraphics[width=1\linewidth]{p_nba0.pdf}
%%    \caption{Sub-NBA $\auto{subtask}$}
%%   \label{fig:nba_b}
%% \end{figure}

\subsection{Inferring temporal order between subtasks in  $\auto{subtask}^-$}\label{sec:poset}
In this section,  we infer the temporal relation between subtasks in the pruned NBA $\auto{subtask}^- = (\ccalV_\text{s}, \ccalE_\text{s})$; see also block 2 in Fig.~\ref{fig:overview}.  To capture the temporal relation among subtasks in a high-level plan,  we rely on the use of partial orders described in Subsection~\ref{sec:partial}.


Specifically, given the NBA $\auto{subtask}^-$, let $\Theta$ denote the set that collects all simple paths that connect $v_0$ and $\vertex{accept}$ in $\auto{subtask}^-$. Simple paths suffice since condition~\hyperref[cond:a]{\it (a)} in Definition~\ref{defn:run} excludes cycles. %% In the case that $\vertex{accept}$ has a self-loop, we collect all paths leading to $\vertex{accept}'$.
For a simple path $\theta \in\Theta$, let $\ccalT(\theta)$ denote the set of subtasks in $\theta$. We say two simple paths $\theta_1, \theta_2$ have the same set of subtasks if $\ccalT(\theta_1) =\ccalT(\theta_2)$. Then we partition $\Theta$ into subsets of  simple paths that contain the same set of subtasks, that is, $\Theta = \cup_e \Theta_e$, $\Theta_e \cap \Theta_{e'} = \emptyset$ if $e\not=e'$. The motivation for this partition is that the set of linear extensions generated by a poset has the same set of elements. {In what follows, we map subtasks to integers to facilitate the discovery of the  poset.}

Given a subset $\Theta_e$ of simple paths in the partition, with a slight abuse of notation, let $\ccalT(\Theta_e)$ denote the set of corresponding  subtasks. Let the function $f_e:\ccalT(\Theta_e)\to [|\ccalT(\Theta_e)|]$ map each subtask to a positive integer. Using $f_e$, we can map every path in $\Theta_e$ to a sequence of integers. Let $\Gamma_e$ collect all sequences of integers for all paths in $\Theta_e$, so $|\Theta_e| =  |\Gamma_e|$. Moreover, a sequence in $\Gamma_e$ is a permutation of the same set of integers, denoted by $X_e = [|\Theta_e|]$. For every sequence $S_e \in \Gamma_e$, let $S_e[i]$ denote its $i$-th entry. We define a linear order $L_{X_e} = (X_e, <_L)$ such that  $S_e[i]  <_L  S_e[j] $ if $i  <  j$. In other words, the subtask $S_e[i]$ should be executed prior to  $S_e[j]$. Then, let $\Xi_e$ collect all linear orders over $X_e$ that can be defined from sequences in $\Gamma_e$. An underlying poset $P_e  = (X_e, <_{P_e})$ of $\Xi_e$ can be found using the algorithm for the partial cover problem in~\cite{heath2013poset}, where the order represents the precedence relation. After obtaining the poset $P_e$, we double check whether the set of all linear extensions of $P_e$ is the same as $X_e$. Otherwise, we treat each linear order in~$\Xi_e$ as a separate linear ordered set, which is a poset as well.

{Finally, given a partition $\{\Theta_e\}$ and a corresponding set of posets $\{P_e\}$, we sort the set $\{P_e\}$ of posets   lexicographically first in a descending order in terms of the width of the posets and then in a ascending order in terms of the height.  The width of a poset  is the cardinality of a maximum antichain, which is a subset of the poset where any two distinct elements are incomparable. The height is the cardinality of a maximum chain, where any two elements are comparable. Intuitively, the wider a poset is, the larger the number of temporally independent subtasks it contains. The lower of a poset is, the smaller the number of elementary subtasks it has.} Every linear extension of subtasks in a poset produces a simple path that connects $v_0$ and $\vertex{accept}$ in $\auto{subtask}^-$. In the next section, our goal is to find a high-level plan that produces a linear extension of a given poset and optimizing the cost of the plan at the same time.

\begin{cexmp}[(Temporal constraints)]
  For task~\hyperref[task:i]{\it (i)}, there are 2 simple paths in $\auto{subtask}^-$ leading to $v_6'$ and all have the same set of 5 edges.  $\Theta_1 = \{\vertex{init},v_1, v_4,v_3,v_6,v_{6'}$; $\vertex{init}, v_1, v_2,v_3, v_6, v_{6'}$\}; see~Fig~\ref{fig:sub-NBA}. Note that the added edge $(v_6, v_{6'})$ is always at the end since it is the only edge after the accepting vertex $v_6$. The design of equivalent subtasks, mapping function, integer sequence and the poset are shown in Fig.~\ref{fig:subtask}. The temporal relation implies that subtasks $(v_1, v_4)$ and $(v_1, v_2)$ are independent, which agrees with our observation. For task~\hyperref[task:ii]{\it (ii)}, the NBA $\auto{subtask}^-$ in Fig.~\ref{fig:nba_ii_subtask} only has one path of 2 subtasks that generates a total ordered set, that is, every two subtasks are comparable.
\end{cexmp}

%% Given $e = (v_1, v_2) \in\ccalE_\text{s}$, let $\ccalE_e$ collect all edges in $\ccalE_\text{s}$ that share the same first vertex label and edge label with $e$, i.e., $\ccalE_e = \{e' = (v'_1, v'_2) \in \ccalE_p \, |\, \gamma(v_1) = \gamma(v'_1), \gamma(v_1, v_2) = \gamma(v'_1, v'_2)\}$. Next, we partition $\ccalE_e$ into two disjoint subsets $\ccalE_e^1$ and $\ccalE_e^2$ such that any $e_1, e_2 \in \ccalE_e^1$ do not belong to a common path in $\Pi$ and $\ccalE_e^2$ is the complement of $\ccalE_e^1$, where $\Pi$ collects all simple paths that connect $v_0$ and $\vertex{accept}$ in $\auto{subtask}$. Tasks in $\ccalE_e^1$ are temporally independent and $\ccalE_e^1$ contains all possible such tasks/e{e'ges.

%% Given $\ccalE_e$ and its partition into $\ccalE_e^1$ and $\ccalE_e^2$, let the function $f_e: \ccalE_e \to \{N_e, \ldots,N_e+|\ccalE_e^2|\}$ map all edges in $\ccalE_e^1$ to the positive integer $N_e$, i.e., $f(e_1) = f(e_2)=N_e, \forall e_1, e_2 \in \ccalE_e^1$, and every edge in $\ccalE_e^2$ to a distinct integer in $\{N_e+1, \ldots, N_e+|\ccalE_e^2|\}$ with one-to-one correspondence, where  $[N_e-1]$ are the integers that have been already used for other sets in $\{\ccalE_e\}$. Since ${\ccalE_e}$ forms a partition of $\ccalE_\text{s}$, we can combine all functions $f_e$ in the function $f: \ccalE_p \to \mathbb{N}^+$ that maps an edge in $\ccalE_p$ to a positive integer. %% In Example~\ref{exp:1}, the function is defined as $f(\vertex{init}, v_{1}) = 1, f(v_{1}, v_{2}) = f(v_5, v_4) = 2, f(v_1, v_5) = f(v_{2}, v_{4}) = f(v_3, v_7)=3, f(v_{2}, v_{3}) = f(v_4, v_7) =4$.


%% \begin{cexmp}
%%   Consider the running example. The equivalence sets are $\ccalE_{(\vertex{init}, v_{1})} = \ccalE^1_{(\vertex{init}, v_{1})} = \{(\vertex{init}, v_{1})\}$, $\ccalE_{(v_{1}, v_{2})} = \ccalE^1_{(v_{1}, v_{2})} = \{(v_{1}, v_{2}), (v_5, v_4)\}$, $\ccalE_{(v_{1}, v_{5})} = \ccalE_{(v_{1}, v_{5})}^1 =  \{(v_1, v_5), (v_{2}, v_{4}), (v_3, v_7)\}$, $\ccalE_{(v_{2}, v_{3})} = \ccalE^1_{(v_{2}, v_{3})} = \{(v_{2}, v_{3}), (v_4, v_7)\}$. The function is defined as $f(\vertex{init}, v_{1}) = 1, f(v_{1}, v_{2}) = f(v_5, v_4) = 2, f(v_1, v_5) = f(v_{2}, v_{4}) = f(v_3, v_7)=3, f(v_{2}, v_{3}) = f(v_4, v_7) =4$. The set of sequences $\Gamma = \Gamma_\sim^1 = \{(1,2,4,3), (1,2,3,4), (1,3,2,4)\}$ and the order relation of the underlying poset $P_1 = P = \{1<_{P}2, 1<_{P}4, 1<_{P}3, 2<_{P}4\}$. In words, eventually 1 robot of type 1 visits $\ell_1$ before 2 robots of type 1 visits $\ell_3$, and the time that 1 robot of type 2 visits $\ell_2$ can be arbitrary.
%% \end{cexmp}
\section{MILP Solution to the Relaxed Automaton}\label{sec:solution}
We iterate over the poset in the  sorted set of posets $\{P_e\}$. Given a poset $P\in \{P_e\}$, let $X_{P}$ denote its base set. Note that each element in $X_P$ is an integer, which is also an edge in the NBA $\auto{subtask}^-$ and a subtask defined in Definition~\ref{defn:subtask}. In this section, we find a high-level plan that indicates  a sequence of waypoints that each robot need to visit by solving a MILP program inspired by vehicle routing problem; see also blocks 3-5 in Fig.~\ref{fig:overview}. The high-level plan produces a linear extension of the poset $P$ by sequentially satisfying vertex and edge labels of all elements in $P$. In this way,  this plan will generate a path in $\auto{subtask}^-$ that connects $v_0$ and $\vertex{accept}$.


\subsection{Construction of the routing graph}\label{sec:graph}
To leverage the MILP formulation, in this section, we construct a routing graph $\ccalG = (\ccalV_{\ccalG},\ccalE_{\ccalG})$ where each vertex represents a specific region that is associated with a specific literal in a specific label of a subtask in $X_P$. Each vertex/region in $\ccalV_\ccalG$ is visited by at most one robot during the whole process. Simultaneous visits of multiple vertices in $\ccalV_\ccalG$ by a fleet of robots  satisfy a literal, a clause, or a label. The time of visits reflects the precedence order among subtasks  Below, we first construct  the vertex set and then the edge set of $\ccalG$. Both constructions follow four layers of nested iterations, starting with the edges, then the labels, then the clauses, and finally the literals. The outline of the algorithm is shown in Alg.~\ref{alg:milpgraph}.  Fig.~\ref{fig:routing} demonstrates such a routing graph. An illustrative graph for task~\hyperref[task:i]{\it (i)}  is also shown in Fig.~\ref{fig:milp}.
\begin{algorithm}[!t]
      \caption{Construct the routing graph}
      \LinesNumbered
      \label{alg:milpgraph}
      \KwIn {Poset $P$}
      \Comment*[r]{Create the vertex set}
      Create the vertex set $\ccalV_{\text{init}}$ for initial locations \label{milp:init}\;
      \Comment*[r]{vertices for  labels}
      \For{$e = (v_1, v_2) \in X_P$ \label{milp:for}}{
        \If{$\gamma(v_1, v_2) \not= \top$ \label{milp:nottrue}}{
          \For{$\ccalC_p^\gamma \in \clause{\gamma} $\label{milp:clause}}{
            \For{$\ap{i}{j}{k,\chi} \in \mathsf{lits}(\ccalC_p^{\gamma})$\label{milp:ap}}{
              Create $i$ vertices \label{milp:i}\;
            }
          }
        }
          \If{$\gamma(v_1)\not= \top, \bot$ \label{milp:nottrue2}}{
            Create vertices by following lines~\ref{milp:clause}-\ref{milp:i} \label{milp:repeat}\;
          }

      }
      \Comment*[r]{Create the ege set}
      \For{$e = (v_1, v_2) \in X_P$ \label{milp:for2}}{
        \If{$\gamma(v_1, v_2) \not= \top$ \label{milp:e}}{
            \For{$\ccalC_p^\gamma \in \clause{\gamma} $\label{milp:clause2}}{
              \For{$\ap{i}{j}{k,\chi} \in \mathsf{lits}(\ccalC_p^{\gamma})$\label{milp:lits}}{
                $(i)$ Vertices of  initial robot locations \label{milp:i2}\;
                $(ii)$ Vertices of prior tasks \label{milp:ii}\;
                $(iii)$ Vertices associated with  $\gamma(v_1)$ \label{milp:iii}\;
              }
            }
        }
        \If{$\gamma(v_1) \not= \top,\bot$ \label{milp:nottrue3}}{
          %%   Create edges by following lines~\ref{milp:clause2}-\ref{milp:ii} \label{milp:repeat2}\;

          \If{$S_2^e= \emptyset$}{
            Create edges by following lines~\ref{milp:clause2}-\ref{milp:i2} \label{milp:repeati}\;
          }
          \ElseIf{\upshape $S_2^e\ne \emptyset$}{
            Create edges from vertices associated with subtasks in $S_2^e$  \label{milp:repeatii}\;
            \If{$X_{\prec_P}^e = \emptyset$ {\bf and} $X_{\|_P}^e \neq \emptyset$ }{
              Create edges from vertices associated with initial robot locations \label{milp:repeatiii}\;}
         }
        }
      }
\end{algorithm}


\subsubsection{Construction of the vertex set:}\label{sec:vertex} The vertex set of the routing graph  consiss of three parts: the first part is related to intial robot locations, the other two parts are associated with edge labels and vertex labels, respectively, in the sub-NBA $\auto{subtask}^-$.
\stepcounter{mycounter}
\paragraph{(\Alph{mycounter}$_1$) Vertices associated with initial locations:}\label{vertex:initial} First we create $n$ vertices, collected in the set $\ccalV_{\text{init}}\subseteq \ccalV_{\ccalG}$ such that each vertex points to the initial location $s^0_{r,j}$ of robot $[r,j]\in\ccalK_j, \forall j\in [m]$ [line~\ref{milp:init}, Alg.~\ref{alg:milpgraph}] (see vertices inside the blue circle in Fig.~\ref{fig:routing} and blue dots in Fig.~\ref{fig:milp}).

Next, we iterate over subtasks in $X_{P}$. Given a subtask $e = (v_1, v_2) \in X_{P}$, we construct new vertices for the  edge label $\gamma(v_1, v_2)$ and starting vertex label $\gamma(v_1)$, if they are neither $\top$ nor $\bot$. In Fig.~\ref{fig:routing}, there are three subtasks $e_1, e_2$ and $e_3$. Those vertices that correpond to the same subtask are surrounded by gray ellipses.

\paragraph{(\Alph{mycounter}$_2$) Vertices associated with the edge label of subtask $e$:}\label{vertex:edge} If $\gamma(v_1, v_2) \not= \top$, we operate on $\gamma(v_1, v_2) =  \bigvee_{p\in \ccalP} \bigwedge_{q \in \ccalQ_{p}} \ap{i}{j}{k,\chi}$ starting by iterating over clauses $\ccalC_p^{\gamma}$ in $\clause{\gamma}$, and then over literals in $\ccalC_p^\gamma$ [lines~\ref{milp:for}-\ref{milp:i}, Alg.~\ref{alg:milpgraph}].
The literal $\ap{i}{j}{k,\chi}\in $ $\mathsf{lits}^+(\ccalC_p^{\gamma})$ implies that $\ag{i}{j}$, that is, $i$ robots of type $j$,  should visit the target region $\ell_k$ simultaneously. Hence, we create $i$ vertices in $\ccalV_\ccalG$  that all point to region $\ell_k$. If $\ag{i}{j}$ visit these $i$ vertices simultaneously, one robot each vertex, then $\ap{i}{j}{k,\chi}$ is true Note that if $\chi\not=0$, additionally, the robots visiting these $i$ vertices should be the same as those visiting another $i$ vertices which are associated with a literal with identical non-zero connector, which will be ensured in the MILP formulation in~Section \ref{sec:milp}. See organge ellipses in Fig.~\ref{fig:routing} that surround vertices associated with the same edge labels and the partition of vertices associated with subtask $e_1$ based on clauses and literals; see also red, yellow, and green dots in Fig.~\ref{fig:milp} that correspond to some edge labels in~$\auto{subtask}^-$.

\begin{figure}[!t]
  \centering
  \includegraphics[width=0.8\linewidth]{routing_graph.pdf}
  \caption{Routing graph $\ccalG$. There are three subtasks $e_1, e_2$ and $e_3$. The temporal order is $e_1 \| e_2, e_1 \prec e_3, e_2 \prec e_3$.    Vertices that are associated with initial robot locations are inside the blue circle (see case~\hyperref[vertex:initial]{\it ($C_1$)}). Each gray ellipse surrounds vertices that are associated with the same subtask, most of which consist of two smaller ellipses, one including vertices associated with the the edge label (orange ellipse; see case~\hyperref[vertex:edge]{\it ($C_2$)}), the other including vertices associated the starting vertex label (green ellipse; see case~\hyperref[vertex:vertex]{\it ($C_3$)}).  Each smaller ellipse is divided into several parts (solid line, we only show the partition for subtask $e_1$), each part including vertices that associated with the same clause. Furthermore, each part is divided into smaller parts (dashed line), each smaller part including vertices that are associated with the same literal.
    Edges indicate that there are connected vertices between  ellipses. Blue, orange and green  edges represent that leaving vertices are from those associated with initial robot locations, from  prior subtask and from vertex labels of the same subtasks, respectively. There are orange edges between $e_1$ and $e_2$ in both directions since they are independent, and only single directed orange edges exist pointing to vertices associated with $e_3$ since it is the last one {(see cases~\hyperref[sec:b]{\it ($D_2$)} and~\hyperref[edge:vertex2]{\it ($E_2$)})}. There are blue edges pointing to vertex labels of $e_1$ and $e_2$ since they are independent and ahead of $e_3$  whereas there is no blue edge pointing to the vertex label of $e_3$ since $e_3$ occurs after $e_1$ and $e_2$ and its leaving vertices are associated with  edge labels of $e_1$ and $e_2$ (see cases~\hyperref[edge:vertex2]{\it ($E_2$)} and~\hyperref[edge:vertex3]{\it ($E_3$)}).  Note that no edges exist inside any ellipse, since vertices inside one ellipse will be visited at the same time.}
  \label{fig:routing}
\end{figure}
\paragraph{(\Alph{mycounter}$_3$) Vertices associated with the starting vertex label of subtask $e$:}\label{vertex:vertex} After the iteration over the edge label $\gamma(v_1, v_2)$ of subtask $e$ is complete, vertices in $\ccalV_\ccalG$ associated with the starting  vertex label $\gamma(v_1)$ can be constructed in the same manner if $\gamma(v_1)$ is neither $\top$ nor $\bot$ [lines~\ref{milp:nottrue2}-\ref{milp:repeat}, Alg.~\ref{alg:milpgraph}]. The green ellipses in Fig.~\ref{fig:routing} capture vertices that are associated with the same vertex labels, which are inside the same ellipses as their correponding edge labels. We do not create vertices for the end vertex label since the meaning of subtask $e$ is irrelevant to end vertex $v_2$. Furthermore, the vertices for $v_2$ will be created when it comes to other subtasks, since it can be the starting vertex of other subtasks.

Finally, repeating this process and iterating over subtasks in $X_{P}$ completes the construction of the vertex set $\ccalV_\ccalG$. Note that each vertex in $\ccalV_\ccalG\setminus \ccalV_{\text{init}}$ is associated with a literal of some subtask in $X_P$ and each literal of some subtask in $X_P$ is associated with multiple vertices in $\ccalV_\ccalG\setminus \ccalV_{\text{init}}$ and specifies the region and the robot type associated with these vertices.
To capture this correspondence, let $\ccalM^\ccalV_{e} : \ccalV_{\ccalG}\setminus \ccalV_{\text{init}} \to  X_{P} $ and $\ccalM^\ccalV_{\mathsf{lits}}  : \ccalV_\ccalG\setminus \ccalV_\text{init}  \to  \prod_{\mathsf{lits}} $  map a vertex in $\ccalV_\ccalG \setminus \ccalV_{\text{init}}$ to its associated subtask and literal, respectively, and $\ccalM^\mathsf{lits}_{\ccalV}:   \prod_{\mathsf{lits}}  \to  2^{\ccalV_\ccalG}$ and $\ccalM^\mathsf{cls}_{\ccalV} :  \prod_{\mathsf{cls}} \to  2^{\ccalV_\ccalG}$ map a literal and clause to the associated vertices, where $\prod_{\mathsf{lits}}$ and $\prod_{\mathsf{cls}}$ are the cartesian products $ X_{P} \times\{0, 1\} \times [|\ccalP|]  \times \ccalQ_p$ and $X_{P}\times \{0, 1\} \times[|\ccalP|]$, respectively, and 0, 1 represent the label type, 0 for vertex label and 1 for edge label, respectively. Furthermore, we define $\ccalM^{\ccalV}_\ccalL :  \ccalV_\ccalG  \to  \ccalL$ and $ \ccalM^{\ccalV}_\ccalK :  {\ccalV_\ccalG}  \to  \{\ccalK_j\}$ that map a vertex to its associated  region and robot type. {If $\chi\not=0$, we define  $\ccalM_{\gamma}^\chi: \mathbb{N}^+ \to 2^{X_{P}\times \{0,1\}}$ to map $\chi$ to all labels (vertex or edge labels) in $X_P$ that have literals with the same connector $\chi$}.

\begin{cexmp}[(Mappings for task {\it (i)})]
    The mappings in Fig.~\ref{fig:milp} regarding the vertex $\ell_2^{1}$ are:
    $\mathcal{M}_e^{\mathcal{V}}(\ell_{2}^{1})  = (v_1,v_2) = 3$ and $\mathcal{M}_{\mathsf{lits}}^{\mathcal{V}}(\ell_{2}^{1})  = ((v_1,v_2), 1, 1, 1)$ since the vertex $\ell_2^{1}$ corresponds to the first literal $\ap{2}{1}{2,1}$ of the first clause of the edge label of the subtask $(v_1, v_2)$ in $X_P$; see also Fig.~\ref{fig:subtask_prune}.  $\mathcal{M}_\mathcal{L}^{\mathcal{V}}(\ell_{2}^{1})  = \ell_2$  and $\mathcal{M}_\mathcal{K}^{\mathcal{V}}(\ell_{2}^{1})  = \mathcal{K}_1$ since the literal that $\ell_2^1$ corresponds to requires 2 robots of type 1 to visit region $\ell_2$. Furthermore,  the literal/clause-to-vertex mappings are:
    $\mathcal{M}^{\mathsf{lits}}_{\mathcal{V}}(((v_1,v_2), 1, 1, 1)) = \mathcal{M}^{\mathsf{cls}}_{\mathcal{V}}(((v_1,v_2), 1, 1))  = \{\ell_2^{1}, \ell_2^{2}\}$, since the literal $\ap{2}{1}{2,1}$ requires 2 robots to visit region $\ell_2$; $\mathcal{M}^{\mathsf{lits}}_{\mathcal{V}}(((v_1,v_4), 1, 1, 1)) = \mathcal{M}^{\mathsf{cls}}_{\mathcal{V}}(((v_1,v_4), 1, 1))  = \{\ell_4^{1}\}$ since the literal $\ap{1}{2}{4}$ requires 1 robot to visit region $\ell_4$. Finally, the connector-to-label mapping is: $\ccalM^{\chi}_{\gamma} (1)  = \{((v_1, v_2), 1), ((v_3, v_6), 1)\}$ since the connector 1 appears in the edge label of subtask $(v_1 ,v_2)$ and the edge label of subtask $(v_3, v_6)$.
   \end{cexmp}
\begin{figure}[t]
  \centering
  \includegraphics[width=0.7\linewidth]{milp.pdf}
  \caption{Routing graph $\ccalG$ for task~\hyperref[task:i]{\it (i)}. $s^0_{1,1}$, $s^0_{2,1}$ and $s^0_{3,1}$ are initial locations of 3 robots of type 1 and $s^0_{1,2}$ and $s^0_{2,2}$ are the initial locations of 2 robots of type 2. Red dots $\ell_{2}^{1}$ and $\ell_{2}^{2}$ correspond to the edge label $\ap{2}{1}{2,1}$ of element 3, i.e., edge $(v_1, v_2)$ in $X_P$; see Fig.~\ref{fig:subtask}, yellow dots $\ell_{3}^{1}, \ell_{3}^{2}$ correspond to the edge label $\ap{2}{1}{3,1}$ of element 4, and green dot $\ell_{4}^{1}$ corresponds to the edge label $\ap{1}{2}{4}$ of element 2. No dots correspond to vertex labels since all vertex labels are either $\top$ or $\bot$.  The edges from $\ell_2^{1}$ to $\ell_3^{1}$ and from $\ell_2^{2}$  to $\ell_3^{2}$ are due to $3 <_{P} 4$. }
    \label{fig:milp}
\end{figure}

\subsubsection{Construction of  the edge set:}\label{sec:edge_set} We follow the similar procedure for the construction of vertex set $\ccalV_\ccalG$ to construct the edge set $\ccalE_\ccalG$ which captures the precedence order in ${P}$, by iterating over $X_P$. For any subtask $e = (v_1, v_2) \in X_{P}$, if $\gamma(v_1, v_2) \not=\top$, we operate on $\gamma(v_1, v_2) =  \bigvee_{p\in \ccalP} \bigwedge_{q \in \ccalQ_{p}} \ap{i}{j}{k,\chi}$ starting by iterating over clauses $\ccalC_p^{\gamma}$ in $\clause{\gamma}$, and then over literals in $\ccalC_p^\gamma$ [lines~\ref{milp:for2}-\ref{milp:iii}, Alg.~\ref{alg:milpgraph}]. Consider the literal $\ap{i}{j}{k,\chi} \in \mathsf{lits}^+(\ccalC_p^{\gamma})$. Its associated $i$ vertices correspond to target region $\ell_k$ that should be visited by $i$ robots. We identify three types of leaving vertices in $\ccalV_\ccalG$ from where $i$ robots depart for region $\ell_k$ to satisfy this specific literal $\ap{i}{j}{k,\chi}$.
\stepcounter{mycounter}
\paragraph{(\Alph{mycounter}$_1$) Vertices associated with initial robot locations:}\label{sec:a} The initial vertices in $\ccalV_{\text{init}}$ that are associated with  robots of type $j$ are leaving vertices. We add an edge from each vertex associated with such an initial vertex to each vertex associated with this specific literal $\ap{i}{j}{k,\chi}$ (see blue edges in Fig.~\ref{fig:routing} and in~Fig.~\ref{fig:milp}), with a weight equal to the length of the shortest path from the initial location to the region the vertex corresponds to.
\paragraph{(\Alph{mycounter}$_2$) Vertices associated with prior subtasks:}\label{sec:b} Let $X^e_{<_{P}}$, $X^e_{\prec_{P}}$ and $X^e_{\|_{P}}$ denote the sets that collect subtasks in $X_{P}$ that are  smaller than, covered by, and incomparable to subtask $e$, respectively; see Section~\ref{sec:partial}. In words, $X^e_{<_{P}}$ contains subtasks in $X_P$ that should be completed prior to $e$, $X^e_{\prec_{P}}$ contains subtasks that can be completed right before $e$  and $X^e_{\|_{P}}$ constains subtasks in  $X^e_{<_P}$ that are independent from $e$. To find leaving vertices, we iterate over $S_1^e = X^e_{<_{P}} \cup X^e_{\|_{P}}$ which includes all subtasks that can be completed prior to $e$.
Given a subtask $e' = (v'_1, v'_2) \in S_1^e$, if its edge label $\gamma'(v'_1, v'_2) \not=\top$ (recall that we did not create vertices for $\top$ labels), we iterate all literals in $\gamma'$ by iterating over clauses in $\gamma'$. Specially, given a clause $\ccalC^{\gamma'}_{p'} \in \clause{\gamma'}$, for any literal $\ap{i'}{j'}{k',\chi'} \in\mathsf{lits}^+(\ccalC^{\gamma'}_{p'})$, if $j'=j$, then those vertices in $\ccalV_\ccalG$ associated with this literal are leaving vertices. If $i'<i$, we add $i\cdot  i'$ edges to $\ccalE_\ccalG$ by creating an edge from any vertex associated with $\ap{i'}{j'}{k',\chi'}$ to any vertex of $\ap{i}{j}{k,\chi}$. Otherwise, if $i' \geq  i$, i.e., at least $\ag{i}{j}$ are at region $\ell_k$, we randomly select $i$ from these $i'$ vertices and add $i$ one-to-one edges starting from these $i$ vertices and ending at the $i$ vertices associated with $\ap{i}{j}{k,\chi}$ (see orange edges in Fig.~\ref{fig:routing} and Fig.~\ref{fig:milp}). This is because there are at least $i$ homogeneous robots of type $j$ and of these only $i$ robots are required, if suffices to build $i$ one-to-one edges. Furthermore, if $\chi=\chi'\neq0$, then literals $\ap{i}{j}{k,\chi}$ and $\ap{i'}{j'}{k',\chi'}$ must have the same number of vertices if formula $\phi$ is a valid formula (see Definition~\ref{defn:valid}). Building $i$ one-to-one edges can guarantee the same  $i$ robots satisy these two literals. Finally, since each region may span multiple cells, the weight of these edges is set as the length of the shortest path from region  $\ell_{k'}$ to $\ell_k$.

After creating edges in the graph $\ccalG$ associated with the edge label  $\gamma'(v'_1,v'_2)$ of $e'$, we identify  leaving vertices  among the vertices associated with the starting vertex label $\gamma(v'_1)$ of $e'$ and build edges in the same manner. %% \red{This simpilication will be addressed in Section~\ref{sec:solution2mapp}}.




%% In what follows, we investigate the following cases depending on the value of $\chi$ in $\ap{i}{j}{k,\chi}$.
%% \paragraph{\quad (a) $\chi = 0$:}\label{sec:ba} When $\chi=0$, no restriction is imposed on robots of the specified type about which robots should visit the region.  Given a clause $\ccalC^{\gamma'}_{p'} \in \clause{\gamma'}$, for any literal $\ap{i'}{j'}{k',\chi'} \in\mathsf{lits}^+(\ccalC^{\gamma'}_{p'})$, if $j'=j$, then those vertices in $\ccalV_\ccalG$ associated with this literal are starting locations. If $i'<i$, we add $i\cdot  i'$ edges to $\ccalE_\ccalG$ by creating an edge from any vertex associated with $\ap{i'}{j'}{k',\chi'}$ to any vertex of $\ap{i}{j}{k,\chi}$. Otherwise, if $i' \geq  i$, i.e., at least $\ag{i}{j}$ are at region $\ell_k$, we randomly select $i$ from these $i'$ vertices and add $i$ one-to-one edges starting from these $i$ vertices and ending at the $i$ vertices associated with $\ap{i}{j}{k,\chi}$ (see orange edges in Fig.~\ref{fig:routing} and Fig.~\ref{fig:milp}). This is because there are more than $i$ homogeneous robots of type $j$ and of these only $i$ robots are required, if suffices to build $i$ one-to-one edges. Furthermore, since each region may span multiple cells, the weight of these edges is the length of the shortest path from region  $\ell_{k'}$ to $\ell_k$. %% \red{This simpilication will be addressed in Section~\ref{sec:solution2mapp}}.
%%   \paragraph{\quad (b) $\chi \not=0$:}\label{sec:bb} In this case, the same group $\ag{i}{j}$ are required to visit several regions sequentially.
  %% Given a clause $\ccalC^{\gamma'}_{p'} \in \clause{\gamma'}$, for any literal $\ap{i'}{j'}{k',\chi'} \in\mathsf{lits}^+(\ccalC_{\gamma'}^{p'})$ with $j'=j$ and $\chi'=\chi$, there are $i'=i$ vertices associated with this literal. In this case, we add $i$ one-to-one edges starting from these $i'$ vertices and ending at the $i$ vertices associated with $\ap{i}{j}{k,\chi}$.

\paragraph{(\Alph{mycounter}$_3$) Vertices associated with $\gamma(v_1)$ of $e$:}\label{sec:c} When the iteration over $S_1^e$ is over, we identify leaving vertices  among the vertices associated with the starting vertex label  $\gamma(v_1)$ of the current subtask $e$ following the  procedure ~\hyperref[sec:b]{\it ($D_2$)} for the prior subtasks, since $\gamma(v_1)$  becomes true before $\gamma(v_1, v_2)$ (see green edges in Fig.~\ref{fig:routing}).

So far we have constructed leaving vertices corresponding to the literal $\ap{i}{j}{k,\chi}$ in $\mathsf{lits}^+(\ccalC_p^{\gamma})$ [lines~\ref{milp:i2}-\ref{milp:iii}, Alg.~\ref{alg:milpgraph}]. We need to continue construct leaving vertices for all other literals in~$\mathsf{lits}^+(\ccalC_p^{\gamma})$ [line~\ref{milp:lits},  Alg.~\ref{alg:milpgraph}] and other clauses in $\clause{\gamma}$ [line~\ref{milp:clause2},  Alg.~\ref{alg:milpgraph}].
After constructing all edges pointing to vertices associated with literals in the edge label $\gamma(v_1, v_2)$ of the current subtask $e$ [line~\ref{milp:e},  Alg.~\ref{alg:milpgraph}], we next construct  edges pointing to vertices associated with literals in the starting vertex label $\gamma(v_1)$ if it is  neither $\top$ nor $\bot$, by identifying leaving vertices among vertices associated with initial robot locations and locations of prior subtasks,


Specifically, let $S_2^e = X_{\prec_P}^e \cup X_{\|_P}^e$ be the set that collects all subtasks that can occur immediately prior to subtask $e$, that is, the satisfaction of edge labels  of subtasks in $S_2^e$  can directly lead to the starting vertex $v_1$ of $e$.
\stepcounter{mycounter}
\paragraph{(\Alph{mycounter}$_1$) If $S_2^e = \emptyset$:}\label{edge:vertex1} The subtask $e$ should be the first one among all to be completed. Thus, $v_1$ is identical to $v_0$. In this case,  we only identify leaving vertices that are associated with initial robot locations, as in case~\hyperref[sec:a]{\it ($D_1$)} [lines~\ref{milp:repeati},  Alg.~\ref{alg:milpgraph}].

\paragraph{(\Alph{mycounter}$_2$) If $S_2^e \neq \emptyset$:}\label{edge:vertex2}  We  identify leaving vertices associated with prior subtasks in $S_2^e$. Given a subtask $e' = (v_1', v_2') \in S^e_2$, for the edge label $\gamma'$ of $e'$, we find all clauses $\ccalC_{p'}^{\gamma'} \in  \clause{\gamma'}$ such that, for the considered  clause $\ccalC_p^\gamma \in \clause{\gamma} $ in the vertex label of subtask $e$, its corresponding clause $(\ccalC_p^\gamma)_{\phi}$ in $\autop$ is implied by  their corresponding clauses $(\ccalC_{p'}^{\gamma'})_{\phi}$ in $\autop$. Next, for each literal $\ap{i}{j}{k,\chi} \in \mathsf{lits}(\ccalC_p^\gamma)$, we create $i$ one-to-one edges starting from those $i$ vertices that are associated with the counterpart  of literal  $\ap{i}{j}{k,\chi}$ in the found clause  $\ccalC_{p'}^{\gamma'} \in \clause{\gamma'}$  and ending at the $i$ vertices associated with $\ap{i}{j}{k,\chi}$ [lines~\ref{milp:repeatii},  Alg.~\ref{alg:milpgraph}]. We create such one-to-one edges based on the condition~\hyperref[cond:d]{\it (d)} regarding strong implication in Definition~\ref{defn:run} and condition~\hyperref[asmp:b]{\it (b)} in Assumption~\ref{asmp:same}. That is,  the satisfied clause in the edge label strongly implies the satisfied clause in the end vertex label, and the fleet of robots satisfying the clause in the vertex label comes from the fleet of robots satisfying the clause in the incoming edge label.
.

\paragraph{(\Alph{mycounter}$_3$) If $X_{\prec_P}^e = \emptyset$ and $X_{\|_P}^e \neq \emptyset$:}\label{edge:vertex3} In this case, the subtask $e$ can be the first one among all to be completed, then  its starting vertex label $\gamma(v_1)$  should be satisfied at the beginning, but leaving vertices associated with other edge labels can not achieve this, since these edges are enabled after subtask $e$. Therefore, for the vertex label $\gamma(v_1)$, we additionally identify leaving vertices pointing to initial robot locations, as in case~\hyperref[sec:a]{\it ($D_1$)} [lines~\ref{milp:repeatiii},  Alg.~\ref{alg:milpgraph}]. %% For instance, in Fig.~\ref{fig:id}, subtasks $(v_1, v_4)$ and $(v_1, v_2)$ are independent. If $(v_1, v_4)$ is the first one to be completed and $(v_4, v_3)$ follows, then, the leaving vertices pointing to vertices associated with  $\gamma(v_1)$ should point to the initial locations, and the leaving vertices pointing to vertices associated with $\gamma(v_4)$ should correspond to the incoming edge label $\gamma'$.
Note that, if $X_{\prec_P }^e \neq \emptyset$,  there is no need to find such leaving vertices that point to initial locations since subtask $e$ is impossible to occur first, and its starting vertex label is strongly implied by the incoming edge label.

%% \paragraph{(c) If $S_2^e \neq \emptyset$ and $v_1 = \vertex{accept}$:}\label{edge:vertex3} We identify leaving vertices among vertices associated with initial robot locations (as in case ~\hyperref[sec:a]{\it (i)} ) and locations of prior subtasks (as in case ~\hyperref[sec:a]{\it (ii)}), [lines~\ref{milp:repeatii},  Alg.~\ref{alg:milpgraph}], since by condition~\hyperref[cond:d]{\it (d)} in the Definition~\ref{defn:run}, there is no strong implication requirement for the accepting vertex.



Finally,  when the iteration over all subtasks in $X_{P}$ is over, we finish the construction of  the edge set $\ccalE_\ccalG$ [line~\ref{milp:for2},  Alg.~\ref{alg:milpgraph}].


 \subsection{Formulation of the MILP}\label{sec:milp}
 In this section, as indicated by block 4 in Fig.~\ref{fig:overview}, we propose a MILP-based method inspired by the vehicle routing problem (VRP) with temporal constraints~\cite{bredstrom2008combined} to obtain a high-level plan that induce a simple path in $\auto{subtask}^-$ connecting $v_0$ and $\vertex{accept}$. In the VRP, a fleet of vehicles traverse a given set of customers such that all vehicles depart from and return to the same depot and each customer is visited by exactly one vehicle. Normally, a weighted graph is built first with vertices corresponding to the customers and the depot, edges corresponding to the paths the vehicles can travel along, and edge weights representing the the travel cost, e.g., energy and time. Then,  a MILP-based model can be formulated to solve the problem. Compared to the VRP, the MRTA-LTL problem is significantly more complex. First, robots are not required  to return to their initial locations, instead there may exist robots that need to execute the task forever due to the  ``always'' operator. Second, there may exist  labeled regions that do not need to be  visited at all and others that need to be visited exactly once,  more than once, or even infinitely  many times. Finally, temporal constraints may exist  among robots. For example, robots that execute a cooperative subtask together are subject to synchronization constraints and robots that execute two different subtasks can be subject to precedence constraints. In what follows, we formulate an MILP to solve this MRTA-LTL problem.


Given the routing graph $\ccalG$, the robots move along $\ccalG$ to drive the transition in~$\auto{subtask}^-$ from $v_0$ to $\vertex{\text{accept}}$. To formulate the MILP, we define two types of variables: the routing variables $x_{uvr} \in\{0, 1\}$ and the scheduling variables $t^-_{vr}, t^+_{vr} \in \mathbb{N}$, where $x_{uvr}=1$  if robot  $r\in \ccalM^\ccalV_\ccalK(v)$ traverses the edge $(u,v) \in \ccalE_\ccalG$, and $t^-_{vr}, t^+_{vr}$ are times when robot $r$ should arrive at and is allowed to leave from vertex $v \in \mathcal{V}_\ccalG$. We assume that robot $r$ is still at vertex $v$ at departure time $t^+_{vr}$. Since the satisfaction of the edge label is instantaneous, if $v \in \ccalV_\ccalG$ is associated with an edge label, we have
  $t_{vr}^- = t_{vr}^+$, which means that the robot is allowed to leave at the next time instant. As for the vertex label, we have $t_{vr}^-  \leq t_{vr}^+$, which means that the robot should stay where it is to wait for the satisfaction of the corresponding edge label. Below, we describe  different types of constraints and the objective function of the proposed MILP.
\subsubsection{Routing constraints:} These constraint restrict the flow when the robot traverses between connected vertices in $\ccalV_\ccalG$. Specifically, $\forall\, v \in \ccalV_\ccalG\setminus\ccalV_{\text{init}}$, the constraint that  $v$ is visited by at most one robot belonging to type $\ccalM^\ccalV_{\ccalK}(v)$ can be encoded as
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}
   & \sum_{u:(u,v)\in \ccalE_\ccalG} \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} x_{uvr}  \leq 1, \;\forall\, r \in \ccalM^\ccalV_{\ccalK}(v), \label{eq:1}
\end{align}
\endgroup
which does not take the strict equality since the clause that vertex $v$ is associated with can be false, so there is no need to visit this vertex. Moreover, the flow constraint on a vertex, $\forall \,v \in \ccalV_\ccalG\setminus\ccalV_{\text{init}}$, that the inflow is no less than the outflow, which says that the robot can remain idle if it is not assigned a subtask, can be encodes as
 \begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}
& \sum_{w:(v,w)\in \ccalE_\ccalG} x_{vwr}   \leq  \sum_{u:(u,v)\in \ccalE_\ccalG} x_{uvr}, \;\forall\, r \in \ccalM^\ccalV_{\ccalK}(v). \label{eq:2}
\end{align}
\endgroup
Then, $\forall \,v \in \ccalV_{\text{init}}$, the initial conditions of~\eqref{eq:2} are
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{subequations}\label{eq:2.5}
  \begin{align}
    & \sum_{w:(v,w)\in \ccalE_\ccalG} x_{vwr}  \leq 1, \;\text{if}\; r = r_v \in \ccalM^\ccalV_{\ccalK}(v), \label{eq:2.5a}\\
    & \sum_{w:(v,w)\in \ccalE_\ccalG} x_{vwr}  = 0, \;\forall r \in \ccalM^\ccalV_{\ccalK}(v)\setminus \{ r_v\}, \label{eq:2.5b}
  \end{align}
\end{subequations}
\endgroup
where $r_v$ refers to the specific robot at the initial location $\ccalM^\ccalV_{\ccalL}(v)\in s^0$ if $v \in \ccalV_{\text{init}}$.
 \subsubsection{Scheduling constraints:} These capture the timing relation on a vertex or between visitation of two connected vertices. First, we require positivity of the scheduling variables, $\forall \, v \in \ccalV_\ccalG$, i.e.,
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align} \label{eq:3}
  0 \leq t_{vr}^{-}, t_{vr}^+ \leq M_{\text{max}} \sum_{u:(u,v)\in \ccalE_\ccalG} x_{uvr}& , \forall r\in \ccalM^\ccalV_{\ccalK}(v),
\end{align}
\endgroup
where $M_{\text{max}}$ is a large positive integer. The constraint~\eqref{eq:3} implies that $t_{vr}^- = t_{vr}^+ = 0$ if $v$ is not visited by robot $r$. The initial condition of~\eqref{eq:3} is
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}\label{eq:3.5}
   t_{vr}^- = t_{vr}^+ = 0,  \quad   \;\forall r \in \ccalM^\ccalV_{\ccalK}(v), \;\forall\, v \in \ccalV_{\text{init}}.
\end{align}
\endgroup
The scheduling constraints between visitation of two connected vertices considering the travelling time, $\forall\, r\in \ccalM^\ccalV_{\ccalK}(v),\, \forall \,(u,v)\in \ccalE_\ccalG$, are
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{subequations}\label{eq:4}
  \begin{align}
    & \hspace{-0.6em} t_{ur}^+ +  T^*_{uv} x_{uvr} \leq  \,t_{vr}^- + M_{\text{max}} (1 - x_{uvr}), \nonumber \\
    &  \pushright{\text{if}\;  u\in \ccalV_{\text{init}}\; \text{or}\; u<_{P}v \; \text{or}\; (u,v)\in X_P,} \label{eq:4b} \\
    & \hspace{-0.6em}t_{ur}^+  + (T^*_{uv} + 1)  x_{uvr}  \leq t_{vr}^- + M_{\text{max}} (1 - x_{uvr}),  \nonumber \\
    & \pushright{\text{if}\; u\|_{P} v,} \label{eq:4a}
  \end{align}
\end{subequations}
\endgroup
where %% $M_{\text{min}}$ is a small positive integer,
$T^*_{uv}$ is the travelling time from $u$ to $v$, $u \in \ccalV_{\text{init}}$ means the starting vertex $u$ is the initial vertex in case~\hyperref[sec:a]{{\it ($D_1$)}},~\hyperref[edge:vertex1]{{\it ($E_1$)}} and~\hyperref[edge:vertex3]{{\it ($E_3$)}}, $u \|_{P} v$ and $u<_{P} v$ mean that the subtask $\ccalM^\ccalV_{{e}}(u)$ is incomparable to or smaller than $\ccalM^\ccalV_e(v)$, which corresponds to the cases~\hyperref[sec:b]{{\it ($D_2$)}} and~\hyperref[edge:vertex2]{{\it ($E_2$)}} where $u$ is associated with prior substasks, and $(u,v)\in X_P$ refers to case~\hyperref[sec:c]{{\it ($D_3$)}} where $u$ is associated with the vertex label and $v$ is associated with the edge label of the same subtask. We set $T^*_{uv}$ as the shortest travelling time between two regions. When $x_{uvr}=1$, constraint~\eqref{eq:4b} becomes $t_{ur}^+  + T^*_{uv}  \leq t_{vr}^-$ and constraint~\eqref{eq:4a} becomes $t_{ur}^+  + T^*_{uv} + 1   \leq t_{vr}^-$. Because $T^*_{uv} \geq 0$, constraints~\eqref{eq:4} ensure that $t_{vr}^-$ should be no less than $t_{ur}^+$ if $x_{uvr}=1$. Note that a cycle in $\ccalG$ must include a pair of incomparable vertices, since all comparable vertices constitute a chain. Constraint~{\eqref{eq:4a} avoids cycles in $\ccalG$ where all vertices correspond to the same region. E.g., consider such a cycle $u_1,u_2,\ldots, u_c, u_1$. Without  constraint~\eqref{eq:4a}, zero travelling time will be exploited by constraints~\eqref{eq:1},~\eqref{eq:2} and~\eqref{eq:4b}, generating a solution $x_{u_1 u_2 r} = ,\ldots,=x_{u_c u_{1} r}= 1$ for a robot $r$, without this robot actually visiting any vertex from its initial location.  Constraint~\eqref{eq:4a} is functionally similar to the subtour elimination constraint in vehicle routing problems which prevents any solution that consists of a disconnected tour. We leverage a  term 1 to ensure that time increases along the edge that connects incomparable vertices, thus preventing the visitation of a cycle.

  \subsubsection{Logical constraints:}\label{sec:labelconstraints} These encode the logical relation between labels, clauses and literals, and the realization of literals.
                {Given a subtask $e\in X_P$, every vertex or edge label  $\gamma  = \bigvee_{p\in \ccalP} \bigwedge_{q\in \ccalQ_p} \ap{i^q}{j^q}{k^q,\chi^q}$ (neither $\top$ nor $\bot$) is true as long as one of its clauses is true.  To this end, we associate each clause  $\ccalC_{p}^{\gamma} \in \clause{\gamma}$ with a binary variable $b_p$ such that $b_p=1$ if $\ccalC_{p}^{\gamma}$ is true. Hence, $\gamma$ being true can be encoded as
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}\label{eq:c}
   \sum_{p  \in \ccalP} b_p = 1.
\end{align}
\endgroup
That is, one and only one clause is true, which is justified by the condition~\hyperref[asmp:a]{\it (a)} in  Assumption~\ref{asmp:same} that the clause of a vertex label that is satisfied does not change. The logical relation, between a clause and its literals, that the satisfaction of the clause is equivalent to the satisfaction of all its literals, can be encoded as
\begingroup\makeatletter\def\f@size{9}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}
 \!\!\!  \left. \left[ \sum_{q\in \ccalQ_p} \sum_{v \in \ccalM^\mathsf{lits}_{\ccalV}(e,0|1,p,q)} \sum_{u: (u,v) \in \ccalE_\ccalG} \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} x_{uvr} \right] \middle/ {\sum_{q\in \ccalQ_p} i^q} \right.= b_p, \label{eq:6}
\end{align}
\endgroup
which also bridges the routing variables $x_{uvr}$ with the logical variables $b_p$. In words, if $b_p=1$, then every vertex corresponding to the $p$-th clause should be visited by one robot.
{Let $$z_{q} = \sum_{v \in \ccalM^\mathsf{lits}_{\ccalV}(e,0|1,p,q)} \sum_{u: (u,v) \in \ccalE_\ccalG} \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} x_{uvr}$$ be the inner summation. If $b_p=1$, then all literals in $\ccalC_p^{\gamma}$ are true. In this case, for the $q$-th literal $\ap{i^q}{j^q}{k^q,\chi^q} \in \mathsf{lits}^+(\ccalC_p^\gamma)$, all $i^q$ vertices in ${\ccalM^\mathsf{lits}_{\ccalV}(e,0|1,p,q)}$ should be visited, so $\sum_{u: (u,v) \in \ccalE_\ccalG} \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} x_{uvr} = 1$ for each vertex $v \in {\ccalM^\mathsf{lits}_{\ccalV}(e,0|1,p,q)}$, and therefore $z_{q}= i^q$, and the left side of constraint~\eqref{eq:6} becomes
  \begin{align*}
   \left. \sum_{q\in \ccalQ_p} z_q \small/ {\sum_{q\in \ccalQ_p} i^q} = {\sum_{q\in \ccalQ_p} i^q} \small/{\sum_{q\in \ccalQ_p} i^q} \right. = 1.
  \end{align*}
If $b_p=0$, all $x_{uvr}$ in constraint~\eqref{eq:6} equal 0, that is, no vertices need to be visited. Combining constraints~\eqref{eq:3} and~\eqref{eq:6}, $\sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t^-_{vr}$ equals 0 if the  clause that $v$ corresponds to is false. That is, a robot remains idle if it is not responsible for the satisfaction of any clause. Furthermore, constraints~\eqref{eq:1} and~\eqref{eq:6} imply that, if visited, each vertex is visisted by only one robot the whole time, which aligns with the Assumption~\ref{asmp:same} that same fleet of robots satisfy the same clause.

    Note that the logical relation in constraint~\eqref{eq:6} only encodes that some vertices should be visited sometime to satisfy the literals, next we encode the synchronization constraint that, if the clause $\ccalC_p^\gamma$ in the edge label $\gamma$ is true, all vertices in~$\ccalM^\mathsf{cls}_\ccalV(e, 1,p)$ should be visited at the same time, since the satisfaction of edge labels is instantaneous.
      We define the pairwise vertex set induced from the clause $\ccalC_p^\gamma$ as  $\ccalV_{\gamma, p}^{\text{sync}} = \{(u,v)\,|\, u, v\in \ccalM^\mathsf{cls}_\ccalV(e,1,p), u\not= v \}$. If $b_p=1$, visiting any pair in $\ccalV_{\gamma, p}^{\text{sync}}$ simultaneously is encoded as
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}
  & \quad\quad  \sum_{r\in \ccalM^\ccalV_{\ccalK}(u)} t_{ur}^-  = \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t_{vr}^- , \quad\forall (u,v) \in \ccalV_{\gamma, p}^{\text{sync}}.\label{eq:7}
\end{align}
\endgroup





\subsubsection{Temporal constraints:}\label{sec:temporal} We first introduce the notion of the activation and completion time of a subtask. Then, given the subtask $e$, there are three types of temporal constraints regarding the activation and completion time,  within the subtask or between subtasks.
\begin{defn}[(Activation and completion time of a subtask or its starting vertex label)]
Given a subtask $e = (v_1, v_2)$, we define the  activation time of a subtask (or of its starting  vertex label) as when its vetex label $\gamma(v_1)$ turns true, and the completion time  of a subtask (or of its starting vertex label) as when its edge label $\gamma(v_1, v_2)$ becomes true (or the last time its starting vertex label $\gamma(v_1)$ is true). The span of a subtask (or its starting vertex label) starts from the activation time and ends at the completion time.
\end{defn}
\paragraph{(i) Temporal constraints on one subtask:}\label{sec:onesubtask} These capture the containment constraints that the completion time of a subtask should lie in the span of the associated vertex label, or exactly one time instant later than the completion of its vertex label. Intuitively, the ``avoid'' part should be maintained until the ``reach'' part is realized.

For this, define variable  $t_e$ as the completion time of the subtask $e$, i.e., time when its edge label  becomes true. We have  that
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}\label{eq:edgetime}
  t_e = \sum_{p\in \ccalP} \sum_{r\in \ccalM^\ccalV_{\ccalK}(v_p)}t_{v_p r}^-,
\end{align}
\endgroup
where $v_p$ is randomly selected from $\ccalM^\mathsf{cls}_\ccalV(e,1,p)$ due to constraints~\eqref{eq:c} and~\eqref{eq:7} that only one clause is true and all corresponding vertices are visited at the same time.

When the starting vertex $v_1$ has a self-loop, and its label $\gamma(v_1)$ is not  $\top$ (otherwise, there are no associated vertices in $\ccalG$), the containment relation, $\forall\, \ccalC_p^{\gamma} \in \clause{\gamma(v_1)}$ and $\forall v \in \ccalM^\mathsf{cls}_\ccalV(e,0,p)$, can be encoded as
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
  \begin{align}
 \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t_{vr}^-   \leq  t_e \leq
    \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t_{vr}^+ + 1  + M_{\text{max}} (1 - b_{p}). \label{eq:17}
  \end{align}
  \endgroup
  If $b_p=0$, then no robot visits vertex $v$ according to constraint~\eqref{eq:6}, so~$ \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t_{vr}^- = 0 \leq t_e$, i.e., the left inequality holds. The right one holds obviously. Only when $b_p=1$, does constraint~\eqref{eq:17} come into effect. Note that constraint~\eqref{eq:17} implies that the span of the subtask is not necessarily equal to the span of the associated vertex label.

  On the other hand, when the starting vertex $v_1$ does not have a self-loop, we have that $v_1$ is identical to the initial vertex $v_0$. Recall that in step~\hyperref[prune:infeasible]{\it (7)} in Section~\ref{sec:prune}, we remove all vertices without self-loops except initial and accepting vertices. Hence, in $\auto{subtask}^-$, only $v_0$ and $\vertex{accept}$ are allowed to not have self-loops but $\vertex{accept}$ can not be the starting vertex; see also Fig.~\ref{fig:prefix}. Therfore, $v_1 = v_0$. Moreover, if $\gamma(v_0) = \bot$, the edge label of subtask $e$ should be satisfied at time instant 0 to activate the progression, i.e.,
  \begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
  \begin{align}
 t_e = 0. \label{eq:tis0}
  \end{align}
  \endgroup


\paragraph{(ii) Temporal constraints on the completion of two sequential subtasks:}\label{sec:constraintonedge}
This imposes the precedence constraint that subsequent subtasks should be completed after the completion of the prior subtasks.   Given the current subtask $e$, we consider its prior subtasks in the set $X^e_{\prec_{P}}$, that is, subtasks that are covered by $e$, other than a larger set $X^e_{<_{P}}$ due to the transitivity of the partial order.
If $X^e_{\prec_{P}}$ is non-empty, we iterate over subtasks in it.  Given $e' \in X^e_{\prec_{P}}$, the fact that the substask $e'$ is completed before the current substask $e$ can be encoded as
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}\label{eq:12}
  t_{e'} +  1  \leq t_e, \; \forall \, e' \in X_{\prec P}^e,
\end{align}
\endgroup
where the term 1 excludes the case where two edge labels become true simultaneously, violating the precedence order.

\paragraph{(iii)  Temporal constraints on  the  completion of the current substask and the activation  of subsequent substasks:}
These capture the precede constraints that the completion of the current subtask $e$ should be at most one time instant earlier than the activation of the subtask immediately after it. Otherwise, the sub-NBA induced from the poset $P$ will be trapped at $e$ if there is no activated subtask immediatedly after it. To capture this, we define $|X_P|\cdot |X_P -1|$ binary variables $b_{ee'}$ for any two differnt subtasks  $e, e' \in X_P$,  such that $b_{ee'}=1$  if it is subtask $e'$ that occurs immediately after subtask $e$. Furthermore, we define  $S_3^e = X^e_{\succ_{P}} \cup X^e_{\|_{P}}$ that collects all subtasks whose activation can immediately follow the completion of subtask $e$.  In what follows, we proceed based on whether $ X^e_{\succ_{P}} \neq \emptyset$.
\stepcounter{mycounter}
\paragraph{(\Alph{mycounter}$_1$) $ X^e_{\succ_{P}} \neq \emptyset$:}\label{activation:a} In this case, there must exist a subtask that occurs after $e$. Then, the  constraint that there exists a subtask in $S_3^e$ that occurs immediately after it can be encoded as
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}\label{eq:bafter}
 \sum_{e'\in  S_3^e} b_{ee'} = 1.
\end{align}
\endgroup
If the subtask $e'$ occurs immediately  after subtask $e$, then it should be completed after subtask $e$, that is,
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}\label{eq:after}
  t_e + 1 \leq  t_{e'} + M_{\text{max}} (1 - b_{ee'}),\; \forall\, e' \in S_3^e.
\end{align}
\endgroup
%% Note that $t_e$ can not be equivalent to $t_{e'}$, otherwise, when subtask $e$ is completed, it is still possible that no subtask is being or about to be activated  at the next time instant (subtask $e'$ has been completed).
To establish the transition between subtasks, the subtask $e'$ that occurs immediately  after subtask $e$ should be activated at most one time instant later than the completion of $e$. That is,  if $\gamma(e')$ is not $\top$, then $\forall\, e' \in S_3^e, \forall \, \ccalC_p^{\gamma(e')} \in \clause{\gamma(e')} , \forall \,v \in \ccalM^\mathsf{cls}_\ccalV(e',0,p)$, we have that
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}\label{eq:20}
  & \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t_{vr}^-   \leq t_{e}  + 1 + M_{\text{max}} (1 - b_{ee'}).
\end{align}
\endgroup
If $\gamma(e')=\top$, we can view that subtask $e'$ is activated since the beginning, thus, constraint~\eqref{eq:20} is satisfied trivially.

\paragraph{(\Alph{mycounter}$_2$) $ X^e_{\succ_{P}} = \emptyset$:}\label{activation:b} In this case, if subtask $e$ is completed after  subtasks in  $X_{\|_P}^e$, then it is the last  subtask  to be completed in  $X_P$. Thus, there is no subtask to be activated any more. Otherwise, if subtask $e$ is not the last subtask, then there exists a subtask that occurs after $e$, same as the case~\hyperref[activation:a]{\it ($F_1$)}. To determine whether subtask $e$ is the last subtask, we define $|X_P|\cdot |X_P -1|$ auxilarybinary variables $b_{e}^{e'}$ for any two differnt subtasks  $e, e' \in X_P$,  such that $b_{e}^{e'}=1$  iff $t_{e} > t_{e'}$, that is, iff subtask $e$ is completed after $e'$. This implication can be encoded as, $\forall e, e' \in X_P $ and $e\neq e'$,
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{subequations}\label{eq:diff}
  \begin{align}
    b_e^{e'} + b_{e'}^e &  = 1, \label{eq:diff_a}\\
  M_{\text{max}} (b_{e}^{e'} - 1) \leq t_e -  t_{e'} & \leq M_{\text{max}} b_{e}^{e'} - 1. \label{eq:diff_b}
\end{align}
\end{subequations}
\endgroup
Constraints~\eqref{eq:diff} requires both that  no two subtasks are completed at the same time and that $b_e^{e'}=1$ implies $t_e > t_{e'}$. Assuming $t_e = t_{e'}$. According to constraint~\eqref{eq:diff_b}, we get that $b_e^{e'}=b_{e'}^{e}=1$, which violates the constraint~\eqref{eq:diff_a}. Although independent subtasks can occur simultaneously, we break the tie so that the solution to the MILP formulation gives rise to a simple path in $\auto{subtask}^-$ that is a linear extension of the poset $P$.%%  Then, that $b_e^{e'}$ implying $t_e > t_{e'}$  can be encoded as
%% \begingroup\makeatletter\def\f@size{10}\check@mathfonts
%% \def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
%% \begin{align}
%%   M_{\text{max}} (b_{e}^{e'} - 1) \leq t_e -  t_{e'} \leq M_{\text{max}} b_{e}^{e'} - 1,
%% \end{align}
%%   \endgroup

%% We first require that no two subtasks are completed at the same time, i.e.,
%% \begingroup\makeatletter\def\f@size{10}\check@mathfonts
%% \def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
%% \begin{align}\label{eq:diff}
%%  b_e^{e'} + b_{e'}^e = 1,\; \; \forall \, e, e' \in X_P, e\neq e'.
%% \end{align}
%%   \endgroup
%% Although independent subtasks can occur simultaneously, we break the tie so that the solution to the MILP formulation gives rise to a simple path in $\auto{subtask}^-$ that is a linear extension of the poset $P$. Then, that $b_e^{e'}$ implying $t_e > t_{e'}$  can be encoded as
%% \begingroup\makeatletter\def\f@size{10}\check@mathfonts
%% \def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
%% \begin{align}
%%   M_{\text{max}} (b_{e}^{e'} - 1) \leq t_e -  t_{e'} \leq M_{\text{max}} b_{e}^{e'} - 1,
%% \end{align}
%%   \endgroup
 %% where the terms $-1$ on the right side is used to enforce $b_{e}^{e'}=1$ if $t_e = t_{e'}$.
 Furthermore, we define $z = |X^e_{\|_{P}}|$. Observe that, for $e' \in X^e_{\|_{P}} $, the term $z -  \sum_{e' \in X^e_{\|_{P}}  } b_{e}^{e'} = 0$ if $e$ is the last completed task, otherwise  positive. If subtask $e$ is not the last subtask, there should be a subtask in $X^e_{\|_{P}}$ that occur immediately after $e$, which can be encoded as
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{subequations}\label{eq:afterparallel}
  \begin{align}
  \sum_{e' \in X_{\|_P}^e} b_{ee'} & \le 1,\label{eq:afterparallel_a}\\
  z - \sum_{e' \in X^e_{\|_{P}}  } b_{e}^{e'} - M_{\text{max}}  \sum_{e' \in X_{\|_P}^e} b_{ee'} &  \leq 0, \label{eq:afterparallel_b} \\
 % \sum_{e' \in X_{\|_P}^e} b_{ee'} & \leq 1.
  %% M_{\text{max}} ( \sum_{e' \in X^e_{\|_{P}}  } b_{e}^{e'} -   z ) & \leq
  \sum_{e' \in X_{\|_P}^e} b_{ee'} - M_{\text{max}}(z -  \sum_{e' \in X^e_{\|_{P}}  } b_{e}^{e'}) & \leq0 . \label{eq:afterparallel_c}
\end{align}
\end{subequations}
\endgroup
If subtask $e$ is completed after  subtasks in  $X_{\|_P}^e$, then $z - \sum_{e' \in X^e_{\|_{P}}  } b_{e}^{e'} = 0$, we have $ \sum_{e' \in X_{\|_P}^e} b_{ee'}=0$ according to constraint~\eqref{eq:afterparallel_c}, that is, there is no subtask required to follow $e$ immediately. Otherwise, if subtask is not the last subtask, i.e., $z - \sum_{e' \in X^e_{\|_{P}}  } b_{e}^{e'} > 0$, then we have $ \sum_{e' \in X_{\|_P}^e} b_{ee'}=1$ according to constraints~\eqref{eq:afterparallel_a} and~\eqref{eq:afterparallel_b}. Finally, after determining the subtask $e'$ that occurs immediately follow $e$, we impose the same constraints as~\eqref{eq:after} and~\eqref{eq:20}.

Note that constraints~\eqref{eq:bafter}-\eqref{eq:afterparallel} in \hyperref[activation:a]{\it (F$_1$)} and \hyperref[activation:b]{\it (F$_2$)} ensures that, for a subtask except the last one in $X_P$, there exists another subtask that immediately follows it. However, it is possible that the subtasks that immediately follow two different subtasks are the same one. To avoid this, we impose the constraint that, except the first subtask   to be completed in $X_P$, each subtask  can only immediately follow one subtask. Recall that $S_2^e = X^e_{\prec_{P}} \cup X^e_{\|_{P}}$.  For the current subtask $e$, if  $X^e_{\prec_{P}} \neq \emptyset$, then it can not be the first subtask to be completed, that is, it has to immediately follow one subtask in $S_2^e$:
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
  \begin{align}\label{eq:follow1}
 \sum_{e' \in S_2^e} b_{e'e} = 1.
\end{align}
  \endgroup
Otherwise, if $X^e_{\prec_{P}} = \emptyset$, then  $X^e_{<_{P}} = \emptyset$,  so there is no subtask prior to $e$. Recall that the binary variable $b_e^{e'}=1$ if subtask $e$ is completed after $e'$ and no two subtasks are completed at the same time. Therefore, $b_e^{e'}=0$ if $e$ is completed prior to $e'$. For $e' \in  X_{\|_P}^e$, the term $\sum_{e' \in X_{\|_P}^e } {b}_{e}^{e'}=0$ if $e$ is the first completed task, otherwise  positive. Then, the constraint that each subtask in $X_{\|_P}^e$, except the first one,  immediately follows another subtask can be encodes as
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{subequations}\label{eq:follow}
  \begin{align}
  \sum_{e' \in X_{\|_P}^e} b_{e'e} & \le 1,\label{eq:follow_a}\\
 \sum_{e' \in X^e_{\|_{P}}  } b_{e}^{e'} - M_{\text{max}}  \sum_{e' \in X_{\|_P}^e} b_{e'e} &  \leq 0, \label{eq:follow_b} \\
 % \sum_{e' \in X_{\|_P}^e} b_{ee'} & \leq 1.
  %% M_{\text{max}} ( \sum_{e' \in X^e_{\|_{P}}  } b_{e}^{e'} -   z ) & \leq
  \sum_{e' \in X_{\|_P}^e} b_{e'e} - M_{\text{max}} \sum_{e' \in X^e_{\|_{P}}  } b_{e}^{e'} & \leq0 . \label{eq:follow_c}
\end{align}
\end{subequations}
\endgroup
When $e$ is the first subtask, i.e., $\sum_{e' \in X^e_{\|_{P}}  } b_{e}^{e'}=0$, then $\sum_{e' \in X_{\|_P}^e} b_{e'e} = 0$, otherise, $\sum_{e' \in X_{\|_P}^e} b_{e'e} = 1$, same as~\eqref{eq:follow1}. Note that constraints~\eqref{eq:bafter}-\eqref{eq:follow} guarantee the one-to-one correspondence between any two consecutive subtasks in one linear extension.


%% Another constraint is that, after the activation of the current subtask, i.e., $\gamma(v_1)$ becomes true, it should remain true until the completion of all subtasks in $X^e_{\prec_P}$ that  should be completed prior to it. Otherwise, since the subtask $e$ should be completed when $\gamma(v_1)$ remains true, it will complete earlier than some subtasks in $X^e_{\prec_P}$, which violates the precedence relation that subtasks in $X^e_{\prec_P}$ are completed before $e$. To avoid that, this constraint, $\forall \, \ccalC_p^{\gamma} \in \clause{\gamma} , \forall \,v \in \ccalM^\mathsf{cls}_\ccalV(e,0,p)$,  $\forall\, e' \in X^e_{\prec_P}$,  can be encoded as,
%% \begingroup\makeatletter\def\f@size{10}\check@mathfonts
%% \def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
%% \begin{align}\label{eq:redundant}
%%    t_{e'}  \leq  \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t_{vr}^+   + M_{\text{max}}(1 - b_p).
%% \end{align}
%% \endgroup
%% Indeed, constraint~\eqref{eq:redundant} is redundant, which can be enforced by constraints~\eqref{eq:17} and~\eqref{eq:12}. In constraint~\eqref{eq:17} we have $t_e \leq    \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t_{vr}^+ + 1 + M_{\text{max}} (1 - b_{p})$ and in~\eqref{eq:12}, we have $ t_{e'} +  1 \leq t_e$. Therefore, $t_{e'} + 1 \leq  \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t_{vr}^+  + 1 + M_{\text{max}} (1 - b_{p})$, which is identical to constant~\eqref{eq:redundant}.

%% To determine this first satisfied subtask in $S_2^e$, we define $|X_{P}|^2$ binary variables $b_{e'}^{o}, \forall e', o \in X_{P}$,  such that $b_{e'}^{o}=1$  iff $t_{e'} \leq t_{o}$, that is, iff $e'$ is satisfied no later than  $o$. This implication can be encoded as
%% \begingroup\makeatletter\def\f@size{10}\check@mathfonts
%% \def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
%% \begin{align}
%%   M_{\text{min}} -  M_{\text{max}} b_{e'}^{o} \leq t_{e'} -  t_{o} \leq M_{\text{max}} (1- b_{e'}^{o}) ,
%% \end{align}
%%   \endgroup
%%  where $M_{\text{min}}$ is a small positive number and it is used to enforce $b_{e'}^{o}=1$ if $t_{e'} = t_{o}$. Furthermore, we define $z = |S_2^e| -1$. Observe that, for $e' \in S_2^e $, the term $z -  \sum_{o \in S_2^e\setminus \{e'\}  } b_{e'}^o = 0$ if $e'$ is the first completed task, otherwise  positive.

%%  Assuming that $S_2^e$ is non-empty, then if $e'$ is the first completed subtask in $S_2^e$, it should be activated at most one time instant later than the completion of the current subtask $e$, that is,  $\forall\, e' \in S_2^e, \forall \, \ccalC_p^{\gamma(e')} \in \clause{\gamma(e')} , \forall \,v \in \ccalM^\mathsf{cls}_\ccalV(e',0,p)$, the precedence constraint is
%% \begingroup\makeatletter\def\f@size{10}\check@mathfonts
%% \def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
%% \begin{align}\label{eq:20}
%%   & \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t_{vr}^-   \leq t_{e}  + 1 +
%%   M_{\text{max}} \Big(z  - \sum_{o \in S_2^e\setminus \{e'\}} b_{e'}^o\Big).
%% \end{align}
%% \endgroup
%% Only when $ \sum_{o\in S_2^e\setminus \{e'\}} b_{e'}^o = z $, does~\eqref{eq:20} come into effect.

%% \paragraph{(iii) Temporal constraints on  the  activation of the current substask and the completion  of prior substasks:}
%% These capture the precedence constraints that the activation of the current subtask $e$  should be at most one time instant later than the the completion of the last subtask that can occur prior to it. Otherwise, the sub-NBA induced from the poset $P$ will be trapped at $e$ since all subtasks that can be completed  before $e$ have been satisfied.  Let $S_2^e = X^e_{\prec_{P}} \cup X^e_{\|_{P}}$ collect all subtasks whose satisfaction can directly lead to the starting vertex $v_1$ of $e$. To determine this last satisfied subtask in $S_2^e$, we define $|X_{P}|^2$ binary variables $b_{e}^{e'}, \forall e, e' \in X_{P}$,  such that $b_{e}^{e'}=1$  iff $t_e \geq t_{e'}$, that is, iff $e$ is satisfied after $e'$. This implication can be encoded as}
%% \begingroup\makeatletter\def\f@size{10}\check@mathfonts
%% \def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
%% \begin{align}
%%   M_{\text{max}} (b_{e}^{e'} - 1) \leq t_e -  t_{e'} \leq M_{\text{max}} b_{e}^{e'} - M_{\text{min}},
%% \end{align}
%%   \endgroup
%%   where $M_{\text{min}}$ is a positive number that is smaller than or equal to the minimum possible gap between $t_e$ and $t_{e}$ if $t_e \not= t_{e}$, and it is used to enforce $b_{e}^{e'}=1$ if $t_e = t_{e'}$. Furthermore, we define $z = |S_2^e| -1$. Observe that, for $e' \in S_2^e $, the term $z -  \sum_{o \in S_2^e\setminus \{e'\}  } b_{e'}^o = 0$ if $e'$ is the last fulfilled task, otherwise  positive.

%% We first assume that $S_2^e$ is non-empty, then  the starting vertex of $e$ has a self-loop, $\forall \, \ccalC_p^{\gamma} \in \clause{\gamma} , \forall \,v \in \ccalM^\mathsf{cls}_\ccalV(e,0,p), \forall e' \in S_2^e$, the precedence constraint is
%% \begingroup\makeatletter\def\f@size{10}\check@mathfonts
%% \def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
%% \begin{align}\label{eq:20}
%%   & \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t_{vr}^-   \leq t_{e'}  + 1 +
%%   M_{\text{max}} \Big(z  - \sum_{o \in S_2^e\setminus \{e'\}} b_{e'}^o\Big).
%% \end{align}
%% \endgroup
%% Only when $ \sum_{o\in S_2^e\setminus \{e'\}} b_{e'}^o = z $, does~\eqref{eq:20} come into effect.

\paragraph{(iv) Temporal constraints on the activation of the first subtask:}
We analyzed the temporal constraints on the completion of the current subtask and the activation of subsequent subtasks above. However, if the subtask $e$ is the first subtask to be completed, there is no subtask whose completion activates $e$. To determined the first subtask in $X_P$,  let $P_{\text{max}}$ be the set that collects subtasks that can be the first one to be completed, which are referred to as the maximal element in a poset $P$. An elment in a poset $P$ is a maximal element if there is no element in $P$ larger than it. That is, for  any subtask  $e \in P_{\text{max}}$, we have $X_{\prec_P}^e = \emptyset$. If the first completed subtask $e = (v_1 ,v_2)$ has a self-loop and the vertex label is not $\top$ (otherwise, it is activated since the begining), we require that the vertex label $\gamma(v_1)$ should be activated at time 0, and the associated vertices in $\ccalG$ should be visited at 0,   i.e., $\forall\, e \in P_{\text{max}}, \forall\, \ccalC_p^{\gamma(v_1)} \in \clause{\gamma(v_1)}, \forall \,v \in \ccalM^\mathsf{cls}_\ccalV(e,0,p)$,
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}\label{eq:zeroactivation}
  & \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t_{vr}^-  \leq M_{\text{max}} (\sum_{e' \in P_{\text{max}}\setminus \{e\}  } {b}_{e}^{e'} + 1- b_p).
\end{align}
\endgroup
Only when $e$ is the first subtask to be completed, i.e, $\sum_{e' \in P_{\text{max}}\setminus \{e\}  } {b}_{e}^{e'}=0$ and the associated clause is true, i.e., $b_p=1$, can the vertices be visited by robots at time 0. When $|P_{\text{max}}|=1$, constraint~\eqref{eq:zeroactivation} will be reduced to  $ \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t_{vr}^-  \leq M_{\text{max}} (1- b_p).$ Note that if the vertex label $\gamma(v_1)$ has no self-loop, then $v_1$ is idential to $v_0$. We have discussed in constraint~\eqref{eq:tis0} this case.


%%  we define $|P_{\text{max}}|^2$ binary variables $\tilde{b}_{e}^{e'}, \forall e, e' \in P_{\text{max}}$,  such that $\tilde{b}_{e}^{e'}=1$  iff $t_{e} \leq t_{e'}$, that is, iff $e$ is satisfied no later than  $e'$. This implication can be encoded as
%% \begingroup\makeatletter\def\f@size{10}\check@mathfonts
%% \def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
%% \begin{align}
%%   1 -  M_{\text{max}} \tilde{b}_{e}^{e'} \leq t_{e} -  t_{e'} \leq M_{\text{max}} (1- \tilde{b}_{e}^{e'}) ,
%% \end{align}
%%   \endgroup
%%   where the term $1$ on the left side  is used to enforce $\tilde{b}_{e}^{e'}=1$ if $t_{e} = t_{e'}$. Furthermore,
  %% we define $z = |P_{\text{max}}| -1$. Observe that, for $e \in P_{\text{max}} $, the term $z -  \sum_{e' \in P_{\text{max}}\setminus \{e\}  } \tilde{b}_{e}^{e'} = 0$ if $e'$ is the first completed task, otherwise  positive. If the first completed subtask $e = (v_1 ,v_2)$ has a self-loop and the vertex label is not $\top$ (otherwise, there are no associated vertices in $\ccalG$), we have that the vertex label $\gamma(v_1)$ should be activated at time 0, and the corresponding vertices should be visited at 0,   i.e., $\forall\, e \in P_{\text{max}}, \forall\, \ccalC_p^{\gamma(v_1)} \in \clause{\gamma(v_1)}, \forall \,v \in \ccalM^\mathsf{cls}_\ccalV(e,0,p)$,
%% \begingroup\makeatletter\def\f@size{10}\check@mathfonts
%% \def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
%% \begin{align}\label{eq:zeroactivation}
%%   & \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t_{vr}^-  \leq M_{\text{max}} (z -  \sum_{e' \in P_{\text{max}}\setminus \{e\}  } \tilde{b}_{e}^{e'} + 1- b_p).
%% \end{align}
%% \endgroup
%% Only when $e$ is the first subtask, i.e, $z -  \sum_{e' \in P_{\text{max}}\setminus \{e\}  } \tilde{b}_{e}^{e'}=0$ and the associated clause is true ($b_p=1$), can the vertices be visited by robots at time 0. When $|P_{\text{max}}=1|$, constraint~\eqref{eq:zeroactivation} will be reduced to  $ \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t_{vr}^-  \leq M_{\text{max}} (1- b_p).$ If the vertex label $\gamma(v_1)$ has no self-loop, then $v_1$ is idential to $v_0$. We have discussed in constraint~\eqref{eq:tis0} the case where $v_0$ does not have a self-loop.

%% If $v_1$ has a self-loop and  the vertex label $\gamma(v_1)$ is not $\top$(otherwise, there are no associated vertices in $\ccalG$), we have that the vertex label $\gamma(v_1)$ should be activated at time 0, i.e., $\forall\, \ccalC_p^{\gamma} \in \clause{\gamma}$,
%% \begingroup\makeatletter\def\f@size{10}\check@mathfonts
%% \def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
%% \begin{align}\label{eq:zeroactivation}
%%   & \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} t_{vr}^-  \leq M_{\text{max}} (1- b_p), \;\forall \,v \in \ccalM^\mathsf{cls}_\ccalV(e,0,p).
%% \end{align}
%% \endgroup

%% Recall that in case~\hyperref[edge:vertex3]{\it (c)}  when constructing the edges for vertex labels of subtasks in $P_{\text{max}}$, leaving vertices fall into 2 categories, one category for initial vertices and the other for prior subtasks. To meet the conditions~\hyperref[asmp:b]{\it (b)} and~\hyperref[asmp:c]{\it (c)} in the Assumption~\ref{asmp:same} that the satisfied clause in the edge label stronly implies the satisfied clause in the end vertex label and the same fleet of robots satisfy these two clauses, we require that, the starting vertex label of the first completed  subtask in $P_{\text{max}}$ should be satisfied by robots coming from the initial vertices $\ccalV_{\text{init}}$ in $\ccalG$, and the starting vertex label of the remaining subtasks in $P_{\text{max}}$ should be satisfied by robots coming from vertices in $\ccalG$ that are associated with edge labels of prior subtasks. To this end, we first define an auxilary binary variable $b_{e}^{\prec}$ such that $b_{e}^{\prec}= 1$ if subtask $e$ is the first subtask in $P_{\text{max}}$, that is,
%% \begin{subequations}
%%   \begin{align}
%%     z - \sum_{e' \in P_{\text{max}}\setminus \{e\}} \tilde{b}_e^{e'}  - M_{\text{max}} (1 - b_{e}^{\prec}) & \leq 0\\
%%     1 - b_{e}^{\prec} -  M_{\text{max}} (z - \sum_{e' \in P_{\text{max}}\setminus \{e\}} \tilde{b}_e^{e'})     & \leq 0
%%   \end{align}
%% \end{subequations}
%% Only when $z = \sum_{e' \in P_{\text{max}}\setminus \{e\}} \tilde{b}_e^{e'}$, we get that $b_e^{\prec}=1$. Then, for any clause in the starting vertex label of $e$, the constraints regarding the categories of leaving vertices can be encoded as, $\forall \, \ccalC_p^\gamma \in \clause{\gamma} $,
%% \begin{subequations}\label{eq:routingforactivation}
%%   \begin{align}
%%    & \sum_{q\in \ccalQ_p} \sum_{v \in \ccalM^\mathsf{lits}_{\ccalV}(e,0,p,q)} \sum_{\substack{u: (u,v) \in \ccalE_\ccalG \\ u \not\in \ccalV_{\text{init}}}}   \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} x_{uvr} \leq M_{\text{max}} (1 - b_e^{\prec}),  \label{eq:routingforactivation_a}\\
%%    & \sum_{q\in \ccalQ_p} \sum_{v \in \ccalM^\mathsf{lits}_{\ccalV}(e,0,p,q)} \sum_{\substack{u: (u,v) \in \ccalE_\ccalG \\ u \in \ccalV_{\text{init}}}}   \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} x_{uvr} \leq M_{\text{max}}  b_e^{\prec}.  \label{eq:routingforactivation_b}
%%   \end{align}
%% \end{subequations}
%% where $u \in \ccalV_{\text{init}}$ means that vertex $u$ falls into the category of  $\ccalV_{\text{init}}$ in $\ccalG$. When subtask $e$ is the first subtask to be completed in $P_{\text{max}}$, i.e., $b_e^{\prec}=1$, constraint~\eqref{eq:routingforactivation_a}, combining with constraint~\eqref{eq:6}, says that robots should come from the vertices in~$\ccalV_{\text{init}}$. However, when subtask $e$ is not  the first subtask to be completed in $P_{\text{max}}$, i.e., $b_e^\prec=0$, constraint~\eqref{eq:routingforactivation_b} requires that robots should come from vertices associated with prior subtasks.

Recall that in case~\hyperref[edge:vertex3]{\it ($E_3$)}  when constructing the edges for vertex labels of subtasks in $P_{\text{max}}$ (a subtask $e$ is in $P_{\text{max}}$ if the set $X_{\succ_P}^e$ is empty), leaving vertices fall into 2 categories, one category for initial vertices and the other for prior subtasks. To meet the conditions~\hyperref[asmp:b]{\it (b)}  in the Assumption~\ref{asmp:same} that the satisfied clause in the edge label strongly implies the satisfied clause in the end vertex label and the same fleet of robots satisfy these two clauses, we require that, the starting vertex label of the first completed  subtask in $P_{\text{max}}$ should be satisfied by robots coming from the initial vertices $\ccalV_{\text{init}}$ in $\ccalG$, and the starting vertex label of the remaining subtasks in $P_{\text{max}}$ should be satisfied by robots coming from vertices in $\ccalG$ that are associated with edge labels of prior subtasks. To this end, we first define an auxilary binary variable $b_{e}^{\prec}$ such that $b_{e}^{\prec}= 1$ if subtask $e$ is the first subtask in $P_{\text{max}}$, that is,
\begin{subequations}
  \begin{align}
   \sum_{e' \in P_{\text{max}}\setminus \{e\}} {b}_e^{e'}  - M_{\text{max}} (1 - b_{e}^{\prec}) & \leq 0\\
    1 - b_{e}^{\prec} -  M_{\text{max}}  \sum_{e' \in P_{\text{max}}\setminus \{e\}} {b}_e^{e'}    & \leq 0
  \end{align}
\end{subequations}
Only when $ \sum_{e' \in P_{\text{max}}\setminus \{e\}} {b}_e^{e'}=0$, we get that $b_e^{\prec}=1$. Then, for any clause in the starting vertex label of $e$, the constraints regarding the categories of leaving vertices can be encoded as, $\forall \, \ccalC_p^\gamma \in \clause{\gamma} $,
\begin{subequations}\label{eq:routingforactivation}
  \begin{align}
   & \sum_{q\in \ccalQ_p} \sum_{v \in \ccalM^\mathsf{lits}_{\ccalV}(e,0,p,q)} \sum_{\substack{u: (u,v) \in \ccalE_\ccalG \\ u \not\in \ccalV_{\text{init}}}}   \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} x_{uvr} \leq M_{\text{max}} (1 - b_e^{\prec}),  \label{eq:routingforactivation_a}\\
   & \sum_{q\in \ccalQ_p} \sum_{v \in \ccalM^\mathsf{lits}_{\ccalV}(e,0,p,q)} \sum_{\substack{u: (u,v) \in \ccalE_\ccalG \\ u \in \ccalV_{\text{init}}}}   \sum_{r\in \ccalM^\ccalV_{\ccalK}(v)} x_{uvr} \leq M_{\text{max}}  b_e^{\prec}.  \label{eq:routingforactivation_b}
  \end{align}
\end{subequations}
where $u \in \ccalV_{\text{init}}$ means that vertex $u$ falls into the category of $\ccalV_{\text{init}}$ in $\ccalG$. When subtask $e$ is the first one to be completed in $P_{\text{max}}$, i.e., $b_e^{\prec}=1$, constraint~\eqref{eq:routingforactivation_a}, combining with constraint~\eqref{eq:6}, says that robots should come from the vertices in~$\ccalV_{\text{init}}$. However, when subtask $e$ is not  the first subtask to be completed in $P_{\text{max}}$, i.e., $b_e^\prec=0$, constraint~\eqref{eq:routingforactivation_b} requires that robots should come from vertices associated with prior subtasks.


\subsubsection{Same-$\ag{i}{j}$ constraints:}\label{sec:samegroup}
Finally, we encode the constraints that some subtasks are executed by the same $\ag{i}{j}$, which are indicated by the same non-zero connector $\chi$. Given a non-zero connector $\chi$, we can locate all labels, vertex or edge labels, that have literals with the same connector $\chi$  by the mapping $\ccalM_\mathsf{\gamma}^\chi(\chi)$. For an edge label $(e, 1)  \in  \ccalM_\mathsf{\gamma}^\chi(\chi)$ or a vertex label $(e, 0)  \in  \ccalM_\mathsf{\gamma}^\chi(\chi)$, each clause has at most one literal $\aap{i}{j}{k}{\chi}$ with connector $\chi$ and it is associated with $i$ vertices in $\ccalG$. We enumerate these $i$ vertices and denote the $b$-th vertex by $v_k^b$. Then for any two labels $\gamma, \gamma'\in\ccalM_\mathsf{\gamma}^a(\chi)$ and any two clauses $\ccalC_p^\gamma \in \clause{\gamma}$ and $\ccalC_{p'}^{\gamma'} \in \clause{{\gamma'}}$ that have  literals $\aap{i}{j}{k}{\chi}$ and $\aap{i}{j}{k'}{\chi}$, respectively, {the constraint} that the corresponding literals are satisfied by the same $\ag{i}{j}$, $\forall \,b \in [i]$ and  $\forall \, r \in \ccalK_j$, can be encoded as
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{subequations}\label{eq:same}
  \begin{align}
    & \sum_{u:(u, v_k^b) \in \ccalE_\ccalG} x_{u v_k^b r} + M_{\text{max}} (b_p - 1) \nonumber \\& \quad\quad\quad \leq  \sum_{u:(u, v_{k'}^b) \in \ccalE_\ccalG} x_{u v_{k'}^b r} + M_{\text{max}}(1 - b_{p'}),\\
    & \sum_{u:(u, v_{k'}^b) \in \ccalE_\ccalG} x_{u v_{k'}^b r} + M_{\text{max}} (b_{p'} - 1) \nonumber \\& \quad\quad\quad \leq \sum_{u:(u, v_{k}^b) \in \ccalE_\ccalG} x_{u v_{k}^b r} + M_{\text{max}}(1 - b_{p}),
  \end{align}
\end{subequations}
\endgroup
where $v_{k'}^b$ is the $b$-th vertex associated with $\aap{i}{j}{k'}{\chi}$. Only when $b_p = b_{p'}=1$, does~\eqref{eq:same} come into effect. Then, $\sum\nolimits_{u:(u, v_k^b) \in \ccalE_\ccalG} x_{u v_k^b r} = \sum\nolimits_{u:(u, v_{k'}^b) \in \ccalE_\ccalG} x_{u v_{k'}^b r} $, i.e., vertices $v_k^b$ and $v_{k'}^b$ are visited by the same robot $r$.

\subsubsection{MILP objective}The objective is to minimize the weighted sum of travelling distance and execution time, i.e.,
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}\label{equ:obj}
  \min \; \;&  \alpha \sum_{(u,v)\in \ccalE_\ccalG}  \sum_{r \in \ccalM^\ccalV_{\ccalK}(v)} d_{uv} x_{uvr} +  (1 - \alpha) \sum_{e\in X_P} t_e,
\end{align}
 \endgroup
  where $\alpha$ is a user-specified parameter and  $d_{uv}$ is the travelling distance.
  \begin{rem}
   Compared to Problem~\ref{prob:1}, the objective~\eqref{equ:obj} involves the optimization of time. In the simulations in Section~\ref{sec:sim}, we observed that without optimizing the time, some scheduling variables can take large values, which impacts the plan execution; see Section~\ref{sec:path}. Note that travel distance and execution time are typically non-conflicting objectives.
  \end{rem}
  \begin{rem}
    One advantage of the above MILP formulation is that we tackle each subtask directly,  which permits us to impose more constraints on certain subtasks to cater to stricter needs, such as prevent certain robots from engaging in a subtask. We will detail these extensions in Section~\ref{sec:extension_milp}.
  \end{rem}

\subsection{Construction of robot prefix plans from the MILP solution}\label{sec:path}
After solving the MILP formulated in Section~\ref{sec:milp}, we first extract a time axis by sorting the completion time of all subtasks such that each time instant in the time axis is the completion time of one subtask in $X_P$ on which the MILP is formulated. This time axis produces a linear extension of the poset $P$ and  will be used in Section~\ref{sec:run} to extract a simple path from the NBA $\auto{subtask}^-$ that connects the initial vertex $v_0$ and the accepting vertex $v_\text{accept}$. Next, we extract a high-level plan for each robot  that will be concretized in Section~\ref{sec:mapp} to generate low-level paths that satisfy the specification $\phi$; see also block 5 in Fig.~\ref{fig:overview}.


\subsubsection{Time axis:}\label{sec:timeaxis} The progress made in the NBA $\auto{subtask}^-$ is directly linked to the satisfaction of the edge label, and also the satisfaction of edge labels in $\auto{subtask}^-$ will lead to the satisfaction of the end vertex labels according to condition~\hyperref[cond:d]{\it (d)} in the Definition~\ref{defn:run}. Therefore, we collect the  set of completion time of all subtasks in $X_P$, evaluated at $t_e$ defined in Section~\ref{sec:constraintonedge}, and sort them in an ascending order to form a unique increasing time axis, denoted by $\vec{t}$. We note that there do no exist idential time instants due to constraint~\eqref{eq:diff}.

%% There may exist identical time instants due to the parallel completion of subtasks. To break the tie, we increment each time instant by a small constant if it is identical with its previous one and further shift the remaing instants into the future by the same amount. For instance, by incrementing 2, the time axis $\vec{t}= (3, 4, 4, 7, 7)$ becomes $(3, 4, 6, 9, 11)$, where the 3-rd entry 4 becomes 6 since it is identical to the previous one, 4-th entry 7 becomes 9 to shift into future by the same amount, and 5-th entry becomes 11 resulting from  the cumulative effect of shifting into future due to entry 4 and being identical to the previous one in the original time axis.  Note that the satisfaction of  the specification $\phi$ relies upon the relative order between the completion of substasks, other than the exact occurence time. In large part, we mantain the relevant order between these time instants and only slightly stagger completion times of subtasks that are independent. This operation is safe since independent subtasks can happen arbitrarily. The reason we stagger is that independent elementary subtasks that are completed at the same time will enable an edge in the NBA $\autop^-$ that corresponds to a composite subtask, while this edge does not exist in the NBA $\auto{subtask}^-$. Our manipulation prevents this happening with the intention of decomposing complex subtasks and focusing on elementary subtasks.

\subsubsection{High-level plans for robots:} Next we extract a high-level plan for each robot, which is a sequence of waypoints that are related  to  the completion of subtasks in $X_P$, along with a sequence of associated non-decreasing time instants. For robot $[r,j]$, let $p_{r,j}$ denote its plan and $t_{r,j}$ denote the  timeline. Consider the vertex $v^*_0 \in \ccalV_{\text{init}}$ in the routing graph $\ccalG$ that points to the initial location of  robot $[r,j]$  and let $v^*_1$ be the vertex such that $x_{v^*_0 v^*_1 r} =1$. Recall that each vertex in the routing graph $\ccalG$ is associated with an label that is captured by the mapping $\ccalM_{\mathsf{lits}}^{\ccalV}$ in Section~\ref{sec:vertex}. If the label of $v_1^*$ is a vertex label, we continue to search for vertex $v_2^*$ such that $x_{v_1^* v_2^* r}=1$ until a vertex $v^*$ is found that is associated with an edge label. Then the associated region  $\ccalM^\ccalV_{\ccalL}(v^*)$ is the first waypoint robot $r$ visits to complete a subtask and thus, we add this region $\ccalM^\ccalV_{\ccalL}(v^*)$ to the plan $p_{r,j}$. Next, the visit time  $t^-_{v^* r} = t^+_{v^* r}$ equals the completion time of the associated subtask, which is captured by $\ccalM_{e}^{\ccalV}(v^*)$. We add the time $t^-_{v^* r}$ to the timeline $t_{r,j}$. Note that each time instant in the time axis $\vec{t}$ corresponds to one subtask, therefore, this visit time $t^-_{v^* r}$ is identical to one time instant in $\vec{t}$ that is associated with the same subtask.   Continuing the above process, we can construct a sequence of waypoints along with the associated timeline where visit times are aligned with time instants in the time axis $\vec{t}$. Based on the high-level plan $\{p_{r,j}\}$, in Section~\ref{sec:solution2mrta} we design low-level executable paths to take into account negative literals and collision avoidance.

%% \blue{The synthesized plan corresponds to the whole or a partial prefix plan
%%   depending on whether a vertex label exists for $\vertex{accept}$, which will be discussed in Section~\ref{sec:suf}. Note that the high-level plans are defined on an abstraction of the environment, minimizing the travelling distance between regions and ignoring inter-robot collision avoidance. Furthermore, these plans are associated with the relaxed automaton $\auto{relax}^-$. In Section~\ref{sec:solution2mrta}, we show how to use these high-level plans to generate low-level executable plans that work for the original automaton $\autop^-$.}
\begin{cexmp}
 {After solving the MILP for the environment in Fig.~\ref{fig:workspace}, the high-level plans and the associated timelines for robots are as follows: $p_{2,1} = p_{3,1} = \{\ell_2, \ell_3\}, t_{2,1} = t_{3,1} = \{4, 12\},    p_{2,2} = \{\ell_4\}$, $t_{2,2} = \{8\}$.    That is, robots $[2,1]$ and $[3,1]$ visit the office building $\ell_2$ at time instant 4, then robot $[2,2]$ visits the road at time instant 8, and finally robots $[2,1]$ and $[3,1]$ visit the  open area $\ell_3$ at time instant 12. The remaining  robots remain idle. Observe that the lengths of the plans differ. The induced run from $\auto{subtask}^-$ in Fig.~\ref{fig:sub-NBA} is $\vertex{init}, v_1, v_2, v_3, v_6, v_{6'}$. The associated time axis  is $\vec{t} = \{0, 4, 8, 12, 13\}$, one time instant each subtask. In words, the subtask $(\vertex{init}, v_1)$ is completed at time instant 0 and the subtask $(v_1, v_2)$ is completed at time instant 4, which corresponds to the event that robots $[2,1]$ and $[3,1]$ visit the office building $\ell_2$ at time instant 4.
  }
\end{cexmp}

\subsection{Construction of robot suffix paths}\label{sec:suf}
We assume that the high-level plan found in Section~\ref{sec:path} for the prefix part  has been used to generate low-level paths as in Section~\ref{sec:solution2mrta} which induces a run in $\autop$ that connects $v_0$ and $\vertex{accept}$. Thus, the final robot locations for the prefix part are given, which will be treated as the initial robot locations of the suffix part. The goal of the suffix paths is to drive the progression in the NBA~$\autop$ back to the accepting vertex and send robots to final locations of the prefix part to close the trajectory.
 We have discussed the suffix part when the given accepting vertex $\vertex{accept}$ has a self-loop; see Fig.~\ref{fig:prefix_no_self_loop}. Its vertex label is satisfied automatically by the final robot locations of the prefix part since in step {\it (B$_2$)} in  Section~\ref{sub-NBA:1} we remove any incoming edge of $\vertex{accept}$ if the edge label does not strongly imply the label $\gamma_{\phi}(\vertex{accept})$. In what follows, we construct closed robot paths for the suffix part when $\vertex{accept}$ does not have a self-loop, which drives the transition along a cycle back to $\vertex{accept}$. Intuitively, by viewing the simple cycle around $\vertex{accept}$ as a simple path, we treat the  accepting vertex on the starting side of this simple path as the initial vertex $v_0$ and the other accepting vertex on the ending side as the goal to be reached, then  starting from the NBA $\autop^-$ in Section~\ref{sec:prune}, we  follow the similar procedure as for the prefix part to obtain paths for the suffix part.

  \begin{figure}[!t]
    \centering
    \includegraphics[width=0.5\linewidth]{suffix.pdf}
    \caption{$\auto{subtask}^-$ for the suffix part when $\vertex{accept}$ does not have a self-loop. $\gamma_1$, $\gamma_2$ and $\gamma_3$ are edge labels and $\pi_{\text{init}}$ is the literal that captures the initial robot configurations; see Section~\ref{sec:suf_milp}.}
    \label{fig:suffix}
  \end{figure}

  \subsubsection{Extracting Subtasks and Infer the Temporal Order from the NBA:}\label{sec:suf_prune}
  \paragraph{(i) Extraction of sub-NBA $\auto{subtask}$ from $\auto{relax}$:} First, based on the NBA $\autop^-$ we obtain the relaxed NBA $\auto{relax}$, as in Section~\ref{sec:prune}.  Then, similar to finding the shortest simple cycle around $\vertex{accept}$ in Section~\ref{sec:sort}, we remove all other accepting vertices from $\auto{relax}$ and then remove all initial vertices if they do not have self-loops. Let $\gamma_{\phi}(\vertex{prior}, \vertex{accept})$ denote the edge label in the NBA $\autop$ that corresponds to the last completed subtask in the prefix part. After generating the low-level paths for the prefix part, the final robot locations of the prefix part satisfy $\gamma_{\phi}(\vertex{prior}, \vertex{accept})$ (see Fig.~\ref{fig:lasso}).  Next, since $\vertex{accept}$ does not have a self-loop, by condition \hyperref[cond:f]{\it (f)} in Definition~\ref{defn:run}, we remove any outgoing edges of $\vertex{accept}$ (acting as $v_0$) from $\auto{relax}$ if $\gamma_{\phi}(\vertex{prior}, \vertex{accept})$ does not imply its edge label in $\autop$. Same as the satisfaction check in Section~\ref{sec:sort}, the implication check is conducted in $\autop$ as well. According to condition \hyperref[cond:f]{\it (f)}, if the set of restricted accepting runs is non-empty, the  implication holds  for some  outgoing edges of some accepting vertices.
  Furthermore, we remove any incoming edges of $\vertex{accept}$ (acting as $\vertex{accept}$) from $\auto{realx}$ if the corresponding edge label in $\autop$ is not implied by $\gamma_\phi(\vertex{prior}, \vertex{accept})$.  We highlight that the implication check is  conducted in the NBA $\autop$, as well. By the condition \hyperref[cond:f]{\it (f)}, if the set of restricted accepting runs is non-empty, the implication holds  for some accepting vertices.   Next, we can follow Section~\ref{sec:pregraph} to  extract a sub-NBA $\auto{subtask}$ from $\auto{relax}$ for the pair $\vertex{accept}$ (acting as $v_0$) and $\vertex{accept}$. The structure of $\auto{subtask}$ is shown in Fig.~\ref{fig:suffix}, which is very similar to those in Fig.~\ref{fig:prefix}, except that $v_0$ does not have a self-loop.  Then, we prune $\auto{subtask}$ to obtain the NBA $\auto{subtask}^-$.

  \paragraph{(ii) Infer temporal order between subtasks in $\auto{subtask}^-$:} We collect all simple cycles in $\Theta$ that connects $\vertex{accept}$ and $\vertex{accept}$. ($\vertex{accept}$ does not have a self-loop.) %% Here, given such a simple path $\theta$, before adding it to $\Theta$, we further check whether in $\autop$ the label $\gamma_{\phi}(\vertex{prior}, \vertex{accept})$ implies  the label of its last edge  (serving as $(\vertex{prior}', \vertex{accept})$; see Fig.~\ref{fig:lasso})  according to Definition~\ref{defn:implication}.
 Note that, as the initial robot locations of the suffix part satisfy $\gamma_{\phi}(\vertex{prior}, \vertex{accept})$, it also satisfies the label of the last edge in each simple cycle $\theta\in \Theta$. By taking this simple cycle $\theta$, not only the transition is driven back to $\vertex{accept}$, but robots can return to their initial locations to close the trajectories. %% while respecting the same-$\ag{i}{j}$ constraints in Section~\ref{sec:samegroup}.
 Finally, we infer the set $\Theta$ of simple cycles that meet this extra requirement and  obtain a sorted set of posets $\{P_e\}$ from simple cycles in $\Theta$.

  \subsubsection{Formulation of the MILP:}\label{sec:suf_milp} Similar to the prefix part, we iterate over the set of posets $\{P_e\}$ to formulate the MILP.  To achieve the two goals of returning to initial locations and close the suffix part of an accepting run at the same time, we first define an atomic proposition $\pi_{\text{init}}$ which is true if all robots return to there initial locations at the end of the suffix paths. Next, we find the set of subtasks, denoted by $P_{\text{min}}$, in a given poset $P$ in $\{P_e\}$ that can be the last one to be completed, which are referred to as the minimal elements in a poset. An element in a poset $P$  is a minimal element if there is no element in $P$ smaller than it. %% Note that the edge labels of all subtasks in $P_{\text{min}}$ can be satisfied by the initial robot locations, since the last edges of all simple paths in $\Theta$ are ensured to be satisfied by the initial robot locations in Section~\ref{sec:suf_prune}, which is the direct consequence of implication.
  For each subtask $e = (v_1, v_2) \in P_{\text{min}}$, we augment its edge label $\gamma(v_1, v_2)$ with another clause $\pi_{\text{init}}$, that is, $\gamma(v_1, v_2) = \gamma(v_1, v_2) \vee \pi_{\text{init}}$; see also Fig.~\ref{fig:suffix}. If $e \in P_{\text{min}}$ is truly the last subtask to be completed, we require the clause $ \pi_{\text{init}}$  to be satisfied. If $\pi_{\text{init}}$ is satisfied, the original edge label $\gamma(v_1, v_2)$ before augment will also be satisfied, since initial robot locations satisfy the original edge label of the last completed subtask. Thus, in this way, these two goals of returning to initial locations and close the suffix part of an accepting run are achieved  at the same time.
  \paragraph{(i) Construction of the routing graph:}   Next, given the poset $P$, we build a routing graph $\ccalG = (\ccalV_G, \ccalE_G)$ following almost the same steps in Section~\ref{sec:graph}. The exceptions are all related to the augmented clause $\pi_{\text{init}}$.  Recall that the vertex set $\ccalV_\text{init} \subseteq \ccalV_\ccalG$ contains vertices that point to the initial robot locations. When buidling the vetex set $\ccalV_\ccalG$, each time we encounter a literal $\pi_{\text{init}}$, we creat a copy of vertices in $\ccalV_{\text{init}}$ and associate these vertices  with the literal $\pi_{\text{init}}$, so that each vertex points to one single cell which is the initial location of a specific robot.  These vertices will be visited at the same time by all robots.  Also, we build a one-to-one correspondence between copied vertices and robots since  robots need to return to different initial locations. The  mappings are created following the way in Section~\ref{sec:vertex}.

  When  building the edge set $\ccalE_\ccalG$, there are no outgoing edges from  vertices that are associated with the literal $\pi_\text{init}$, since these verties will be where robots reside at the final moment. The incoming edges of these vertices are constructed by treating $\pi_{\text{init}}$ as a regular clause (single literal with connector $\chi=0$) of an edge label, as in Section~\ref{sec:edge_set} but with one exception.  Recall that in step~\hyperref[sec:a]{\it {(D$_2$)}}, when identifying the leaving vertices that are associated with prior subtasks,  when the number of leaving vertices is larger than the number of end vertices, we randomly create multiple  one-to-one edges, since all robots visiting these leaving vertices belong to the same type. However, here we create edges from all leaving vertices to each vertex associated with $\pi_{\text{init}}$ since each vertex with $\pi_{\text{init}}$ is only allowed to be visited by a specific robot of a specific type, making all robots heterogeneous in this sense.
\stepcounter{mycounter}
 \paragraph{(ii) Formulation of the MILP problem:}  To find a high-level plan, we formulate a MILP problem based on the routing graph $\ccalG$ by following almost identical procedures in Section~\ref{sec:milp} with two exceptions:

\paragraph{(\Alph{mycounter}$_1$) same-$\ag{i}{j}$ constraints:} The first exception is the same-$\ag{i}{j}$ constraints in Section~\ref{sec:samegroup}, since we need to maintain the same group of $i$ robots of type $j$ visiting some regions sequentially as those in the prefix plan. Specifically, after solving the MILP for the prefix part, for any connector $\chi\not=0$ that appear in $\phi$, we check whether any literal that includes this connector was involved in the prefix part. If yes, then these literals with the same non-zero connector should be satisfied by the same $\ag{i}{j}$. We denote by $\ccalK^\chi \subseteq \ccalK_j$ the set of $\ag{i}{j}$ that make these literals true and  by  $r^b$ the $b$-th robot in the enumerated set $\ccalK^\chi$. When dealing with the suffix part, for any label $\gamma \in\ccalM_\mathsf{\gamma}^\chi(\chi)$ where literals with connector $\chi$ appear and any clause $\ccalC_p^\gamma \in \clause{\gamma}$ that has  literal $\aap{i}{j}{k}{\chi}$, the constraint that this literal is satisfied by the same $\ag{i}{j}$  can be encoded as}
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}\label{eq:same_suffix}
    \sum\nolimits_{u:(u, v_k^b) \in \ccalE_\ccalG} x_{u v_k^b r^b} =  b_p, \;\forall\, r^b \in \ccalK^\chi,
  \end{align}
\endgroup
where $v_k^b$ is the $b$-th vertex in the set of vertices in the routing graph $\ccalG$  that are associated with literal $\ap{i}{j}{k,\chi}$. If the clause $\ccalC_p^\gamma$ is true, i.e.,  $b_p=1$, the $b$-th vertex $v_k^b$ is visited by the $b$-th robot $r^b \in \ccalK^\chi$. On the other hand, if $\ccalK^\chi = \emptyset$, that is, literals that share this $\chi$ do not appear in the prefix part, we turn to constraint~\eqref{eq:same} to impose the same-$\ag{i}{j}$ constraints.

Note that by condition \hyperref[cond:f]{\it (f)} regarding implication in Definition~\ref{defn:run}, the clause $\ccalC$ in the edge label $\gamma(\vertex{prior}, \vertex{accept})$ (see Fig.~\ref{fig:lasso}) that the initial locations of the suffix part satisfy implies a clause $\ccalC'$ in the edge label $\gamma(\vertex{prior}', \vertex{accept})$, i.e., $\ccalC'$ is a subformula of $\ccalC$,  therefore, robots returning to the initial locations of the suffix part will enable this clause $\ccalC'$ in $\gamma(\vertex{prior}', \vertex{accept})$ and at the same time maintain that any literal in the clause $\ccalC'$ with non-zero connector uses the same group of robots as the literal in the clause $\ccalC$ in $\gamma(\vertex{prior}', \vertex{accept})$ with the same connector.  In other words, when robots head back towards their initial locations, the same-$\ag{i}{j}$ constraints over the last-completed subtask are satisfied automatically. Robots can safely return to their initial locations at last without worrying about violating the same-$\ag{i}{j}$ constraints. This is why we treat the literal $\pi_{\text{init}}$ as a literal with connect $\chi=0$ when we build the routing graph $\ccalG$.

%% The solution to this MILP returns high-level plans that induce a run in $\auto{subtask}^-$ that starts from and ends at the accepting vertex $\vertex{accept}$. Then, we can get the low-level executable paths by following the method in~Section~\ref{sec:solution2mrta} that drive the transitions to vertex label of $v_{\text{next}}$. The last step is to design paths that satisfy  the vertex label of $v_{\text{next}}$ so that robots go back  to their initial locations from the final locations of these paths returned by Section~\ref{sec:solution2mrta} and meanwhile do not violated the specification. In this way, robots' path constitute a cycle.
\paragraph{\quad (b) Closing of robots trajectories:} The second exception results from the requirement that, while driving transition back to $v_{\text{accept}}$, robots need to synchronize and make their trajectories a loop, i.e., the finial locations of the suffix paths should be identical to the initial locations of the suffix paths.
To this end, we define binary variables $b_e$ for each subtask in $P_{\text{min}}$ such that $b_e$ equaling 1 implies the satisfaction of the corresponding clause $\pi_{\text{init}}$. First, we require that one  and only one $b_e$ can be true, i.e.,
\begin{align}\label{eq:one_suffix}
  \sum_{e \in P_{\text{min}}} b_e = 1.
\end{align}
If $b_e=0$ for a subtask $e$ in $P_{\text{min}}$, then one of the remaining clauses in the edge label of $e$ must be satisfied according to constraint $\eqref{eq:c}$, which is reduced to the regular case as if $\pi_{\text{init}}$ did not exist.

Next, we encode the constraint that it is when completing the last subtask in $P_{\text{min}}$ that robots return to their initial locations. Recall that in Section~\ref{sec:milp} we define binary variables $b_{e}^{e'}=1$ which is 1 if subtask $e$ is completed after  $e'$, i.e., $t_e >  t_{e'}$. To determine this last satisfied subtask in $P_{\text{min}}$,
%% we define $|P_{\text{min}}|^2$ binary variables $b_{e}^{e'}, \forall e, e' \in P_{\text{min}}$,  such that $b_{e}^{e'}=1$  iff $t_e \geq t_{e'}$, that is, iff $e$ is satisfied no earlier than  $e'$. This implication can be encoded as}
%% \begingroup\makeatletter\def\f@size{10}\check@mathfonts
%% \def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
%% \begin{align}
%%   M_{\text{max}} (b_{e}^{e'} - 1) \leq t_e -  t_{e'} \leq M_{\text{max}} b_{e}^{e'} - M_{\text{min}},
%% \end{align}
%%   \endgroup
%%  where $M_{\text{min}}$ is a small positive number and it is used to enforce $b_{e}^{e'}=1$ if $t_e = t_{e'}$.
  we define $z = |P_{\text{min}}| -1$. Then, for any $e \in P_{\text{min}}$, the term $\sum_{e' \in  P_{\text{min}}\setminus \{e \} } b_{e}^{e'} - z  = 0$ if $e$ is the last subtask to be completed. Thus, robot returning to initial locations to complete the last subtask  can be encoded as
\begin{align}\label{eq:lastsubtask}
  1 + M_{\text{max}} ( &  \sum_{e' \in  P_{\text{min}}\setminus \{e \} } b_{e}^{e'} - z)  \leq  b_e \nonumber \\
  & \leq 1 + M_{\text{max}} (z - \sum_{e' \in  P_{\text{min}}\setminus \{e \} } b_{e}^{e'}),
\end{align}
for any subtask $e \in P_{\text{min}}$. Only when $e$ is the last subtask in $P_{\text{min}}$ to be completed, does $b_e = 1$ come into effect.


Given a subtask $e = (v_1, v_2) \in P_{\text{min}}$, similar to constraint~\eqref{eq:6}, the following constraint says that when $b_e=1$, i.e., subtask $e$ is indeed the last one to be completed,  each vertex in $\ccalG$ that is associated with clause $\pi_{\text{init}}$ of $\gamma(v_1, v_2)$ will be visited by a specific robot among the whole fleet of $n$ robots,
\begin{align}\label{eq:return_suffix}
  \left.   \left[ \sum_{v \in \ccalM_\ccalV^\mathsf{lits}(e, 1, p_e, 1)}   \sum_{u: (u,v) \in \ccalE_\ccalG}     \sum_{r = \ccalM_{\ccalK}^\ccalV(v) }   x_{uvr} \right] \middle/ {n} \right. = b_e,
 \end{align}
where $p_e$ is the index of the clause $\pi_{\text{init}}$ in $\gamma(v_1, v_2)$ and robot $r$ is the specific robot that should visit vertex $v$.

%% To this end, the clause that will be satisfied in the label of vertex $v_{\text{next}}$ in the suffix part should be the same as the clause that was satisfied in the prefix part. Both vertices refer to $v_{\text{next}}$ at the bottom part in Fig.~\ref{fig:absence}. Specifically, from the solution of MILP for the prefix part, we can locate the clause $\ccalC_p^\gamma \in \clause{\gamma(v_{\text{next}})}$ such that  $b_p = 1$, and then in the MILP for the suffix part, we set the variable $b_p$ as 1 that corresponds to the $p$-th clause of the label $\gamma(v_{\text{next}})$.

%%   Besides that the same clauses are satisfied, it should be the same set of robots that enable literals in these two clauses, that is, these robots return to the same region where they are when they satisfy the clause in the prefix part. To find the set of robots, given
%%   the $q$-th literal $\ap{i}{j}{k,\chi}$ in the $p$-th clause that was satisfied in $\gamma(v_{\text{next}})$ in the prefix part,  we locate robot $r\in \ccalM_\ccalK^\ccalV(v)$ such that $\exists\, v\in \ccalM_{\ccalV}^\mathsf{lits} (e, 0, p, q),\,\exists\, (u,v)\in\ccalE_\ccalG$, making $x_{uvr}=1$, where $e$ is the subtask whose starting vertex is $v_{\text{next}}$. In this way, we can find the set of robots that together satisfy this lietral. Therefore, in the suffix part, these $i$ robots should visit $i$ vertices that  point to region $\ell_k$ to satisfy the same literal $\ap{i}{j}{k,\chi}$ in $\gamma(v_{\text{next}})$. This constraint now becomes the same as the same-$\ag{i}{j}$ constraint. We can enumerate these $i$ robots to have one-to-one correspondence with $i$ vertices, and formulate the constraints like~\eqref{eq:same_suffix}.

After solving the MILP for the suffix part, we can use the method in Section~\ref{sec:solution2mrta} to obtain low-level paths which drives the transition back to $\vertex{accept}$ and return to initial locations to close the trajectories.



{Finally, for each poset $P_{\text{suf}}$, we can potentially find one suffix path (failures may result from that the MILP formulation is physically infeasible), then we select the suffix path over $\{P_{\text{suf}}\}$ with the lowest cost, which will be the best suffix path that correponds to a poset $P_{\text{pre}}$ in the prefix part for the given pair $(v_0, \vertex{accept})$. This best suffix path and the prefix path corresponding to $P_{\text{pre}}$ constitute a best total path for the poset $P_{\text{pre}}$ given the triple $(v_0, \vertex{accept})$. Then, according to~\eqref{eq:cost}, we select the best total paths over all posets $\{P_{\text{pre}}\}$ in the prefix part for the given pair $(v_0, \vertex{accept})$.  At last, we can obtain the best total path by iterating over all pairs of initial and accepting vertice with finite total length. We highlight that our method can terminate anytime once a feasible path is found and running more cases can lead to feasible paths that outperform the best incumbent solution.
}

  \section{Design of Low-Level Paths that Satisfy the Original LTL Task}\label{sec:solution2mrta}
 This section presents the correction stage that concretizes the high-level plan obtained in Section~\ref{sec:path} to satisfy the specification $\phi$; see also blocks 6 and 7 in Fig.~\ref{fig:overview}. We first extract a simple path from the NBA $\auto{subtask}^-$ that connects $v_0$ and $\vertex{accept}$, based on the time axis and the high-level plan, and then find the counterpart of this simple path from the NBA $\autop$ that connects $v_0$ and $\vertex{accept}$. To satisfy the specification $\phi$, by means of following along the high-level plan, we formulate a sequence of generalized multi-robot path planning problems to design low-level executable paths \red{ that can induce a run in $\autop$ that acts as the prefix part of a restricted accepting run while meeting the Assumption~\ref{asmp:same}.}
\subsection{Extraction of the simple path from the relaxed NBA \upshape $\auto{subtask}^-$}\label{sec:run}
  %% Note that we operate on $\auto{subtask}^-$ other than the pruned NBA  $\auto{subtask}^-$. This is because independent elementary subtasks can occur simultaneously, which together consistitute a composite subtask whose associated edge  appears in the NBA $\auto{subtask}^-$ but not in~$\auto{subtask}^-$.

Recall that each distinct time instant in the time axis $\vec{t}$ obtained in Section~\ref{sec:path} has one-to-one correspondence with subtasks in the set $X_P$, and the sorted time axis generates a linear extension of subtasks in $X_P$ that induces a simple path in $\auto{subtask}^-$ that connects $v_{0}$ and $\vertex{accept}$. In this section, we proceed along the time axis $\vec{t}$ to extract this simple path using the backtracking search. The outline of the algorithm is shown in Alg.~\ref{alg:extract}.

  To this end, we define $c\in \mathbb{N}$ as the {\it global counter} which keeps track of the progress that has been made along the time axis $\vec{t}$. Specifically, $c$ is the index of the subtask that  has  been completed most recently, therefore, $\vec{t}(c+1)$ denotes  the  completion time of the current subtask, denoted by $e' = (v'_1, v_2')$, which is  the next one to be completed. Let $v_1$ denote the vertex in $\auto{subtask}^-$ that is the  most recently reached when following along the time axis.  We start from the initial vertex $v_1= v_0$ with global counter $c=0$ [line~\ref{run:initialization}, Alg.~\ref{alg:extract}]. At each iteration, among all subtasks from the vertex $v_1$, we find the one $(v_1, v_2)$ that is  equivalent to the  subtask $e'$ [line~\ref{run:edgelabel}, Alg~\ref{alg:extract}]. Then, after the time instant $\vec{t}(c+1)$,  vertex $v_2$ becomes the most recently reached vertex. We then increase the global counter by 1 and add it to a stack, a last-in-first-out container [line~\ref{run:put}, Alg.~\ref{alg:extract}]. The iteration will terminate until the accepting vertex $\vertex{accept}$ is reached.


 \begin{algorithm}[t]
      \caption{Extract the  simple path  from $\auto{subtask}^-$ }
      \LinesNumbered
      \label{alg:extract}
      \KwIn {time axis $\vec{t}$, sub-NBA $\auto{subtask}^-$}
         \Comment*[r]{Initialization}
         $v_1 = v_0, c = 0,  \text{stack} = \emptyset $ \label{run:initialization}\;
           \Comment*[r]{Backtracking search}
           \While{\upshape $v_1 \neq \vertex{accept}$}{
             Obtain the subtask $e'=(v'_1, v_2')$ that is associated with $\vec{t}(c+1)$\;
           \For{\upshape $(v_1, v_2) \in \auto{subtask}^-$}{
             \If{\upshape   $ \gamma(v_1, v_2) = \gamma(v'_1, v'_2)$ {\bf and} $\gamma(v_1) = \gamma(v'_1)$ \label{run:edgelabel}}{
               Determine {\it (H$_1$)} essential clause, {\it (H$_2$)} essential robots, {\it (H$_3$)} negative clause, and {\it (H$_4$)} the sequence of vertices leading to  $v_2$\label{run:info}\;
                 $\text{stack.put}(v_2, c+1)$\label{run:put}\;

             }
           }
           $(v_1, c) = \text{stack.pop}()$\;
           }
           return the simple path leading to $v_1$\;

 \end{algorithm}
\stepcounter{mycounter}
 When a subtask $(v_1, v_2)$ in~$\auto{subtask}^-$ is matched with the subtask in $X_P$ that is completed at $\vec{t}(c+1)$, we keep track of information regarding {\it (\Alph{mycounter}$_1$)} the exact clauses that are\ satisfied in the vertex label $\gamma(v_1)$  and edge label $\gamma(v_1, v_2)$, since only one clause in each label is true by constraint~\eqref{eq:c}, and {\it (\Alph{mycounter}$_2$)} the subset of robots that participate to satisfy each literal in these clauses (see constraint~\eqref{eq:6}),
 {\it (\Alph{mycounter}$_3$)} the negative subformula in $\autop$ that is in conjunction  with the satisfied clause in {\it (\Alph{mycounter}$_1$)} but is replaced with $\top$ during the relaxation stage in Section~\ref{sec:prune}, and  {\it (\Alph{mycounter}$_4$)} the sequence of vertices in $\auto{subtask}^-$ that have been visited up to vertex $v_2$. These infomation will be used to formulate the generalized multi-robot path planning problems when planning the low-level paths in Section~\ref{sec:mapp}. In what follows, we discuss {\it (H$_1$)-(H$_3$)} in detail.

   \paragraph{(\Alph{mycounter}$_1$) Essential clauses:} Given the edge label or vertex label $\gamma=\bigvee_{p\in \ccalP} \bigwedge_{q\in \ccalQ_p} \ap{i}{j}{k,\chi}$ of subtask $(v_1, v_2)$ that is neither $\top$ nor $\bot$, we refer to the unique clause that is satisfied as the {\it essential clause} and denote by $\gamma^+$, which is determined by locating the binary variable $b_p$, defined in~Section~\ref{sec:labelconstraints} representing the truth of a clause, whose value is 1. That is, find the clause $\ccalC_{p}^{\gamma} \in \clause{\gamma}$ such that $b_p=1$. On the othe hand, when the vertex or edge label is $\top$, by default we define the essential clause as $\top$.
   \paragraph{(\Alph{mycounter}$_2$) Essential robots:} We refer to the set of robots whose collective behavior satisfies the positive literals in the essential clause as the {\it essential robots}. For $q$-th literal $\ap{i}{j}{k,\chi}$ in the essential clause $\ccalC_p^\gamma$ of a vertex or edge label of subtask $(v_1, v_2)$, we determine its essential robots by locating the binary variable $x_{uvr}$, representing one robot visiting a vertex in the routing graph $\ccalG$ that is associated with this literal, whose value is 1. That is, for each $v\in \ccalM_{\ccalV}^\mathsf{lits} (e, 0|1, p, q)$, find the robot $r\in \ccalM_\ccalK^\ccalV(v)$ such that $\exists\, (u,v)\in\ccalE_\ccalG$, making $x_{uvr}=1$.  On the other hand, if the essential clause is $\top$, there is no essential robots.
   \paragraph{(\Alph{mycounter}$_3$) Negative clause:} The collective behavior of essential robots satisfies the essential clauses in $\auto{subtask}^-$. For every essential clause if the associated label is neither $\top$ nor $\bot$, there exists a unique clause in the NBA $\autop$ that only differs from the essential clause in that it may contain the conjunction of the negative literals that were removed during the relaxation stage. We refer to this conjunction of negative literals  as the {\it negative clause} and denote by $\gamma^-$, which will be avoided when desinging the low-level paths in Section~\ref{sec:mapp}. By default, we  define the negative clause as $\top$, if the corresponding clause in $\autop$ does not have negative literals. In this way, the conjunction $\gamma^+ \wedge \gamma^-$ of an essential  clause and its corresponding negative clause correspond to  one {\it complete clause} in~$\autop$. Note that the complete clause of the vertex $v_1$ is implied by the complete clause of the edge that is immediatedly preceding the current subtask $(v_1, v_2)$.

   On the other hand, when the vertex label $\gamma(v_1)$ or edge label $\gamma(v_1, v_2)$ of subtask $(v_1, v_2)$ in $\auto{subtask}^-$ is $\top$, the associated essential clause is $\top$. However, the negative clause may not be $\top$, which happens when there exists a  clause in the corresponding label in $\autop$ that only includes negative literals. If the label is the edge label $\gamma(v_1, v_2)$, we randomly select one among clauses that only include negative literals. Otherwise,  if the label is the vertex label $\gamma(v_1)$, we select one as the negative clause (also the complete clause), that is  implied by the complete clause in the edge that is immediatedly preceding the current subtask $(v_1, v_2)$. We can obtain this edge since in step {\it (H$_4$)} keep track of the sequence of vertices that lead to vertex $v_2$.}

 %%  To this end, we define $c\in \mathbb{N}$ as the {\it global counter} which keeps track of the progress that has been made along the axis $\vec{t}$. Specifically, $c$ is the index of the subtask that  has  been completed most recently, therefore, $\vec{t}(c+1)$ denotes  the   completion time of the current subtask, which is the immediate one to be completed. Let $v_1$ denote the vertex that is the  most recently reached when following along the time axis.  We start from the initial vertex $v_1= v_0$ with global counter $c=0$ [line~\ref{run:initialization}, Alg.~\ref{alg:extract}]. At each iteration, we determine the set $H$ of time instants that are identical to $\vec{t}(c+1)$, of which the corresponding subtasks will be completed parallelly at the same time. We denote by $\gamma_{\text{edge}}$ and $\gamma_{\text{vertex}}$ the conjunciton of the associated edge labels  and vertex labels of those subtasks, respectively. [line~\ref{run:instants}, Alg.~\ref{alg:extract}].
 %%   Among all outgoing edges from the vertex $v_1$, we find the subtask $(v_1, v_2)$  whose edge label abd vertex label are logically equivalent to $\gamma_{\text{edge}}$ and $\gamma_{\text{vertex}}$, respectively [line~\ref{run:edgelabel}, Alg~\ref{alg:extract}]. Recall that when $|H|>1$, by definition~\ref{defn:id} of ID property, all independent subtasks  have vertex labels $\top$.    In this way, after the time instant $\vec{t}(c+1)$,  vertex $v_2$ becomes the most recently reached vertex. We then increase the global counter by $|H|$ and add it to a stack, a last-in-first-out container [line~\ref{run:put}, Alg.~\ref{alg:extract}]. The iteration will terminate until the accepting vertex $\vertex{accept}$ is reached.}


 %% \begin{algorithm}[t]
 %%      \caption{Extract the  run from $\auto{subtask}^-$ }
 %%      \LinesNumbered
 %%      \label{alg:extract}
 %%      \KwIn {time axis $\vec{t}$, relaxed NBA $\auto{subtask}^-$}
 %%         \Comment*[r]{Initialization}
 %%         $v_1 = v_0, c = 0,  stack = \emptyset $ \label{run:initialization}\;
 %%           \Comment*[r]{Backtracking search}
 %%         \While{\upshape $v_1 \not= \vertex{accept}$}{
 %%           Determine the set of identical time instants: $H = \{\vec{t}(h): \vec{t}(h) = \vec{t}(c+1), \;\forall\,  c+1 \leq h \leq |\vec{t}|\}$
 %%           and the conjunction of labels $\gamma_{\text{edge}}$ and $\gamma_{\text{vertex}}$ \label{run:instants}\;
 %%           \For{\upshape $(v_1, v_2) \in \auto{subtask}$}{
 %%             \If{\upshape   $ \gamma(v_1, v_2) = \gamma_{\text{edge}}$ {\bf and} $\gamma(v_1) = \gamma_{\text{vertex}}$ \label{run:edgelabel}}{
 %%                 Determine {\it (i)} essential clauses, {\it (ii)} essential robots {\it (iii)} the sequence of vertices \label{run:info}\;
 %%                 $stack.put(v_2, c+|H|)$\label{run:put}\;

 %%             }
 %%           }
 %%           $(v_1, c) = stack.pop()$\;
 %%         }

 %% \end{algorithm}

 %% \blue{When an edge $(v_1, v_2)$ in~$\auto{subtask}^-$ is matched with a subtask in~$X_P$, we keep track of information regarding {\it (i)} the exact clauses that are\ satisfied in the vertex label $\gamma(v_1)$ (if $\gamma(v_1) \neq \top, \bot$) and edge label $\gamma(v_1, v_2)$ (if $\gamma(v_1, v_2) \neq \top$), since only one clause in each label is true by~\eqref{eq:c}, and {\it (ii)} the subset of robots that participate to satisfy each literal in these clauses, {\it (iii)} the sequence of vertices in $\auto{subtask}^-$ that have been visited up to vertex $v_2$. We next discuss {\it (i)} and {\it (ii)} in detail.

 %%   \domanda{(i) Essential clauses} When $H=1$, given the edge label or vertex label $\gamma=\bigvee_{p\in \ccalP} \bigwedge_{q\in \ccalQ_p} \ap{i}{j}{k,\chi}$, we refer to the clause that is satisfied as the {\it essential clause} and denote by $\gamma^+$, which is determined by locating the binary variable, defined in~Section~\ref{sec:labelconstraints} representing the truth of a clause, whose value is 1. That is, $b_p=1, \, \forall\, \ccalC_{p}^{\gamma} \in \clause{\gamma}$. On the other hand, when $|H|>1$, we first determine the essential clauses for the elementary subtasks, and then determine the essential clause for the composite substask that is the conjunction of these clauses.
 %%   \domanda{(ii) Essential robots} We refer to the set of robots whose collective behavior satisfies the literals in the essential clause as the essential robots. For each literal $\ap{i}{j}{k,\chi}$ in the essential clause for each elementary subtask, we determine its essential robots by locating the binary variable, representing one robot visiting a vertex in the routing graph $\ccalG$ associate with this literal, whose value is 1. That is, $x_{vr}=1, \, \forall\, v\in \ccalM_{\ccalV}^\mathsf{lits} (e, 0|1, p, q),\,\forall\, r\in \ccalM_\ccalK^\ccalV(v)$.




 %% \begin{cexmp}
 %%   The time axis obtained from individual timeline $\{t_{1,2}, t_{2,1}, t_{2,4}\}$ is  $\vec{t} = \{7, 17\}$, since each time instant unless the starting instant 0 corresponds to an edge label.  The detailed search over the NBA $\auto{subtask}^-$, also $\auto{relax}$, in Fig.~\ref{fig:nba_m} is shown Table~\ref{tab:search}, where the first column lists the vertex that is being searched and the second column records the set $stack$ once the search over the left-side vertex is over. The run in the relaxed NBA $\auto{relax}$ in Fig.~\ref{fig:nba_m} is $v_0 \to v_1 \to v_3 \to v_6(\vertex{accept})$. That is, robots $[2,1], [2,4]$ and $[1,2]$ are involved in the subtask $(v_1,v_3)$ that occurs at time instant  $7$, and robots $[2,1] $ and $[2,4]$ are involved in the subtask $(v_3, v_6)$ that occurs at time instant $17$.
 %% \end{cexmp}
 %% \begin{table}[t]
 %%   \caption{Extract a run from automaton $\auto{subtask}^-$}\label{tab:search}
 %%   \centering
 %%   \red{\begin{tabular}{cl}
 %%     \toprule
 %%     vertex & $stack$\\
 %%     \midrule
 %%     $v_0$ & $\{(v_1, 1)\}$\\
 %%     $v_1$ & $\{(v_4, 2), (v_2, 2), (v_3, 2)\}$\\
 %%     $v_4$ & $\{(v_2, 2), (v_3, 2)\}$\\
 %%     $v_2$ & $\{(v_3, 2)\}$\\
 %%     $v_3$ & $\{(\vertex{accept}, 3)\}$\\
 %%     $\vertex{accept}$ & $\emptyset$\\
 %%     \bottomrule
 %%   \end{tabular}}
 %% \end{table}

 {\subsection{Generalized multi-robot path planning}\label{sec:mapp}
   Using  the relation between the NBA  $\autop$ and the  sub-NBA $\auto{subtask}^-$, in $\autop$ we can find the counterpart  of the  simple path in $\auto{subtask}^-$ obtained in Section~\ref{sec:run}. We denote by $\theta_{\phi}$ this counterpart, which corresponds to  a sequence of temporally sequential subtasks. Our goal is to find a collection of executable paths for the robots that induce the simple path $\theta_{\phi}$ in $\autop$; see also block 7 in Fig.~\ref{fig:overview}. To achieve this, we formulate  the execution of each subtask in $\theta_{\phi}$ into a {\it generalized multi-robot path planning problem (GMRPP)}. Compared to the classical multi-robot path planning that, given an initial robot configuration, designs paths to reach the target configuration, the GMRPP imposes extra constraints on the intermediate configuration.

 %% \begin{figure}[t]
 %%  \centering
 %%  \includegraphics[width=0.9\linewidth]{adjustment.pdf}
 %%  \caption{\blue{Adjustment of time spans. Consider three consecutive subtasks $e_1, e_2, e_3$. Every green horizontal bar depicts the time interval when the vertex label of one subtask is true and the red triangle marks the satisfaction of the edge label, i.e., the completion of the subtask. The upper part illustrates the general relation between the spans of subtasks (unaligned in the vertical direction for better illustration) and the lower  part shows the overlapping at the endpoints after the alignment.}}
 %%  \label{fig:adjustment}
 %% \end{figure}
 %% We first  align the timing of subtasks, consisting of two consecutive vertices in the found run $\theta_{\phi}$,  along the timeline. Specially, we fix the completion time of each subtask as an ``anchor' and then align the time interval when the associated vertex label is true,  so that the activation time of this subtask is the same as  the completion time   of the previous subtask, and the last time when the associated vertex label is true is the same as the completion time of this subtask; see also Fig.~\ref{fig:adjustment}. In this way,  the union of all spans of subtasks covers the whole timeline and the spans of two consecutive subtasks only overlap at the endpoint. Also, the time interval when the vertex label is true is the same as the span of the subtask. To realize the alignment, each  pair of  time instants in $t_{r.j}$ that specify the time interval when a vertex label is true will be modified so that the first time instant equals the completion of the previous subtask and the second one equals the completion of the current subtask that this vertex label corresponds to.

 %% {Note that the plan $\{p_{r,j}\}$ and the timeline $\{t_{r,j}\}$ still satisfy the constraints in Section~\ref{sec:milp} except~\eqref{eq:4}. Because we adjusted the timeline by fixing the time instants associated with edge labels, only constraints related to time instants associated with vertex labels can be affected, that is, \eqref{eq:4}, \eqref{eq:17} and~\eqref{eq:20}. Specifically, the completion time of the subtask is the same as the completion time of the corresponding vertex label, thus, the containtment in~\eqref{eq:17} is satisfied. Furthermore, the activation time of the current subtask is same as the completion time of the subtask immediately preceding it, thus, temporal constraint~\eqref{eq:20} is satisfied. Constraints in~\eqref{eq:4} can be  violated since the alignment can bring forward the activation time of the vertex label or delay the completion time of the vertex label, which might make the time difference between visitation of connecting vertices slightly less than the required travelling time. However, since the travelling time used in~\eqref{eq:4} is the shortest travelling time between regions, the constraints~\eqref{eq:4} are the approximation of the real situation, thus, violation of~\eqref{eq:4} is acceptable and will be addressed in Section~\eqref{sec:solution2mapp}.}

 {Observe that given the completion time of two consecutive subtasks in the time axis $\vec{t}$, we can obtain the tightest span of the vertex label of the second subtask. Specifically, the activation time, at the latest, of the vertex label of the second subtask is exactly one time instant later than the completion time of the first subtask; see also constraint~\eqref{eq:20} that captures the temporal relation between two subtasks. On the other hand, the earliest completion time of the vertex label of the second subtask is exactly one time instant earlier than the completion time of the second subtask; see also constraint~\eqref{eq:17} that captures the temporal relation for the same subtask.  To design the low-level paths,  we let each robot visit waypoints in its individual plan $p_{r,j}$ sequentially, maybe at different time instants than those in its timeline $t_{r,j}$ when taking the concrete environment into account, but relative temporal relations with other robots (precedence or simultaneity) are kept. Also we maintain the tightest span of the vertex label of the considered subtask between completion time of two consecutive subtasks.}

 To this end, for each robot $[r,j] \in \{\ccalK_j\}$, we define a {\it local counter} $\zeta_{r,j} \in \mathbb{N}$  that  keeps track of how much progress has been made along the individual plan $p_{r,j}$. Specifically, $\zeta_{r,j} = a$ indicates that the waypoint in the plan $p_{r,j}$ most recently visited by  robot $[r,j]$ is the $a$-th waypoint. Furthermore, recall the  global clock $c$ that monitors the index of the most recently completed subtask  along the time axis $\vec{t}$, which also captures the execution progress along the simple path  $\theta_{\phi}$. In what follows, we provide the ingredients for the construction of GMRPP.

 %%  \blue{Next, we discuss the correspondence between clauses in the NBA $\auto{subtask}^-$ and those in $\autop$ in two cases:
 %% \domanda{(i) Label is neither $\top$ nor $\bot$} Given a subtask $e$ contained in the run $\theta_{\phi}$ in $\auto{subtask}^-$, only one clause (a conjunction of positive literals) can be true in every associated label $\gamma$, vertex or edge label by~\eqref{eq:c}, if it is neither $\top$ nor $\bot$. We refer to this clause as the {\it satisfied clause} and denote by $\gamma^+$. For every satisfied clause in $\auto{subtask}^-$, there exists a unique clause in the pruned NBA $\autop^-$ that only differs from the satisfied clause in that it may contain the conjunction of the negative literals that were removed  during the relaxation stage . We refer to this conjunction of negative literals  as the {\it negative clause} and denote by $\gamma^-$, which is defined as $\top$ by default, if the corresponding clause does not have negative literals. In this way, each label is associated with a satisfied clause and a negative clause which together constitute one clause.

 %% \domanda{(ii) Label is $\top$}  When the vertex or edge label is $\top$, the associated satisfied clause is $\top$ by default. However, the negative clause may not be $\top$, which happens when all clauses in the corresponding label in $\autop^-$ only include negative literals. For the edge label, we randomly select one of its clauses as the negative clause. For the vertex label, we select one among clauses that only include negative literals that is not mutually exclusive with the conjunction of the satisfied and negative clauses associated with  the edge label of the subtask that is immediately preceding the current subtask. Otherwise, if the robot locations in the designed low-level paths  satisfy the edge lalel of the previous subtask in $\autop^-$, then the next robot locations should satisfy the negative clause associated with the vertex label of the current subtask. Due to the mutual exclusion,  this situation is hard to realize.}  In what follows, we describe  the ingredients of a single instance of the generalized multi-robot path planning problem [line~\ref{seq:ingredients}, Alg.~\ref{alg:sequentialMAPP}].

 \subsubsection{Ingredients of GMRPP:}\label{sec:gmmpp1} Consider a subtask $e = (v_1, v_2)$ generated by the simple path $\theta_{\phi}$ that is the next one to be completed. Let $\gamma_1^+$ and $\gamma_1^-$ denote the essential and negative clauses associated with the vertex label $\gamma(v_1)$, respectively. Similarly, we define $\gamma_{1,2}^{+}$ and $\gamma_{1,2}^{-}$  for the edge label $\gamma(v_1, v_2)$. The goal of a GMRPP formulated  is to determine a collection of executable paths such that robots complete the current subtask (by satisfying the complete clause  $\gamma_{1,2}^+ \wedge \gamma_{1,2}^-$ at the end while respecting the complete clause $\gamma_1^+ \wedge \gamma_1^-$ en route) and automatically activate the next subtask after completion since the complete clause $\gamma_{1,2}^+ \wedge \gamma_{1,2}^-$ implies the complete clause associated with the starting vertex of the next subtask. We refer to $\gamma_1^-$ as the {\it running constraint} and $\gamma_{1,2}^- $  as the {\it terminal constraints}.
%% Let $\gamma_1^-$ denote the negative clause associated with the vertex label $\gamma(v_1)$. Let $\gamma_2^{+,1} (\gamma_2^{-,1}) $ and $\gamma_2^{+,2} (\gamma_2^{-,2})$ denote the satisfied (negative) clause associated with the edge label $\gamma(v_1, v_2)$ and the vertex label of the next subtask, respectively. Then, we define $\gamma_2^+ = \gamma_2^{+,1} \wedge \gamma_2^{+,2}$ and $\gamma_2^- = \gamma_2^{-,1} \wedge \gamma_2^{-,2}$. As mentioned  in the definition of subtasks (see Definition~\ref{defn:subtask}), the completion of a subtask requires the satisfaction of its edge label while respects its vertex label. Thus, the goal of a GMRPP is to determine a collection of executable paths that satisfy the clauses $\gamma^+_2 \wedge \gamma^-_2$ at the end and respect the clause $\gamma_1^-$ en route.\endnote{We do not consider the satisfied clause, denoted by $\gamma_1^+$, in the vertex label of the current subtask since it is satisfied at the end of the previous subtask and will maintain true since involved robots remain idle, same as that $\gamma_2^{+,2}$ of the next vertex label is addressed when dealing with the current subtask.} That is, robots complete the current subtask (by satisfying the corresponding edge label $\gamma_2^{+,1}\wedge \gamma_2^{-,1}$ and the vertex label $\gamma_1^-$) and activate the next subtask (by satisfying the next vertex label $\gamma_2^{+,2}\wedge \gamma_2^{-,2}$). We refer to $\gamma_1^-$ as the {\it running constraint},  $\gamma_2^-$ as the {\it terminal constraint}, and $\gamma_2^+$ as the {\it target}.

 Note that not all robots need to move for one specific subtask, since only the set of essential robots are responsible for the satisfaction of this subtask. In what follows, we introduce two moving schemes with the difference of whether the full set or only a subset of robots move.   We first determine the subset of robots that should move in both schemes in 3 cases:
 \stepcounter{mycounter}
 \paragraph{(\Alph{mycounter}$_1$) Essential robots associated with the constraint $\gamma_1^+$:}\label{sec:essential_a} We collect essential robots associated with essential clauses in $\gamma_{1}^{+}$ in the sets $\ccalR_{1}$,  where robots need to remain at certain target regions related to the current subtask.
 \paragraph{(\Alph{mycounter}$_2$) Essential robots associated with the target $\gamma_{1,2}^{+}$:}\label{sec:essential_b}  We collect essential robots associated with the essential clause  $\gamma_{1,2}^{+}$ in the set $\ccalR_{1,2}$, where  robots need to reach certain target regions related to the current and next subtasks.
 %% \paragraph{(\Alph{mycounter}$_3$) Essential robots associated with subsequent subtasks:} These robots move simultaneously with the first two types of robots heading towards  waypoints associated with subsequent subtasks of the current subtask $e$. We collect robots in the set $\ccalR'_{1,2}$ and identify them in the following way. First, we identify the completion time  of the current subtask, which is given by $\vec{t}(c+1)$.  Next, we iterate over the remaining robots that are not in $\ccalR_1 \cup \ccalR_{1,2}$. For every such robot $[r',j']$, the time when it should visit the next waypoint based on its local counter $\zeta_{r',j'}$ is given by $t_{r',j'}(\zeta_{r',j'}+1)$. Note that {$t_{r', j'}(\zeta_{r',j'}+1) > \vec{t}(c+1)$}, since we proceed along the simple path $\theta_{\phi}$ and the completion time of  subtasks that have not been considered, by the precedence relation in~\eqref{eq:12} and the increasing time axis, will be larger than that of the current subtask. Finally, we calculate the time difference $\Delta t = t_{r', j'}(\zeta_{r',j'}+1) - \vec{t}(c+1)$  and then check whether the robot $[r', j']$ can arrive at the target region $p_{r',j'}(\zeta_{r',j'}+1)$  within time $\Delta_t$ starting from  its current location by taking the shortest route. {If not, robot $[r', j']$ should move simultaneously when completing the current subtask.}
 \paragraph{(\Alph{mycounter}$_3$) robots associated with running and terminal constraints:}\label{sec:essential_c} The robots in this case  are different from the above-mentioned three types due to that they are related to negative clauses $\gamma_1^-$ or $\gamma_{1,2}^-$. These robots navigate without specific targets, unless they appear in the first 3 cases, only to satisfy the threshold imposed by the negative literals on the number of certain type of robots that appear at some regions. We collect them in the set $\ccalR^-$, which contains all robots that belong to certain types mentioned in $\gamma_1^-$ or $\gamma_{1,2}^-$. That is, $\ccalR^- = \{\{\ccalK_j\}: \neg \ap{i}{j}{k} \in \mathsf{lits}^- (\gamma_1^-  \vee \gamma_{1,2}^-) \}$.

 \begin{rem}
   Note that we collect robots that are directly involved in the current subtask $e$. However, robots that pariticipate in subsequent subtasks of $e$ can move simultaneously with these robots, so that after the current subtask $e$ is completed, these robots associated with subsequent subtasks have traversed part of their routes towards finishing their respective subtasks. We will present this extension in Section~\ref{sec:extension_essential}.
 \end{rem}

Let $\ccalR = \ccalR_1 \cup\ccalR_{1,2}  \cup \ccalR^-$ denote the set that collects all robots that need to move in both schemes, and $\ccalR_0 = \{\ccalK_j\}\setminus\ccalR$ collect robots that do not need to move in the partial-moving sheme but move in the full-moving sheme. In what follows, we provide the partial-moving scheme which shares most similarity with the full-moving scheme. First, we define by $X_I$ and $X_G$ the sets of initial and target locations, respectively, for robots in $\ccalR$  such that $X_I(r,j) \in S$ and $X_G(r,j)\subseteq S$ are the initial  and target locations of robot $[r,j] \in \ccalR$. Specifically, the initial robot locations are those where the robots stand at the end of the subtask immediately preceding $e$. Moreover, the target region of  robot $[r,j] \in \ccalR_{1,2}$ is determined  by its associated literal in $\gamma_{1,2}^+$, which is also given by  $p_{r,j}(\zeta(r,j)+1)$. Similarly, the target region of robot $[r,j] \in \ccalR_{1}$ can also be determined by its associated literal in $\gamma_1^+$. %% Furthermore, the target region of robot $[r',j'] \in \ccalR'_{1,2}$ is the  location from where robot $[r',j']$ can reach the region $p_{r',j'}(\zeta(r',j')+1)$ within time $\Delta t$ by taking the shortest route.
 %% in the new environment $S'$. If the selected target location of robot $[r',j']$ has already been assigned to another robot in $\ccalR'_{1,2}$, then we select another free cell on the shortest route to be this robot's target location, which is close to the previously selected occupied cell and has not been assigned.

Finally, let $\tau'_{r,j}$ denote the path segment of robot $[r,j] \in \ccalR$, where $\tau'_{r,j}(t)$ denotes the robot location at time $t$ for $ t = 0,  \ldots, T$, where time instants 0  and $T$ correspond to the completion time of the immediately preceding subtask and the current subtask, respectively. Next, the generalized multi-robot path planning problem in the partial-moving scheme, adapted from~\cite{yu2016optimal}, is defined as follows.
 \begin{defn}[(Generalized multi-robot path planning)]\label{defn:gmmpp}
    Given a discrete environment $E$, a set of robots $\ccalR$ where $\ccalR = \ccalR_1 \cup\ccalR_{1,2} \cup \ccalR^-$, a set of initial locations $X_I$ and a set of target regions $X_G$, the running constraint $\gamma_1^-$, the terminal constraints $\gamma_{1,2}^-$, and the horizon $T$, find a collection of path segments $\tau'_{r,j}$ for all robots $[r,j]\in \ccalR$ such that {\it (i)} every robot $[r,j] \in \ccalR_{1,2}$ starts from the initial location and arrives at the target region at time instant $T$, i.e., $ \tau'_{r,j}(0) = X_I(r,j)$ and  $ \tau'_{r,j}(T) \in X_G(r,j)$ for $[r,j] \in  \ccalR_{1,2}$. Furthermore, every robot $[r,j] \in \ccalR_1$ remains in the target region for all time except $0$ and $T$, that is, $ \tau'_{r,j}(0) = X_I(r,j)$ and $\tau'_{r,j}(t) \in X_G(r,j)$ for all $t=1,\ldots, T-1$;
  %% {\it (ii)} the paths of  any two distinct robots $[r,j]$ and $[r', j']$ are collision-free, that is, there does not exist  a atime instant $t \in [T+1]$ such that $\tau'_{r,j}(t) = \tau'_{r',j'}(t)$ (meet collision, that is, two robots occupy the same cell at the same time) or  $\tau'_{r,j}(t) = \tau'_{r',j'}(t-1) \wedge \tau'_{r',j'}(t) = \tau'_{r,j}(t-1)$ (head-on collision, that is, two robots at adjacent cells switch locations with each other);
  and {\it (ii)} the paths $\{\tau'_{r,j}\}$ must satisfy the running constraint $\gamma^-_1$ for all time except at $0$ and $T$, and they also satisfy the terminal constraint $\gamma^-_{1,2}$ at time instant $T$.
 \end{defn}

 \begin{figure}[!t]
   \centering
   \includegraphics[width=0.9\linewidth]{timeline.pdf}
   \caption{The time relation within one GMRPP. The essential and negative clauses are aligned with the time instants when they should be satisfied.}
   \label{fig:timeline}
 \end{figure}

 Fig.~\ref{fig:timeline} illustrates the timing relations of essential and negative clauses.  The paths do not need to satisfy  $\gamma_1^+$ and $\gamma_1^-$ at time instants 0 and  $T$ since the tightest span of the vertex label of the current subtask can be one time instant later than the completion of the immediately preceding subtask, which is indicated by time 0, and one time instant earlier than the completion of the current subtask, which is indicated by time $T$. In the full-moving scheme, robots in $\ccalR_0$ can move but, like those in $\ccalR^-$, there is no specific target regions for robots in $\ccalR_0$.  In the following Section~\ref{sec:solution2mapp} we discuss how to solve the GMMPP with horizon $T$.  The paths returned by this GMRPP complete the subtasks $(v_1, v_2)$  and meanwhile activate the vertex label of $v_2$, i.e., the next subtask. %% They navigate only to move out of the way of robots that head for their targets. Therefore, the new environment $E'$ is the same as the original one $E$.
 The rest will remain the same as in the partial-moving sheme.

 %% Note that when the end vertex $v_2$ does not have a self-loop, that is, $v_2$ is $\vertex{accept}$ (only $\vertex{accept}$ can have no self-loop when acting as the end vertex according to condition \hyperref[cond:c]{\it (c)} in Definition~\ref{defn:run}), we do not consider robots in $\ccalR_2$ and the terminal constraint $\gamma_2^-$. Therefore, the horizon of the GMRPP is $T$.



 %% \subsubsection{$\gamma(v_2)=\bot$}\label{sec:gmmpp2} Given the current subtask $(v_1, v_2) \in \theta_{\phi}$, when $\gamma(v_2) = \bot$, we have $v_2 = \vertex{accept}$; see also Fig.~\ref{fig:absence}.  In this case, we consider these two subtasks $(v_1, \vertex{accept})$ and  $(\vertex{accept}, v_{\text{next}})$ together. First, we treat the edge label $\gamma(\vertex{accept}, v_{\text{next}})$ as if it were the vertex label of $\vertex{accept}$, since $\gamma(\vertex{accept}, v_{\text{next}})$ should be satisfied one step later after the subtask $(v_1,  \vertex{accept})$, acting like the vertex label of $\vertex{accept}$. Therefore, similar to case~\hyperref[sec:gmmpp1]{{\it 1)}}, we obtain the negative clause $\gamma^-_2$ and the subset of robots $\ccalR^-$  from the label $\gamma(\vertex{accept}, v_{\text{next}})$ and $\gamma_2^-$ should still be satisfied at time instant $T+1$. The subset $\ccalR_2$ is empty since $\gamma(\vertex{accept}, v_{\text{next}})$ is $\top$. Next, we consider extra constraints than case~\hyperref[sec:gmmpp1]{{\it 1)}}, which are related to the activation of vertex label of $v_{\text{next}}$. Specifically, we require that $\gamma(v_{\text{next}})$ be activated at time instant $T+2$. To this end, let $\ccalR'_2$ collect all essential robots related to the  essential clause of $\gamma(v_{\text{next}})$ so that the set $\ccalR$ of robots that need to move also includes $\ccalR'_2$ and robots in $\ccalR'_2$ should reach target regions at time instant $T+2$. Furthermore, we denote by $\gamma'^-_2$ the negative clause related to $\gamma(v_{\text{next}})$ and the set of robots $\ccalR^-$ should include all robots of some types that appear in negative literals in $\gamma_2'^-$. Therefore, $\gamma'^-_2$ is also a terminal constraint which should be satisfied at time instant $T+2$. In the following Section~\ref{sec:solution2mapp} we discuss how to solve the above  generalized multi-robot path planning problem with given horizon  $T+2$. The paths returned by this GMRPP complete the subtasks $(v_1, \vertex{accept})$ and  $(\vertex{accept}, v_{\text{next}})$  and meanwhile activate the vertex label of $v_{\text{next}}$.

%% In what follows, we define a template for the generalized multi-robot path planning adapted from~\cite{yu2016optimal}, which can be instantiated based on different scenarios.  Each instantiated problem imposes constraints on the path $\tau'_{r,j}$ for each robot $[r,j] \in \ccalR$. We denote by  $\tau'_{r,j}(t)$ the robot location at time instant  $ t = 0,  \ldots, T, \ldots, T+x$, where the time instant $T$ is when robots reach their target regions associated with the current subtask, and the extension term $x\in \mathbb{N}$ is problem-specific.
%% \begin{defn}[Template for the generalized multi-robot path planning]\label{defn:gmmpp}
%%     Given a discrete environment $E'$, a set of robots $\ccalR=\ccalR_1 \cup \ccalR_{\setminus1} $, a set of initial locations $X_I$ and a set of target regions $X_G$, the constraints $\gamma^-$ and the horizon $T+x$, along with the time interval $I = \{0, \ldots, T+x\}$, find a collection of path segments $\tau'_{r,j}$ for all robot $[r,j]\in \ccalR$ such that {\it (i)} every robot $[r,j] \in \ccalR_{\setminus1}$ starts from the initial location and arrives at the target region at time instants $T+y\in I$ where $y\in \{0,\ldots,x\}$, i.e., $ \tau'_{r,j}(0) = X_I(r,j)$ and  $\tau'_{r,j}(T+y) \in X_G(r,j)$ for $[r,j] \in \ccalR_{\setminus1}$. Furthermore, every robot $[r,j] \in \ccalR_1$ remain in the target region over a time interval $I_1\subseteq I$, that is, $\tau'_{r,j}(t) \in X_G(r,j)$ for $t \in I_1$; {\it (ii)} the paths of  any two distinct robots $[r,j]$ and $[r', j']$ are collision-free, that is, there does not exist time instant $t\in I$ such that $\tau'_{r,j}(t) = \tau'_{r',j'}(t)$ (meet collision, that is, two robots occupy the same cell at the same time) or $\tau'_{r,j}(t) = \tau'_{r',j'}(t-1) \wedge \tau'_{r',j'}(t) = \tau'_{r,j}(t-1)$ (head-on collision, that is, two robots at adjacent cells switch locations with each other); and {\it (iii)} the paths $\{\tau'_{r,j}\}$ must satisfy the constraint $\gamma^-$ over a time interval $I_2\subseteq I$ or at a specific time instant $t\in I$.
%% \end{defn}

%% When the vertex label of $v_2$ exists, the instantiated GMRPP is as follows.
%%   \begin{defn}[Instantiated GMRPP when $\gamma(v_2)\neq \bot$]\label{defn:gmmpp1}
%%     Given a discrete environment $E'$, a set of robots $\ccalR = \ccalR_1 \cup\ccalR_{1,2} \cup \ccalR_{2} \cup \ccalR'_{1,2}$, a set of initial locations $X_I$ and a set of target regions $X_G$, the running constraint $\gamma_1^-$, the terminal constraints $\gamma_{1,2}^-$ and $\gamma_2^-$, and the horizon $T+1$ (thus, $x=1$), find a collection of path segments $\tau'_{r,j}$ for all robot $[r,j]\in \ccalR$ such that {\it (i)} every robot $[r,j] \in \ccalR\setminus\ccalR_1$ starts from the initial location and arrives at the target region at time instants $T$. Furthermore, every robot $[r,j] \in \ccalR_1$ remain in the target region for all $t = 1, \ldots, T-1$;
%%   {\it (ii)} same as (ii) in the template; and {\it (iii)} the paths $\{\tau'_{r,j}\}$ must satisfy the running constraint $\gamma^-_1$ for all $t = 1, \ldots, T-1$, and they also satisfy the terminal constraint $\gamma^-_{1,2}$ at time instant $T$ and $\gamma^-_{2}$ at time instant $T+1$.
%% \end{defn}

%%  In this instantiation, time instants $0$, $T$ and $T+1$ indicate the completion time of the immediately preceding subtask, the completion time of  the current subtask and the activation time of the next subtask, respectively. The paths do not need to satisfy the running constraint $\gamma_1^-$ at time instants 0,  $T$ and $ T+1$ since the tightest span of the vertex label of the current subtask can be one time instant later than the completion of the immediately preceding subtask and one time instant earlier than the completion of the current subtask.

%%  \subsubsection{$\gamma(v_2)=\bot$}\label{sec:gmmpp2} Given the current subtask $(v_1, v_2) \in \theta_{\phi}$, when $\gamma(v_2) = \bot$, we have $v_2 = \vertex{accept}$. In this case, we consider these two subtasks $(v_1, v_2)$ and $(v_2, v_{\text{next}})$ together. First, we treat the edge label $\gamma(v_2, v_{\text{next}})$ as if it were the vertex label of $v_2$, since $\gamma(v_2, v_{\text{next}})$ should be satisfied one step later after the subtask $(v_1, v_2)$, acting like the vertex label of $v_2$. Therefore, similar to case~\hyperref[sec:gmmpp1]{{\it 1)}}, we obtain the negative clause $\gamma^-_2$ and the subset of robots $\ccalR^-$  from the label $\gamma(v_2, v_{\text{next}})$ and $\gamma_2^-$ should still be satisfied at time instant $T+1$. The subset $\ccalR_2$ is empty since $\gamma(v_2, v_{\text{next}})$ is $\top$. Next, we consider extra constraints compared to the instantiation in case~\hyperref[sec:gmmpp1]{{\it 1)}}, which are related to the vertex label of $v_{\text{next}}$. Specifically, we require that $\gamma(v_{\text{next}})$ be activated at time instant $T+2$ (thus, $x=2$). To this end, let $\ccalR'_2$ collect all essential robots related to the  essential clause of $\gamma(v_{\text{next}})$ so that the set $\ccalR$ of robots that need to move also includes $\ccalR'_2$ and robots in $\ccalR'_2$ should reach target regions at time instant $T+2$. Furthermore, we denote by $\gamma'^-_2$ the negative clause related to $\gamma(v_{\text{next}})$ and the set of robots $\ccalR^-$ should include all robots of some types that appear in negative literals in $\gamma_2'^-$. Therefore, $\gamma'^-_2$ is also a terminal constraint which should be satisfied at time instant $T+2$. In the following Section~\ref{sec:solution2mapp} we discuss how to solve the above  generalized multi-robot path planning problem with given horizon  $T+2$. The paths returned by this instantiation complete the subtasks $(v_1, v_2)$ and $(v_2, v_{\text{next}})$ and meanwhile activate the vertex label of $v_{\text{next}}$, thus, preparing for the start of the suffix part or robots returning to initial locations to make the suffix part a loop.
 %% \subsubsection{Robots return to the initial locations} When the robots need to return to initial locations of the prefix plan, all robots need to move, therefore, $\ccalR = \{\ccalK_j\}$.
 %% The initial locations $X_I(r,j)$ are the final  locations in~\hyperref[sec:gmmpp2]{{\it 2)}} that drive the transition to vertex $v_{\text{next}}$  and the target locations $X_G(r,j)$ are the final locations of the  prefix plan, which should be visited by robots in $\ccalR$ at time instant $T$, thus, $x=0$. We initialize horizon  $T$  as the  longest travelling time between the initial locations and target locations over robots in $\ccalR$. Furthermore, the set $\ccalR_1$ is empty since
 %% and  also the running constraint $\gamma_1^-$ determined by the negative clause in $\gamma(v_{\text{next}})$ is satisfied for all $t=1, \ldots,T$, where  the last time instant $T$ is included since there is no edge transition and the target locations still correspond to the vertex label $\gamma(v_{\text{next}})$.

 {\begin{algorithm}[!t]
    \caption{Executable multi-robot path planning}
    \algorithmendnote{The right-side time instant $\vec{t}(c+1)$ in~line~\ref{seq:axis} is the one before updated.}
      \LinesNumbered
      \label{alg:sequentialMAPP}
      \KwIn {environment $E$,  robot team $\{\ccalK_j\}$, subtask sequence $\theta_{\phi}$, waypoint sequence $\{p_{r,j}\}$, time sequence $\{t_{r,j}\}$, NBA $\autop$ and $\auto{subtask}^-$}
      \Comment*[r]{Initilization}
        $\tau_{r,j} = s_{r,j}^0 $, $\zeta_{r,j} = 0, \forall\, [r,j] \in \{\ccalK_j\}$, $c = 0$ \label{seq:initilization}\;
      \For{$e = (v_1, v_2) \in \theta_{\phi}$ \label{seq:terminate_1}}{
        \Comment*[r]{Solving GMRPP}
        \If{\upshape $\vec{t}(1)=0$ \label{seq:initial}}{
          $\zeta_{r,j} = \zeta_{r,j} + 1, \; \forall \, [r,j] \in \ccalR_{1,2}$ \label{seq:counter_initial}\;
          $c = c + 1$ \label{seq:c_initial}\;
        }
        \Else{
          Formulate the GMRPP  \label{seq:ingredients}\;
          Solve the GMRPP for horizon $T$ as in Section~\ref{sec:solution2mapp} to obtain paths $\tau'_{r,j}$. If no solution exists, increment $T$\label{seq:mapp}\;
          \Comment*[r]{Update}
          %% \If{\upshape $v_2 = \vertex{accept}$  \label{seq:terminate_1}}{
          %%   If $v_2$ has a self-loop, $\tau_{r,j} = \tau_{r,j} \cdot \tau'_{r,j}[1:T_e+1], \;\forall \,[r,j] \in \ccalR $, and repeat $T_e+1$ times the last waypoint in $\tau_{r,j}$ for robots in $[r,j] \in \{\ccalK_j\} \setminus \ccalR$; otherwise, add $\tau'_{r,j}[1:T_e]$ to $\tau_{r,j}$ and repeat $T_e$ times the last waypoint in $\tau_{r,j}$ \label{seq:finalpath}\;
          %%   {\bf break}\;
          %% }
          %% %% \ElseIf{\upshape $v_2 = \vertex{accept}$ {\bf and} $\gamma(v_2) = \bot$ \label{seq:terminate_2}}{
          %% %%   $\tau_{r,j} = \tau_{r,j} \cdot \tau'_{r,j}[1:T_e], \;\forall \,[r,j] \in \ccalR $, and repeat $T_e$ times the last waypoint in $\tau_{r,j}$ for robots in $[r,j] \in \{\ccalK_j\} \setminus \ccalR$ \label{seq:finalpath}\;
          %% %%   {\bf break}\;
          %% %% }

            $\tau_{r,j} = \tau_{r,j} \cdot \tau'_{r,j}[1:T_e], \;\forall \,[r,j] \in \ccalR $, and repeat  $T_e$ times  the last waypoint in $\tau_{r,j}$ for robots in $[r,j] \in \{\ccalK_j\} \setminus \ccalR$ \label{seq:path}\;
            $t_{r,j}(\zeta) =  t_{r,j}(\zeta)  + T_e - (\vec{t}(c+1) - \vec{t}(c))$, $\forall \,\zeta \geq  \zeta_{r,j}$, and $ \forall\, [r,j] \in \{\ccalK_j\} $ \label{seq:timeline} \;
            $\vec{t}(c') = \vec{t}(c') + T_e - (\vec{t}(c+1) - \vec{t}(c))$, $ \forall \, c' \geq c+1$  \label{seq:axis}\;
            $\zeta_{r,j} = \zeta_{r,j} + 1, \; \forall \, [r,j] \in \ccalR_{1,2}$ \label{seq:counter}\;
            $c = c + 1$ \label{seq:c}\;

        }
      }
      %% \If{\upshape close the loop for the suffix plan}{
      %%   Formulate the GMRPP by determining the set $\ccalR$ of robots required to move, the updated environment $E'$, sets of initial locations $X_I$ and target locations $X_G$, running constraint $\gamma_1^-$, and horizon $T$ \label{seq:ingredients_loop}\;
      %%   Solve the GMRPP for horizon $T$ as in Section~\ref{sec:solution2mapp} to obtain paths $\tau'_{r,j}$. If no solution exists, increment $T$ by a constant\label{seq:mapp_loop}\;
      %%    $\tau_{r,j} = \tau_{r,j} \cdot \tau'_{r,j}[1:T_e], \;\forall \,[r,j] \in \ccalR $ \label{seq:finalpath}\;
      %% }
\end{algorithm}}

 \subsubsection{Sequential solving of  GMRPP to find low-level paths that induce the simple pathx $\theta_{\phi}$:}
 The algorithm to design executable paths based on GMRPP under the  partial-moving scheme is outlined in Alg.~\ref{alg:sequentialMAPP}.  We initialize all local counters and the global clock as 0 [line~\ref{seq:initilization}, Alg.~\ref{alg:sequentialMAPP}]. The algorithm  terminates when iteration over  the subtasks in the simple path $\theta_{\phi}$ is finished [line~\ref{seq:terminate_1}, Alg.~\ref{alg:sequentialMAPP}].  We first check whether the first time instant $\vec{t}(1)$ in the time axis is 0. If $\vec{t}(1)=0$, then the first subtask in the simple path $\theta_{\phi}$, that is, the edge label of the first subtask, is satisfied by the initial robot locations, we increase the local counters of robots that participate and the global counter by 1 [lines~\ref{seq:initial}-\ref{seq:c_initial}, Alg.~\ref{alg:sequentialMAPP}]. Otherwise, we solve the corresponding GMRPP as in Section~\ref{sec:solution2mapp}.  We initialize $T$ by $\vec{t}(c+1) - \vec{t}(c)$ (by default $\vec{t}(0)=0$),  which is the difference between the completion time of the immediately preceding subtask and the current one. %% Another instance of GMRPP is generated by incrementing $T$ until a solution is found and
we denote by $T_e$  the final $T$  when  the GMRPP has a solution [line~\ref{seq:mapp}, Alg.~\ref{alg:sequentialMAPP}]. {Given a solution to the generalized mulri-robot planning problem, Alg.~\ref{alg:sequentialMAPP} proceeds with the following updates [lines~\ref{seq:path}-\ref{seq:c}, Alg.~\ref{alg:sequentialMAPP}].

%% {The iteration terminates when the end vertex $v_2$ of subtask $e$ is $\vertex{accept}$ [line~\ref{seq:terminate_1}, Alg.~\ref{alg:sequentialMAPP}]. For robot $[r, j] \in \ccalR$, we append the path segment $\tau'_{r,j}(t)$, for all $t = 1, \ldots, T_e$, to its already-executed path $\tau_{r,j}$, i.e.,  $\tau_{r,j} = \tau_{r,j} \cdot \tau'_{r,j}[1:T_e]$ where ``$\cdot$'' denotes the concatenation of two path segments. Then, for other robot $[r,j] \in \{\ccalK_j\}\setminus \ccalR$, we  append  $T_e$ times  the last waypoint of  $\tau_{r,j}$  to $\tau_{r,j}$, that is, these robots  remain idle for $T_e$ time instants [line~\ref{seq:finalpath}, Alg.~\ref{alg:sequentialMAPP}]. In the full-moving scheme, path segments of all robots will be provided by the solution of GMRPP. If the  end vertex $v_2$ of subtask $e$ is $\vertex{accept}$ and $\vertex{accept}$ does not have a self-loop, the iteration also terminates and  we take similar steps to append $T_e$ waypoints in the path segments to already-executed ones [line~\ref{seq:finalpath}, Alg.~\ref{alg:sequentialMAPP}].

First, for robot $[r, j] \in \ccalR$, we append the path segment $\tau'_{r,j}(t)$, for all $t=1,\ldots, T_e$, to its already-executed path $\tau_{r,j}$. Then, for other robot $[r,j] \in \{\ccalK_j\}\setminus \ccalR$, we  append  $T_e$ times the last waypoint of  $\tau_{r,j}$  to $\tau_{r,j}$ [line~\ref{seq:path}, Alg.~\ref{alg:sequentialMAPP}]. Note that the final waypoint will be the initial locations of the next instance of GMRPP.  Morevoer, for each robot $[r,j] \in \{\ccalK_j\}$, we increase the time instants in $t_{r,j}$ with indices larger than or equal to  $\zeta_{r,j}$ by $T_e - (\vec{t}(c+1) - \vec{t}(c))$ [line~\ref{seq:timeline}, Alg.~\ref{alg:sequentialMAPP}], where $\vec{t}(c+1) - \vec{t}(c)$ is the time span of the current subtask  given by the high-level plan whereas $T_e$ is the time span given by the low-level executable path.
    Similarly, we increase the time instants in $\vec{t}$ with indices larger than or equal to  $c+1$ by $T_e - (\vec{t}(c+1)- \vec{t}(c))$.
    In this way, for all high-level plans, the subsequent parts that have not been executed are shifted into the future by the same amount in order to mantain the correct temporal relation (precedence or simultaneity) between visitation of waypoints in $\{p_{r,j}\}$. Next, we increase  the local counter by 1 for all robots in $\ccalR_{1,2}$, which captures progress towards completing their individual plans [line~\ref{seq:counter}, Alg.~\ref{alg:sequentialMAPP}]. Similarly, we increase the global counter $c$ by 1 [line~\ref{seq:c}, Alg.~\ref{alg:sequentialMAPP}].}


\begin{figure}
  \centering
  \subfigure[$t=4$]{
    \includegraphics[width=0.3\linewidth]{gridworld_4.pdf}
    \label{fig:frame4}
  }
  \subfigure[$t=8$]{
    \includegraphics[width=0.3\linewidth]{gridworld_8.pdf}
    \label{fig:frame8}
  }
  \subfigure[$t=15$]{
    \includegraphics[width=0.3\linewidth]{gridworld_15.pdf}
    \label{fig:frame15}
  }
  \caption{Key frames demonstrating the execution of low-level paths that satisfy the task~\hyperref[task:i]{\it {(i)}}. Fig.~\ref{fig:frame4} shows that at time instant 4, robots $[2,1]$ and $[3,1]$  reach the office building $\ell_2$, while robot $[2,2]$ are on the way to the road $\ell_4$. Fig.~\ref{fig:frame8} shows that at time instant 8, robot $[2,2]$ reaches the road $\ell_4$ while robots $[2,1]$ and $[3,1]$ head towards the open area $\ell_3$. Finally, they reach $\ell_3$ in Fig.~\ref{fig:frame15} at time instant 15.}
  \label{fig:frames}
  \end{figure}
\begin{cexmp}[(Low-level paths)]
  Continuing the task~\hyperref[task:i]{\it {(i)}}, Fig.~\ref{fig:frames} shows an array of 3 key frames where subtasks are completed. Note that task~\hyperref[task:i]{\it {(i)}} is completed at time instant 15, which is longer than 12 given by the high-level plan due to that the high-level plan considers the shortest travelling time between regions and  collision avoidance is tackled in the low-level paths.
\end{cexmp}

\begin{rem}
  In the formulation of GMRPP, we did not take into account the collision avoidance between robots, which will be tackled in Section~\ref{sec:extension_collision}.
\end{rem}
\subsection{Solution to the generalized multi-robot path planning}\label{sec:solution2mapp}

\begin{figure}[t]
  \centering
  \includegraphics[width=0.8\linewidth]{mapp.pdf}
  \caption{Time-expanded graph over horizon $T+1$} (modified from~\cite{yu2016optimal})
  \label{fig:mapp}
\end{figure}

\begin{figure}[t]
  \centering
  \includegraphics[width=0.5\linewidth]{gadget.pdf}
  \caption{Merge-split gadget for avoiding head-on collision} (from~\cite{yu2016optimal})
  \label{fig:gadget}
\end{figure}
{ Conventional multi-robot path planning on graphs finds collision-free and optimal paths for groups of robots starting from a set of initial locations and ending at a set of desired target locations; see, e.g., \cite{yu2016optimal} and the references therein. To find executable paths that satisfy the subtasks defined here, we generalize the mult-robot path planning problem in several ways. First, in the partial-moving scheme,  only a subset of robots that are involved in the current or future subtasks are allowed to move.  Second, we extend the notion of a single target location to a taget region such that reaching any cell in the target region suffices. Third, the path segments that complete the  subtask should satisfy the complete clauses in the corresponding vertex label and edge label.


  In what follows, we adapt the method proposed in~\cite{yu2016optimal} to solve GMRPP under the partial-moving scheme with given horizon $T$.  The key idea is to construct a time-expanded graph $\ccalG_T = (\ccalV_T, \ccalE_T)$ of the environment which contains $T$ copies of the free cells in the environment $E$; see Fig.~\ref{fig:mapp}. We organize the vertices and edges of this time-expanded graph $\ccalG_T$ in a matrix structure, so that each row corresponds to a free cell in the environment $E$ and each column corresponds to a time instant $t\in \{0,\ldots,T\}$. Then, a vertex $u_t \in \ccalV_T$ that appears in the $t$-th column of this matrix structure indicates whether the cell $u\in E$ is occupied by a robot at the time instant $t$. The edges in $\ccalG_T$ capture  adjacency relations between neighboring cells in $E$ and consecutive time instants in $\{0,\ldots,,T\}$. Specifically, for any two adjacent cells $u$ and $v$ in $E$, an ``X''-shape structure, referred to as a {\it merge-split gadget}, is created to capture the transition from vertex $u$ at time $t$ to vertex $v$ at time $t+1$; see also Fig.~\ref{fig:gadget}. In this way, robots traveling along a given row in the matrix structure corresponding to $\ccalG_T$ effectively remain idle at their current cell, while robots switching between different rows in $\ccalG_T$ transition between adjacent cells in $E$. We say that a sequence of transitions in $\ccalG_T$ form $t=0$ to $t=T$ produces a robot path in the environment $E$.

Next, we formulate an Integer Linear Programming (ILP) to solve the GMRPP. Let $s_{uvrj} \in\{0,1\}$ be the routing variable such that $s_{u_{t}v_{t+1}rj} = 1$ if robot $[r,j]$ traverses the edge $(u_t,v_{t+1}) \in \ccalE_T$. In what follows, we describe the constraints and objective of this ILP.


\subsubsection{Routing constraints:}
The constraint that each edge can be traversed by at most one robot at the given time is encoded as}
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}
  \sum_{[r,j] \in \ccalR} s_{u_t v_{t+1}rj} \leq 1, \quad \forall \,(u_t,v_{t+1}) \in \ccalE_T,
\end{align}
\endgroup
for all $t=0,\ldots, T-1$, where $[r,j]\in\ccalR$ means the summation is taken over all robots in $\ccalR$. Furthermore, the flow conservation constraint is encoded as,
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begingroup
  \begin{align}\label{equ:flow}
  \sum_{u_{t-1}:(u_{t-1}, v_t) \in \ccalE_T}   s_{u_{t-1} v_t rj} &  =   \sum_{w_{t+1}:(v_t, w_{t+1}) \in \ccalE_T} s_{v_t w_{t+1} rj},
  \end{align}
\endgroup
for all $[r,j]\in \ccalR$ and all $t=1,\ldots,T-1$. This means that every robot that arrives at a vertex in $\ccalG_T$ has to leave that vertex at the next time step. Next, the constraints at the initial time are encoded as,
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begingroup

\begin{subequations}\label{equ:source}
  \begin{align}
    \sum_{v_1:(u_0, v_1) \in \ccalE_T} s_{u_0v_1 rj} &  = 1,  \\
    \sum_{v_1:(w_0, v_1) \in \ccalE_T} s_{w_0v_1 rj} & = 0, \quad \forall\, w \in E\setminus u,
  \end{align}
\end{subequations}
\endgroup
for all $[r,j]\in \ccalR$, where $u_0$ is the vertex that is associated with the cell $u = X_I(r,j)$ where robot $[r,j]$ is at the initial time. Constraints~\eqref{equ:source} say that robot $[r,j]$ has to depart from its initial location. Note that this departure is in the graph $\ccalG_T$ and is associated more with time than physical location.

\subsubsection{Target constraint:}
The general constraints that robot $[r,j]$ in $\ccalR_1$ and $\ccalR_{1,2}$  arrives at a cell that is in the target region $X_G(r,j)$ at certain time instant $t$ can be encoded as
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begingroup
  \begin{align}\label{equ:sink}
  \sum_{v: v \in X_G(r,j) } \;\sum_{u_{t-1}:(u_{t-1}, v_{t}) \in \ccalE_T} s_{u_{t-1} v_{t} rj} &  = 1,
  \end{align}
  \endgroup
 Specifically, $t$ in constraint~\eqref{equ:sink} takes the value ranging from $1, \ldots, T-1$ when encoding the constraint that robot $[r,j] \in\ccalR_1$  stay at the target region $X_G(r,j)$ to maintain the truth of  the vertex label of the current subtask.  For the constraint that robot $[r,j]\in\ccalR_{1,2} $ arrives at a cell in $X_G(r,j)$ at the time instant $T$ to complete the current subtask, we have $t = T$ in~\eqref{equ:sink}. %% Similarly,  the constraint that robot $[r,j] \in \ccalR_2$ arrives at a cell that is in the target region $X_G(r,j)$ at the time $T$ to activate the next subtask  can be encoded by assigning $T$ to $t$ in~\eqref{equ:sink}.

 \subsubsection{Running and terminal constraints:} The general running and terminal constraints that negative literals $\neg \ap{i}{j}{k}$ should be respected at certain time instant $t$ can be encoded as
   \begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}\label{equ:avoid}
  \sum_{[r,j]\in \ccalR \cap \ccalK_j} \sum_{v \in \ell_k \cap E}   \sum_{u_{t-1}: (u_{t-1}, v_{t}) \in \ccalE_T} s_{u_{t-1} v_{t} r j } \leq i - 1,
\end{align}
\endgroup
where $[r,j] \in \ccalR \cap \ccalK_j$ means the summation is taken over all robots of type $j$ in $\ccalR$ and $v \in \ell_k \cap E$ means the summation is taken over all cells in region $\ell_k$ that are not occupied by other robots that do not need to move. Then, the running constraint that any
negative literal $\neg\ap{i}{j}{k} \in \mathsf{lits}^-(\gamma_1^-)$ in the vertex label of the current subtask should be respected (excluding time instants $0 $ and $T$), can be encoded by assigning to $t$ in constraint~\eqref{equ:avoid} values ranging from $1, \ldots, T-1$. Similarly, we encode the terminal constraint that the negative literal  $\neg\ap{i}{j}{k}$ in $\mathsf{lits}^-(\gamma_{1,2}^-)$  should be satisfied at the time $T$ by letting $t$ in constraint~\eqref{equ:avoid} take the value $T$.
\subsubsection{ILP objective:} The ILP objective is to minimize the total travelling distance and is defined as
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begingroup
\begin{align}
  \text{min} \sum_{[r,j] \in \ccalR} \; \sum_{t\in \{0,\ldots, T-1\}} \sum_{(u_t, v_{t+1}) \in \ccalE_T} d_{uv} s_{u_{t} v_{t+1} r j}   .
\end{align}
\endgroup
where $d_{uv} \in \mathbb{N}$ is the distance between cells $u$ and $v$.

When a solution does not exist for a horizon $T$, we increment $T$ to solve the ILP again.  The solution to this ILP provides  a collection of executable paths that satisfy  the current subtask at time $T$  as well as activates the next subtask.

  \section{Correctness and Feasiblity}\label{sec:correctness}
  Given a NBA $\auto{}$, e.g., $\autop, \auto{relax}$ and $\auto{subtask}$, we define $\ccalL_E(\auto{})$ as the set of words in  $\ccalL(\auto{})$ that can be realized by robot paths. Recall that we can always map a run  in $\auto{}$ to its counterpart in $\autop$. If $\auto{}=\autop$, then the counterpart of a run is itself. We define $\ccalL^\phi_E(\auto{})$ as the set of realizable words in $\ccalL_E(\auto{})$ such that for the accepting run in $\auto{}$ that is induced by a realizable word in $\ccalL^\phi_E(\auto{})$, its corresponding run in $\autop$ is a restricted accepting run. In words, considering $\auto{} = \auto{subtask}^-$, if a path $\tau$ generates a word $w$ in $\ccalL_E^\phi(\auto{subtask}^-) \subseteq \ccalL_E(\auto{subtask}^-)$ and further $w$ induces an accepting run $\rho$ in $\auto{subtask}^-$, we have that its corresponding run  in $\autop$ is a restricted accepting run, and we can seek to modify the path $\tau$  to produce this run  in $\autop$, thus satisfying the specification $\phi$.  Additionally, let $\tilde{\ccalL}^{\phi}_E(\auto{}) \subseteq \ccalL^{\phi}_E(\auto{})$ collect those words in $\ccalL^{\phi}_E(\auto{})$ that can be generated by paths that meet Assumption~\ref{asmp:same}.  The following propositions show that feasibility of Problem~\ref{prob:1} is preserved under the proposed LTL-MRTA algorithm. The proofs are shown in the~\hyperref[sec:appendix]{Appendix}.

  \subsection{Relations between the NBA}
  The following proposition shows that the pruning steps in Section~\ref{sec:prune} do not affect the set of restricted accepting runs  in $\autop$ hat can be induced by realizable words.
  \begin{lem}\label{prop:prune}
    Considering  a discrete environment, a team of $n$ robots of $m$ types with $n$ transition systems and a valid \ltl specification $\phi$, after pruning steps in Section~\ref{sec:prune}, it holds that  $\ccalL_E^\phi(\autop^-) = \ccalL^\phi_E(\autop)$.
  \end{lem}
  %% Since $\autop^-$ is a sub-NBA of $\autop$, for any run in $\autop^-$, its counterpart in $\autop$ is itself.   Lemma~\ref{prop:prune} implies  that  pruning in Section~\ref{sec:prune} does not remove any realizable word in $ \ccalL_E(\autop)$ that can induce a restricted accepting run,
    The proof can be found in Section~\ref{app:prune}. A direct consequence of Lemma~\ref{prop:prune} is that, any path that generates a word $w$ in  $\ccalL_E^\phi(\autop^-)$ satisfies the specification $\phi$, since the word $w$ belongs to $\ccalL^\phi_E(\autop)$. The following proposition shows that relaxation expands the set of realizable words accepted by $\auto{realx}$.
  \begin{lem}\label{prop:inclusion}
 Considering  a discrete environment, a team of $n$ robots of $m$ types with $n$ transition systems and a valid \ltl specification $\phi$, after the relaxation stage of replacing all negative literals with $\top$ in Section~\ref{sec:prune}, it holds that $\ccalL^\phi_E(\autop^-) \subseteq \ccalL^\phi_E(\auto{relax})$.
  \end{lem}
  The proof can be found in Section~\ref{app:inclusion}. Lemma~\ref{prop:inclusion} implies that a word $w$ in $\ccalL^\phi_E(\auto{relax})$ may not belong to $\ccalL^\phi_E(\autop^-)$, therefore, a path generating a word in $\ccalL^\phi_E(\auto{relax})$ may not satisfy the specficaition $\phi$, which is obvious since $\auto{relax}$ ignores the negative literals. The following corollary captures the difference between $\ccalL^\phi_E(\autop^-) $ and $\ccalL^\phi_E(\auto{relax})$ from the perspective of the runs they induce. First, we define $\ccalL^\phi(\auto{})$ as the set of  words in $\ccalL(\auto{})$ such that for the run in $\auto{}$ that is induced by a word in $\ccalL^\phi(\auto{})$, its corresponding run in $\autop$ is a restricted accepting run. Apparently, $\ccalL_E^\phi(\auto{})  \subseteq \ccalL^\phi(\auto{})$.  Note that   $\auto{relax}$ is graphically equivalent to $\autop^-$ in terms of the vertex set and the edge set. We say that a run in $\auto{relax}$ is same as a run in $\autop^-$ if these two runs are the same sequence of vertices. Given a NBA $\auto{}$, Let $\Omega_E^\phi(\auto{})$ and $\Omega^\phi(\auto{})$ denote the set of runs in $\auto{}$ that are induced by the words in $\ccalL_E^\phi(\auto{})$ and $\ccalL^\phi(\auto{})$, respectively.
    \begin{cor}\label{prop:equality}
Considering  a discrete environment, a team of $n$ robots of $m$ types with $n$ transition systems, and a valid \ltl specification $\phi$, after the relaxation stage of replacing all negative literals with $\top$ in Section~\ref{sec:prune}, it holds that $\Omega_E^\phi(\autop^-) \subseteq  \Omega_E^\phi(\auto{relax}) \subseteq \Omega^\phi(\autop^-)$.
    \end{cor}
    The proof can be found in Section~\ref{app:equality}. A direct consequence of Corollary~\ref{prop:equality} is that when all restricted accepting runs can be induced by feasible paths, it follows that $\Omega_E^\phi(\autop^-) = \Omega^\phi(\autop^-)$. Therefore $\Omega_E^\phi(\autop^-) =  \Omega_E^\phi(\auto{relax})$. In this case, given a path $\tau$ that generates a word in $\ccalL_E^\phi(\auto{relax})$, there exists a path $\tau'$ that generates a word in $\ccalL_E^\phi(\autop^-)$ such that the two runs induced by these two words, one in $\auto{relax}$ and the other in $\autop^-$, are identical. The difference between $\tau$ and $\tau'$ is that $\tau$ does not take the negative literals into account. According to Lemma~\ref{prop:prune}, $\tau'$ satisfies the specification $\phi$. Therefore, given such a path $\tau$ and its induced run, we conclude that it can be modified to satisfy the specification $\phi$ while keeping the induced run unchanged. This justifies our method in Section~\ref{sec:solution2mrta} to design low-level paths for $\autop$ by following the simple path  that is induced by a high-level plan in $\auto{subtask}^-$ ($\auto{subtask}^-$ is a sub-NBA of $\auto{relax}$).

    Next, we consider separately  the prefix and suffix part of a restricted accepting run. Given a pair of initial and accepting vertices, $v_0$ and $v_\text{accept}$, let $\ccalL^{\phi, v_0 \scriptveryshortarrow \vertex{accept}}_E(\auto{})$ be the set that collects finite realizable words that can generate a run in $\auto{}$ from $v_0$ to $\vertex{accept}$ whose correponding run in $\autop$ is the prefix part of a restricted accepting run. %% Let $\tilde{\ccalL}^{\phi, v_0 \scriptveryshortarrow \vertex{accept}}_E(\auto{}) \subseteq  \ccalL^{\phi, v_0 \scriptveryshortarrow \vertex{accept}}_E(\auto{})$ denote the set of words that can be generated by paths that meet conditions~\hyperref[asmp:a]{\it (a)}-\hyperref[asmp:b]{\it (b)} in Assumption~\ref{asmp:same}.
    The following two statements show that extraction and pruning of the sub-NBA $\auto{subtask}$ for the prefix part do not empty the set of restricted accepting runs that can be induced by feasible paths that meet the Assumption~\ref{asmp:same}. The detailed proof can be found in Section~\ref{app:nonempty}-~\ref{app:sub-NBA}, respectively.
  \begin{lem}\label{prop:nonempty}
  Considering  a discrete environment, a team of $n$ robots of $m$ types with $n$ transition systems, and a valid \ltl specification $\phi$, for a pair of initial and accepting vertices, $v_0$ and $\vertex{accept}$, after the extraction of the sub-NBA $\auto{subtask}$ in Section~\ref{sub-NBA:1}, it holds that  $\ccalL^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{relax}) = \ccalL^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask})$.
  \end{lem}

 \begin{lem}\label{prop:sub-NBA}
  Considering  a discrete environment, a team of $n$ robots of $m$ types with $n$ transition systems, and a valid \ltl specification $\phi$, for a pair of initial and accepting vertices, $v_0$ and $\vertex{accept}$, after the pruning steps in Section~\ref{sub-NBA:2}, it holds that $\ccalL^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-) \subseteq \ccalL^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask})$. Additionally, if $\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}) \not= \emptyset$, then $\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-) \not= \emptyset$.
 \end{lem}
Recall that when building the NBA $\auto{subtask}^-$ for the suffix part, we rely on the the last subtask $(\vertex{prior}, \vertex{accept})$ that is  obtained from $\auto{subtask}^-$ for the prefix part (obtaining the NBA $\auto{subtask}$) and final robot locations of the prefix part (adding new clause $\pi_{\text{init}}$). Therefore, we define  $\ccalL^{\phi, \vertex{accept} \scriptveryshortarrow \vertex{accept}}_E(\auto{}; s_{\text{pre}}, \vertex{prior})$ as the set that collects finite realizable words that can generate a run in $\auto{}$ from $\vertex{accept}$ to $\vertex{accept}$ whose correponding run in $\autop$ is the suffix part of a restricted accepting run. Additionally, the paths generating these words start from $s_{\text{pre}}$, the final robot locations of the prefix part, and  the prefix part of this restricted accepting run traverses $\vertex{prior}$ right before $\vertex{accept}$. The following corollary draws the similar conclusion to Lemma~\ref{prop:nonempty} and~\ref{prop:sub-NBA} for the suffix part; see Section~\ref{app:sub-NBA2} for the proof.
 \begin{cor}\label{prop:sub-NBA2}
   Considering  a discrete environment, a team of $n$ robots of $m$ types with $n$ transition systems, and a valid \ltl specification $\phi$, for an  accepting vertices $\vertex{accept}$, given $s_{\textup{pre}}$ and $\vertex{prior}$, after the extraction and pruning  steps in Section~\ref{sec:suf_prune}, it holds that $\ccalL^{\phi,\vertex{accept}\scriptveryshortarrow \vertex{accept}}_E(\auto{relax}; s_{\textup{pre}},\vertex{prior}) = \ccalL^{\phi,\vertex{accept}\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}; s_{\textup{pre}}, \vertex{prior})$.  Furthermore, if $\tilde{\ccalL}^{\phi,\vertex{accept} \scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}; s_{\textup{pre}},\vertex{prior}) \not= \emptyset$, then $\tilde{\ccalL}^{\phi, \vertex{accept} \scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-; s_{\textup{pre}}, \vertex{prior}) \not= \emptyset$.
 \end{cor}

 Finally, we are ready to present  the first major result, whose proof can be found in Section~\ref{app:nba}.
 \begin{thm}\label{thm:nba}
   Considering  a discrete environment, a team of $n$ robots of $m$ types with $n$ transition systems, and a valid \ltl specification $\phi$, if Problem~\ref{prob:1} is feasible, that is, there exists a path $\tau = \tau^\textup{pre} [\tau^\textup{suf}]^\omega$ that induces a resitrcted accepting run $\rho = v_0, \ldots, \vertex{prior}, \vertex{accept} (\vertex{next}, \ldots, \vertex{prior}', \vertex{accept})^\omega$ in $\autop$ and meets the Assumption~\ref{asmp:same}, i.e.,  $\tilde{\ccalL}_E^\phi(\autop) \neq \emptyset$, then there exists a pair of initial and accepting vertices $v_0$ and $\vertex{accept}$ such that $\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-) \not= \emptyset$. Furthermore, if $ \vertex{next} \neq \vertex{accept}$, that is, the suffix part consists of other vertices,  then $\auto{subtask}^-$ for the suffix part can be  built on the final robot locations, denoted by $s_\textup{pre}$, of the prefix part $\tau^{\textup{pre}}$ and the vertex $\vertex{prior}$, and
    $\tilde{\ccalL}^{\phi,\vertex{accept} \scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-; \tilde{s}_{\textup{pre}},\tilde{v}_\textup{prior}) \not= \emptyset$, where   $\tilde{s}_{\textup{pre}} = s_{\textup{pre}}$ and  $ \tilde{v}_\textup{prior} = {\vertex{prior}}$.
 \end{thm}

 \begin{rem}
One major difference between Corollary~\ref{prop:sub-NBA2} and Theorem~\ref{thm:nba} is that, in Corollary~\ref{prop:sub-NBA2} the conclusion is made based on the condition that the pair  $s_{\textup{pre}}$ and $\vertex{prior}$ is provided, while in Theorem~\ref{thm:nba} we need to show that the the pair  $\tilde{s}_{\textup{pre}}$ and $\tilde{v}_\textup{prior}$ obtained from the sub-NBA $\auto{subtask}^-$ for the prefix part is indeed idential to that obtained from $\autop$ since the path $\tau^{\textup{pre}}$ accepted by $\auto{subtask}$ may not be accepted by $\auto{subtask}^-$ due to pruning.
 \end{rem}
 If follows from Theorem~\ref{thm:nba}  that we can iterate over all pairs of initial and accepting vertices to seek the prefix and suffix parts of the robot paths separately.

\subsection{Feasibility of MILP formulation}
Consider a finite path $\tau$ that  generates a finite word $w \in\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-)$. Let $\rho$  denote the induced run in $\auto{subtask}^-$ and $\theta$ denote the simple path obtained from $\rho$. This simple path exists due to condition~\hyperref[cond:a]{\it (a)} in Definition~\ref{defn:run}.  Assuming that the poset $P$ is inferred from the set of simple paths that contains $\theta$.  Lemma~\ref{prop:feasibility} says that the MILP formulation for the prefix part that is based on the poset $P$ is feasible and Lemma~\ref{prop:run} follows that a simple path in $\auto{subtask}^-$ can be extracted from the solution to the MILP with satisfying temporal property.

 \begin{lem}\label{prop:feasibility}
   If there exists a path $\tau$ that generates a finite word $w \in \tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-)$, and the word $w$ induces a simple path in $\auto{subtask}^-$ that lies in the set of simple paths from which the poset $P$ is inferred,
   then the  MILP formulation  in Section~\ref{sec:milp} that is based on the poset $P$  is feasible. %% with any positive integer $M_{\textup{min}}$.
 \end{lem}
    The detailed proof can be found in Section~\ref{app:feasibility}. In essence, the path $\tau$ that generates the word $w$ can give rise to a high-level plan  that satisfies constraints~\eqref{eq:1}-\eqref{eq:same} in Section~\ref{sec:milp}.

\begin{lem}\label{prop:run}
  If the MILP formulation based on a poset $P$ produces a solution, then in Section~\ref{sec:run} a simple path $\theta$ that is within the set of simple paths from which the poset $P$ is inferred, can be extracted from the sub-NBA $\auto{subtask}^-$. Additionally, the following properties hold for subtasks in the simple path $\theta$:
  \begin{noindlist}
  \item \label{property:a} The first subtask in the simple path $\theta$ is activated at time 0;
    \item \label{property:b}  For any subtask  $e \in \theta$, if its starting vertex has a self-loop, then the completion time of the subtask $e$ is no early than the activation of its vertex label, and at most one time instant later than the completion of the vertex label;
  \item \label{property:c}  For any two consecutive subtasks  $e, e'\in \theta$, the latter subtask $e'$ is activated at most one time instant later than the completion of the former subtask $e$.
  \end{noindlist}
\end{lem}

  The detailed proof can be found in Section~\ref{app:run}. Property~\ref{property:a} guarantees the initialization of the sequence of subtasks in $\theta$, property~\ref{property:b} ensures that each subtask in $\theta$ is correctly implemented, and property~\ref{property:c} avoids the absence of gaps between the transition of two consecutive subtasks. Altogether, these three properties establishes that once the first subtasks is activated at time 0, each subtask is completed successfully and inter-subtasks transition occurs seamlessly, until the completion of the last subtask.

We refer to a free cell in the environment as the region-free cell if it is not inside any region, and a path as the label-free path if it only passes region-free cells. The following Lemma~\ref{prop:valid} states that low-level executable paths can be generated based on the solution to the MILP.
 \begin{lem}\label{prop:valid}
   Assuming there exists an obstacle-free and region-free path between any two regions and any region is adjacent to a free cell that does not belong to any reiogn or obstacle, then in Section~\ref{sec:solution2mrta} the sequence of instances of GMRPP  for the simple path $\theta$ extracted form $\auto{subtask}^-$ based on the solution to the MILP for the prefix part, is feasible. That is, each instance of GMRPP is feasible for some $T$'s.
 \end{lem}

 \begin{proof}
     The detailed proof can be found in Section~\ref{app:valid}.
 \end{proof}
 Combining Lemma~\ref{prop:feasibility}-\ref{prop:valid}, we conclude that if Problem~\ref{prob:1} is feasible, we can find executable robot paths that satisfy the requirements on the prefix part in Definition~\ref{defn:run} and Assumption~\ref{asmp:same}.  For any \ltl formulas that can be satisfied by finite paths, such as co-safe LTL \citep{kupferman2001model} or LTL$_f$ \citep{de2013linear}, if $\tilde{\ccalL}_E^\phi(\autop) \neq \emptyset$, our method can find a feasbile path.
\begin{thm}\label{thm:prefix}
  Considering  a discrete environment, a team of $n$ robots of $m$ types with $n$ transition systems, and a valid \ltl specification $\phi$, if the Problem~\ref{prob:1} is feasbile, i.e.,  $\tilde{\ccalL}_E^\phi(\autop) \neq \emptyset$. Furthermore, assuming there exists an obstacle-free and region-free path between any two regions and any region is adjacent to a free cell that does not belong to any reiogn or obstacle, then we can find an executable robot path $\tau$ that generates a word $w$ which induces a run $\rho$ in $\autop$ that connects a certain pair of initial and accepting vertices. Futhermore, the run $\rho$ satisfies the requirements on the prefix part in conditions~\hyperref[cond:a]{\it (a)}-\hyperref[cond:d]{\it (d)} in Definition~\ref{defn:run} and the path $\tau$ satisfies conditions~\hyperref[asmp:a]{\it (a)}-\hyperref[asmp:b]{\it (b)} in Assumption~\ref{asmp:same}.
  %% belonging to $\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\autop)$, where $v_0$ and $\vertex{accept}$ is a certain pair of initial and accepting vertices. That is, the path $\tau$ can induce a run in $\autop$ that the a prefix part of a restricted accepting run.
 \end{thm}

\begin{proof}
  The detailed proof can be found in Section~\ref{app:prefix}.
\end{proof}
Similar to Lemma~\ref{prop:feasibility}, we show the feasibility of the MILP formulation for the suffix part.
\begin{lem}\label{prop:suffix_feasibility}
  If there exists a path $\tau$ that generates a finite word $w \in \tilde{\ccalL}^{\phi,\vertex{accept}\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-; s_{\textup{pre}}, \vertex{prior})$ ($s_{\textup{pre}}$ and $\vertex{prior}$ are given), and the word $w$ induces a simple path that lies in the set of simple paths from which the poset $P$ is inferred,
  then the formulation of MILP that is based on the poset $P$, composed of constraints in Section~\ref{sec:milp} and constraints~\eqref{eq:same_suffix}-\eqref{eq:return_suffix} in Section~\ref{sec:suf},  is feasible.
\end{lem}

\begin{proof}
  The detailed proof can be found in Section~\ref{app:suffix_feasibility}.
\end{proof}

Similar to Lemma~\ref{prop:valid}, we show the feasibility of instances of GMRPP for the suffix part. Let $\Pi_{\text{safe}}$ be the set that collects those negative literals that appear in every vertex label edge label of $\autop$. These negative literals can arise from the safety constraints in \ltl, that is, something bad never happens, e.g.~$\square \neg \ap{i}{j}{k}$. Let $\Theta_{\text{safe}}$ be the set that collects all simple cycles around certain accepting vertices in $\autop$ such that, for each simple cycle in $\Theta_{\text{safe}}$, all negative literals that appear in the starting vertex label of its last subtask (end vertex is an accepting vertex) belong to $\Pi_{\text{safe}}$.
\begin{lem}\label{prop:suffix_valid}
  Assuming there exists an obstacle-free and region-free path between any two regions and any region is adjacent to a free cell that does not belong to any reiogn or obstacle. Also, assuming that the simple cycle $\theta$ extracted form $\auto{subtask}^-$ based on the solution to the MILP for the suffix part belong to $\Theta_\textup{safe}$,  then in Section~\ref{sec:solution2mrta} the sequence of instances of GMRPP  for the simple cycle $\theta$  is feasible. That is, each instance of GMRPP is feasible for some $T$'s.
\end{lem}

\begin{proof}
  The detailed proof can be found in Section~\ref{app:suffix_valid}.
\end{proof}

Finally, combining Themorem~\ref{thm:prefix} and Lemma~\ref{prop:suffix_feasibility}, we are ready to prove the completeness of our method for the LTL-MRTA problem.
$\gamma_\phi(\vertex{accept},\vertex{next})$ only has one clause. all negative literals in $\gamma_\phi(\vertex{prior}')$ are shown in
\begin{thm}\label{thm:completeness}
  Considering  a discrete environment, a team of $n$ robots of $m$ types with $n$ transition systems, and a valid \ltl specification $\phi$, if the Problem~\ref{prob:1} is feasbile, i.e.,  $\tilde{\ccalL}_E^\phi(\autop) \neq \emptyset$. Furthermore, assuming there exists an obstacle-free and region-free path between any two regions and any region is adjacent to a free cell that does not belong to any reiogn or obstacle, then we can find an executable robot path $\tau=\tau^{\textup{pre}} [\tau^{\textup{suf}}]^\omega$ that  generates a word $w= w^{\textup{pre}} [w^{\textup{suf}}]^\omega$ which induces a restricte accepting run $\rho= \rho^{\textup{pre}} [\rho^{\textup{suf}}]^\omega$, and the path $\tau$ satisfies the Assumption~\ref{asmp:same}.  %% belonging to $\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\autop)$, where $v_0$ and $\vertex{accept}$ is a certain pair of initial and accepting vertices. That is, the path $\tau$ can induce a run in $\autop$ that the a prefix part of a restricted accepting run.
\end{thm}


\begin{proof}
The detailed proof can be found in Section~\ref{app:completeness}.
\end{proof}

%% \begin{prop}\label{prop:adjustment}
%% Given a solution to the MILP formulation in the Section~\ref{sec:milp}, after the adjustment to the completion time in the solution as in Section~\ref{sec:timeaxis}, there exsits another solution to the MILP formulation in which the completion time of subtasks are identical to those after the adjustment.
%% \end{prop}
%% \begin{proof}
%%   The detailed proof can be found in Section~\ref{app:adjustment}.
%% \end{proof}


 %% (i) determine the set of sets of atomic propositions $\sigma$'s in $w$ that enable the edge transitions in $\rho$. The set of atomic propositions $\sigma_e$ indexed by $e\in \mathbb{N}$  is such if $v_{e-1} \neq v_e$ in the run $\rho$; (ii) randomly select one clause in the edge label $\gamma(v_{e_1}, v_e)$ is satisfied by $\sigma_e$, then all literals in this clause also appear in $\sigma_e$. We collect these literals to construct the $e$-th set $\sigma^*_e$ in the essential word; (iii)
\section{Simulation Results}\label{sec:sim}
We present two case studies, implemented in Python 3.6.3 on a computer with 2.3 GHz Intel Core i5 and 8G RAM, that illustrate the correctness and efficiency of our method. The MILP is solved using Gurobi~\citep{gurobi} with $M_{\text{max}}=10^5$. We generate a  $10\times 10$ grid world with 10 regions and 10 obstacles randomly placed in the world at each trial. The team of robots consists of of 5 types with $N$ robots of each type. The initial locations are randomly generated.
%% \begin{table}[t]
%%   \caption{Results with respect to the size of workspace}\label{tab:1}
%%   \centering
%%   \begin{tabular}{cccccc}
%%     \toprule
%%     $W$ & $T$(sec) & $W$ & $T$(sec) & $W$ & $T$(sec)\\
%%     10& 122.00 &  20 & 119.12& 50& 120.10\\
%%      \bottomrule
%%   \end{tabular}
%% \end{table}

%% \subsubsection{Case \RNum{1}}First, we consider a team of robots of 3 types, with each type including 4 robots. The LTL task captures a multi-agent travelling salesman problem (TSP)~\cite{bektas2006multiple},
%% %\vspace{-1em}

%% \endnotesize
%% \begin{align*}
%%   %% \phi = & \Diamond \ap{1}{1}{1} \wedge \Diamond \ap{1}{2}{2} \wedge \Diamond \ap{1}{3}{3} \wedge \Diamond \ap{1}{1}{4} \wedge \Diamond \ap{1}{2}{5} \wedge \Diamond \ap{1}{3}{6} \nonumber \\  & \wedge \Diamond \ap{1}{1}{7} \wedge \Diamond \ap{1}{2}{8} \wedge \Diamond \ap{1}{3}{9} \wedge \Diamond \ap{1}{1}{10} \\
%%   \phi_1=  \bigwedge\nolimits_{j\in [3]} (\Diamond \ap{1}{j}{j}) \wedge \bigwedge\nolimits_{j\in [3]} (\Diamond \ap{1}{j}{j+3}) \wedge \bigwedge\nolimits_{j\in [3]} (\Diamond \ap{1}{j}{j+6}) \wedge (\Diamond \ap{1}{1}{10})
%% \end{align*}
%% \normalsize
%% For simplicity, we define only $t^-_{vr}$ for vertices associated with edge labels, since $t^-_{vr} = t^+_{vr}$. The  MILP has 454 variables and 638 constraints. We vary  $W$ and the results are averaged over 5 runs for each $W$. Each time the solution attains the optimal allocation in terms of the sum of the travelling distance, i.e., $\sum_{(u,v)\in \ccalE_\ccalG}  \sum_{r \in \ccalM^\ccalV_{\ccalK}(v)} w_{uv} x_{uvr}$, which is verified by a brute-force search method.
%% For $W=10,20,50$, the average runtimes are $122.00,119.12, 120.10$ in seconds, respectively, which accounts for the time needed to build the  NBA all the way to extracting a solution. The runtimes are similar since only the shortest paths between pairwise regions are required and the MILP only generates a sequence of waypoints that is then augmented using the shortest paths.
\subsubsection{Case \RNum{1}} {The cooperative persistence coverage task is}

\small
\begin{align*}
  %% & \phi = \square \Diamond \ap{x}{1}{1} \wedge \square \Diamond \ap{x}{2}{2} \wedge \square \Diamond \ap{x}{3}{3}  \wedge \square \Diamond \ap{x}{4}{4} \wedge \square \Diamond \ap{x}{5}{5} \nonumber \\
  %% & \wedge \Diamond \square\ap{x}{1}{6} \wedge \Diamond \square\ap{x}{2}{7} \wedge \Diamond \square\ap{x}{3}{8} \wedge \Diamond \square\ap{x}{4}{9} \wedge \Diamond \square\ap{x}{5}{10}
   \phi_2 = \bigwedge\nolimits_{j\in[4]} \square \Diamond( \ap{x}{j}{j} \wedge \ap{x}{j+1}{j} ) ,
\end{align*}
\normalsize
where $x = N/3$. We vary $N$ and compare our method to the method for cLTL+ problems in~\cite{sahin2019multirobot} in terms of runtime and cost measured by~\eqref{eq:cost} with $w=0.5$. This task cannot be categorized as a cLTL problem since here robots are heterogeneous. {Although translating LTL to NBA is worst-case exponential w.r.t. the length of the formula, in practice the translation is quick (0.03 and 0.10 seconds for case \RNum{1} and \RNum{2}, respectively). Both NBAs $B$ and $\auto{relax}$ have 5 vertices and 14 edges (excluding self-loops). The size of $B$ is independent of the number of robots. There is one pair of initial and accepting vertices and  $\auto{subtask}^-$ has 5 vertices and 5 edges.} Since the method in~\cite{sahin2019multirobot} depends on the horizon $h$ of the plan, we vary $h$ between 5, 10, 15.\endnote{The SAT solver Z3 is used to solve the Integer Linear Programming since~\cite{sahin2019multirobot} addresses feasibility and all variables are binary.} The results  are shown in Table~\ref{tab:2} and are averaged over 10 trials for each $N$. Our method is two orders of magnitude faster than~\cite{sahin2019multirobot}. This is because it decomposes the problem so that first a sequence of waypoints is decided by solving a MILP and then a shortest path  between waypoints is computed. More importantly, our method outperforms~\cite{sahin2019multirobot} in terms of cost.  The feasibility-oriented formulation in~\cite{sahin2019multirobot} causes robots that are not assigned to any task to move aimlessly, while in our solution, such robots remain idle.

%% \begin{table}[t]
%%   \centering
%%   \caption{Comparative results w.r.t. the number of robots}\label{tab:2}
%%   \begin{tabular}{c|c|c|c|c}
%%    \toprule
%%    \multicolumn{2}{c|}{$N$} & 3 & 6 & 9 \\
%%    \midrule
%%    \multirow{4}{*}{\vtop{\hbox{\strut runtime}\hbox{\strut \;\,\,(sec)}}} & LTL-MRTA & {\bf 0.1}\bm{$\pm $}{\bf 0.0} & {\bf 0.9}\bm{$\pm$}{\bf 0.5} & {\bf 1.5}\bm{$\pm$}{\bf 0.7}\\
%%     & $h=5$ & 173.2$\pm$54.3 & 403.9$\pm$207.9 & 511.7$\pm$327.9\\
%%     & $h=10$ & 71.1$\pm$23.8 & 153.6$\pm$108.8  & 285.9$\pm$271.4\\
%%     & $h=15$ & 68.3$\pm$6.4 & 159.7$\pm$20.8 & 349.7$\pm$35.5\\
%%     \midrule
%%     \multirow{4}{*}{cost} & LTL-MRTA &  {\bf 19.9}\bm{$\pm$}{\bf 4.4} & {\bf 32.7}\bm{$\pm$} {\bf 3.4} & {\bf 46.9}\bm{$\pm$}{\bf 5.8}\\
%%     & $h=5$  & 63.0$\pm$8.0 & 118.7$\pm$22.7  & 156.5$\pm$32.7\\
%%     &$h=10$ & 64.4$\pm$5.7 & 126.6$\pm$14.5 & 189.2$\pm$18.8\\
%%     & $h=15$ & 92.5$\pm$5.4 & 185.2$\pm$ 6.5 & 268.7$\pm$16.5\\
%%         \bottomrule
%%   \end{tabular}
%% \end{table}

\subsubsection{Case \RNum{2}}We consider tasks where some locations are visited sequentially by the same set of robots. For instance, these can be tasks where objects are  picked up by several robots and then delivered to another location.
Let $N=5$. The LTL formula  considered is

\small
\begingroup
\begin{align*}
  \phi_3 = &  \square \Diamond (\pi^{\ell_1,0}_{3,1} \wedge \pi^{\ell_4, 0}_{4,4}) \wedge \Diamond ( \pi^{\ell_2,1}_{3,3} \wedge  (\pi^{\ell_2,1}_{3,3} \,\mathcal{U} \, \pi^{\ell_2,0}_{1,4})  \wedge \Diamond \pi_{4,3}^{\ell_3,0})   \nonumber \\ & \wedge \Diamond (\aap{2}{2}{\ell_7}{0} \wedge (\aap{3}{5}{\ell_8}{2} \vee \aap{3}{5}{\ell_{10}}{2}) \wedge \bigcirc  \Diamond  \aap{3}{5}{\ell_{9}}{2} ) \wedge \Diamond \square \aap{1}{2}{\ell_{10}}{0}
\end{align*}
\endgroup
\normalsize
The NBA $B$ has 31 vertices and 182 edges. There is one pair of initial and accepting vertices. The sub-NBA $\auto{subtask}^-$ has 25 vertices and 48 edges. The MILP has 3760 variables and 4477 constraints. The runtime over 10 trials is 4.8$\pm$2.2$s$. {An animation can be found in~\cite{ltlmrta}.} We observe that the paths satisfy the task. The methods in~\cite{schillinger2018decomposition,schillinger2018simultaneous,faruq2018simultaneous} can not address such cooperative tasks and~\cite{sahin2017provably,sahin2017synchronous,sahin2019multi,sahin2019multirobot} can not capture tasks where the same set of robots needs to visit different locations.


\section{Extension and discussion}\label{sec:extension}
In this section, we present several extensions of the addressed problem and proposed method. We first tackle the collision avoidance between robots, then show in GMRPP  how essential robots for other subtasks  can simultaneously move with essential robots of the current subtask, next demonstrate possible extensions of the \ltl formula such as two subtasks are completed by two different fleet of robots, and finally introduce variations to the MILP formulation by considering more interesting constraints.

\subsection{Collision avoidance}\label{sec:extension_collision}
We handle collision avoidance in each instance of GMRPP in low-level path planning part,  since the high-level plan generation abstracts out the environment. Specifically, the paths of  any two distinct robots $[r,j]$ and $[r', j']$ are collision-free if there does not exist  a time instant $t \in [T]$ such that $\tau'_{r,j}(t) = \tau'_{r',j'}(t)$ (meet collision, that is, two robots occupy the same cell at the same time) or  $\tau'_{r,j}(t) = \tau'_{r',j'}(t-1) \wedge \tau'_{r',j'}(t) = \tau'_{r,j}(t-1)$ (head-on collision, that is, two robots at adjacent cells switch locations with each other). Furthermore, in the partial-moving scheme, we treat those robots that do not need to move  as obstacles, giving rise to a new environment $E'=(S', \to_{E'})$. The time-expanded graph in Section~\ref{sec:solution2mapp} that captures the connectivity of the environment is constructed based on the new environment $E'$. Finally, we add the following collision avioidance constraints to the ILP for the GMRPP.

Avoiding meet collisions,  $\forall v \in E'$, can be captured by the constraint
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begin{align}\label{eq:meet}
 \sum_{[r,j]\in\ccalR}  \, \sum_{u_t: (u_t, v_{t+1}) \in \ccalE_T} s_{u_t v_{t+1} r j } \leq 1,  \; \forall \,(u_t, v_{t+1}) \in \ccalE_T,
\end{align}
\endgroup
for all $t=0,\ldots,T$. Moreover, avoiding head-on collision collisions at every  gadget, $\forall u, v \in E'$ with $u\not= v$ can be captured by the constraint
\begingroup\makeatletter\def\f@size{10}\check@mathfonts
\def\maketag@@@#1{\hbox{\m@th\normalsize\normalfont#1}}%
\begingroup
\begin{align}\label{eq:headon}
 \sum_{[r,j]\in \ccalR} \left( s_{u_t v_{t+1} r j } + s_{v_t u_{t+1} r j } \right) \leq 1, \; \forall \,(u_t, v_{t+1}) \in \ccalE_T,
\end{align}
\endgroup
for all $t=0,\ldots,T$.

\subsection{Simultaneous movement}\label{sec:extension_essential}
In Section~\ref{sec:gmmpp1}, when identify the robots that are invovled in one instance of GMRPP, we only identify robots $\ccalR_1 \cup \ccalR_{1,2} \cup \ccalR^-$ that are directly involved in the completion of the current subtask (see~{\it (\hyperref[sec:essential_a]{I$_1$})}-{\it (\hyperref[sec:essential_c]{I$_3$})}). However, the rest of robots that are not involved in the current subtask may participate in subsequent subtasks $e$. These robots can move simultaneously  heading towards  waypoints associated with subsequent subtasks of the current subtask $e$. In what follows, we find essential robots associated with subsequent subtasks.

 \paragraph{(\Alph{mycounter}$_4$) Essential robots associated with subsequent subtasks:} These robots move simultaneously with the first two types of robots heading towards  waypoints associated with subsequent subtasks of the current subtask $e$. We collect robots in the set $\ccalR_{1,2}$ and identify them in the following way. First, we identify the completion time  of the current subtask, which is given by $\vec{t}(c+1)$.  Next, we iterate over the remaining robots that are not in $\ccalR_1 \cup \ccalR_{1,2}$. For every such robot $[r,j]$, the time when it should visit the next waypoint based on its local counter $\zeta_{r,j}$ is given by $t_{r,j}(\zeta_{r,j}+1)$. Note that {$t_{r, j}(\zeta_{r,j}+1) > \vec{t}(c+1)$}, since we proceed along the simple path $\theta_{\phi}$ and the completion time of  subtasks that have not been considered, by the precedence relation in~\eqref{eq:12} and the increasing time axis, will be larger than that of the current subtask. Finally, we calculate the time difference $\Delta t = t_{r, j}(\zeta_{r,j}+1) - \vec{t}(c+1)$  and then check whether the robot $[r, j]$ can arrive at the target region $p_{r,j}(\zeta_{r,j}+1)$  within time $\Delta t$ starting from  its current location by taking the shortest route. {If not, robot $[r, j]$ should move simultaneously when completing the current subtask.} In this case, the set of robots that need to move becomes $\ccalR = \ccalR_1 \cup \ccalR_{1,2} \cup \ccalR'_{1,2}\cup \ccalR^-$.

 Next, we determine the target waypoint $X_G(r,j)$ of robot $[r,j] \in \ccalR'_{1,2}$, which is the  location from where robot $[r,j]$ can reach the region $p_{r,j}(\zeta(r,j)+1)$ within time $\Delta t$ by taking the shortest route in the new environment $S'$ (treating robot that do not move as obstacles). If the selected target location of robot $[r',j']$ has already been assigned to another robot in $\ccalR'_{1,2}$, then we select another free cell on the shortest route to be this robot's target location, which is close to the previously selected occupied cell and has not been assigned. In the Definition~\ref{defn:gmmpp} of GMRPP, the requirement on robot $[r,j] \in \ccalR'_{1,2}$ is that it should arrive at the target waypoint at time $T$, that is, design the path $\tau'_{r,j}$ such that $\tau'_{r,j}(0) = X_I(r,j)$ and $\tau'_{r,j}(T) \in X_G(r,j)$.  Similar to robots in $\ccalR_{1,2}$ that complete the current subtask, this requirement can be encoded by setting $t$ as $T$ in constraint~\eqref{equ:sink} that handles the target constraint. Note that the target $X_G(r,j)$ for $[r,j] \in \ccalR_{1,2}'$ is a single cell, other than a region for robots in $\ccalR_{1,2}$.
%% {\it (ii)}
\subsection{Variations of MILP for the high-level plan}\label{sec:extension_milp}
Leveraging that the MILP formulation deals with each subtask directly, we can add more constraints to cater to different restrictions on specific subtasks.
\subsubsection{Whether specific robots participate in a subtask:}
Given an atomic proposition $\ap{i}{j}{k,\chi}$ that appears in the \ltl formula, we can demand  a specific subset of robots, denote by  ${\ccalK}'_j \subseteq \ccalK_j$,  to or not to participate in its satisfaction. Suppose the subset of vertices  in $\ccalG$ that are associated with this literal is $\ccalM_{\ccalV}^\mathsf{lits} (e, 0|1, p, q)$,  then for each specific robot $r \in \ccalK'_j$, we have that
\begin{align}
  \sum_{u:(u,v) \in \ccalE_\ccalG} x_{uvr} = I, \quad  \forall \, v \in \ccalM_{\ccalV}^\mathsf{lits} (e, 0|1, p, q)
\end{align}
where $I=0,1$. We set $I$ as 1 if we require every roobot in $\ccalK'_j$ to participate in the satisfaction of $\ap{i}{j}{k,\chi}$ (where $|\ccalK'_j|\leq i$); otherwise $I=0$ if any robot in $\ccalK'_j$ should not be involved. Note that we iterate all if there are multiple subsets of vertices that are associated with this literal due to that it appears in multiple labels.
\subsubsection{Manage the number of involved robots:}
When completing the task specifiedy by \ltl formula, it may be desirable to dispatch as few robots as possible, so  every dispatched robot engages in more subtasks. On the other hand, considering the resource-constrained component like battery,  we may want dispatched robots to be  as diverse as possible. For instance, if several areas need to be patrolled by robots, in the first  case, we deploy one robot to patrol all areas sequentially. However, if areas are not near to each other,  we deploy more robots such that one robot per area. This requriement can be handled by adding another term to the MILP objective in~\eqref{equ:obj}, which becomes
\begin{align}\label{eq:objective1}
\min \; \; &  \alpha_1 \sum_{(u,v)\in \ccalE_\ccalG}  \sum_{r \in \ccalM^\ccalV_{\ccalK}(v)} d_{uv} x_{uvr} +  \alpha_2  \sum_{e\in X_P} t_e  \nonumber \\ & \pm  \alpha_3 \sum_{v\in \ccalV_{\text{init}}} \sum_{r \in \ccalM_{\ccalK}^\ccalV(v)} \sum_{w:(v,w)\in \ccalE_\ccalG} x_{vwr},
\end{align}
where $\alpha_1 + \alpha_2 + \alpha_3=1$, and the final term  captures the number of robots that leave their initial locations, which is equivalent to  number of robots that are assigned to some subtasks. Objective~\eqref{eq:objective1} adds the final term if fewer robots are desirable otherwise subtracts it if diverser robots are desirable.

\subsubsection{Prohibitive use of the same robots:} In the Definition~\ref{defn:valid} of \ltl formula, we handle such requirement such two atomic propositions with the same non-zero connector are satisfied by the same fleet of robots. On the other hand, we can impose the restriction that some atomic propositions involving the same robot type and with different non-zero connectors are satisfied by two disjoint fleets of robots. For instance, the formula $\Diamond \ap{1}{1}{1,1} \wedge \Diamond \ap{2}{1}{2,2}$ can require that the robot that visits region $\ell_1$ are different from those 2 robots that visit region $\ell_2$. Given such two atomic propositions that are satisfied by different robots, suppose the subsets of vertices in $\ccalG$ that are associated with these two lietrals are $\ccalM_{\ccalV}^\mathsf{lits} (e, 0|1, p, q)$ and $\ccalM_{\ccalV}^\mathsf{lits} (e', 0|1, p', q')$, then, $\forall \, r \in \ccalK_j$, this requirement can be encoded as
\begin{align}\label{eq:atmost1}
  \sum_{v\in \ccalM_{\ccalV}^\mathsf{lits} (e, 0|1, p, q)} & \sum_{u: (u,v) \in \ccalE_\ccalG} x_{uvr} + \nonumber \\
 & \hspace{-2em}  \sum_{v\in \ccalM_{\ccalV}^\mathsf{lits} (e', 0|1, p', q')} \sum_{u: (u,v) \in \ccalE_\ccalG}  x_{uvr} \leq 1.
\end{align}
Constraint~\eqref{eq:atmost1} says that robot $r$ of type $j$ can visit at most one vertex among vertices that are associated with these two literals.


\subsection{Relaxation of conditions}
$x_{uvr}$ where $u$ is the initial location

The pruning of the NBA $B$ and the extraction of sub-NBA $\autop$ in~Section~\ref{sec:app} prunes the space of feasible solutions. Thus, optimality cannot be guaranteed. However, our method does not reduce the feasible set  too much. In particular, edges removed in step~\hyperref[prune:2]{2)} in Subsection~\ref{sec:prune} correspond to vertices with label $\bot$ that can not easily transition to next vertices {(weak terminal vertices in some sense)}. {In Subsection~\ref{sec:pregraph}, pairs of initial and accepting vertices with shorter total length are selected that lead to the  extraction of larger sub-NBA $\auto{subtask}^-$ {with more transitions} from $\auto{relax}$.} {The reason is that edge labels in shorter paths often contain conjunctions of several edge labels in longer paths}. Similarly, edges removed from $\auto{subtask}^-$ in step~\hyperref[sec:pregraph]{2)} {have alternatives simple paths} meaning that their corresponding subtasks can be decomposed into smaller sequential subtasks, {that is, same plan but different schedule}. Finally, in Subsection~\ref{sec:poset} the partial cover problem returns the poset that covers the largest set of linear plans, thus, keeping as many as transitions in $\auto{subtask}^-$. As a result, while optimality can not be guaranteed,  the solutions obtained from the proposed algorithm have low  enough cost. %% Finally, extension to the full class of LTL formulas including negative atomic propositions and consideration of mutual collision avoidance among robots will be our future direction.
\section{Conclusion}
We have proposed an efficient MILP solution to the LTL-MRTA problem. Numerical simulations show that our method outperforms existing methods in terms of runtime and quality of the solution.

\section{Appendix}\label{sec:appendix}
\subsection{Proof of Lemma~\ref{prop:prune}}\label{app:prune}
%% We first show that $\ccalL_E^\phi(\autop^-) = \ccalL^\phi_E(\autop)$ holds after the first 6 steps, then states that this equivalence is not affected by the last step. First, steps~\hyperref[prune:exclusion1]{\it (1)}-\hyperref[prune:violation2]{\it (6)} in Section~\ref{sec:prune} merely  remove infeasible clauses and merge redundant literals. Obviously,  removing  infeasible clauses does not have any effect on the realizable words in $\ccalL_E(\autop)$. Morevoer, given any remaining clause $\ccalC$ in $\autop$, merging redundant literals results in a clause, denoted by $\ccalC'$, in $\autop^-$ that is a subformula of the original one, therefore, the satisfaction of $\ccalC$ implies the satisfaction of $\ccalC'$. On the other hand, the satisfaction of a literal in $\ccalC'$ leads to the satisfaction of the same literal in $\ccalC$ and the merged literals because of this literal, therefore, the satifaction of $\ccalC'$ implies the satisfaction of $\ccalC$. Thus, $\ccalC$ and $\ccalC'$ are logically equivalent, which implies that $\autop$ and $\autop^-$ are logically equivalent in terms of realizability, that is, any realizable words can be accepted by both $\autop$ and $\autop^-$.  %% Therefore, $\autop$ and $\autop^-$ are logically equivalent after steps~\hyperref[prune:exclusion1]{\it (1)}-\hyperref[prune:violation2]{\it (6)}.
%% Therefore, after steps~\hyperref[prune:exclusion1]{\it (1)}-\hyperref[prune:violation2]{\it (6)}, we conclude that  $\ccalL_E(\autop^-)= \ccalL_E(\autop)$. Next, we prove that $\ccalL_E^\phi(\autop^-) = \ccalL^\phi_E(\autop)$ after steps~\hyperref[prune:exclusion1]{\it (1)}-\hyperref[prune:violation2]{\it (6)}.

%% First, we show that $\ccalL_E^\phi(\autop^-) \subseteq \ccalL^\phi_E(\autop)$. Due to $\ccalL_E^\phi(\autop^-) \subseteq \ccalL_E(\autop^-)$ and $\ccalL_E(\autop^-)= \ccalL_E(\autop)$,  any word $w$ in $\ccalL_E^\phi(\autop^-)$ is also in  $ \ccalL_E(\autop)$. Furthermore, because $w \in \ccalL_E^\phi(\autop^-)$, the corresponding run in $\autop$ of the run that $w$ induces in $\autop^-$ is a restricted accepting run. This restricted accepting run  can be directly induced by $w$ in $\autop$ since $w \in \ccalL_E(\autop)$ and $\autop^-$ and $\autop$ are logically equivalent in terms of realizability, making $w \in \ccalL^\phi_E(\autop)$.
%% Thus, $\ccalL_E^\phi(\autop^-) \subseteq \ccalL^\phi_E(\autop)$. Next, we show that the reverse also holds, i.e., $\ccalL^\phi_E(\autop) \subseteq \ccalL_E^\phi(\autop^-)$. For any word $w \in \ccalL^\phi_E(\autop)$, we have that $w \in \ccalL_E(\autop)  = \ccalL_E(\autop^-)$. Since $w$ is in $\ccalL^\phi_E(\autop)$, the induced run in $\autop$ is a restricted accepting run. We can map this run to $\autop^-$ and the mapped run can be induced by $w$ as well, since $w = \ccalL_E(\autop^-)$ and $\autop$ and $\autop^-$ are logically equivalent in terms of realizability. Thus, $w \in \ccalL_E^\phi(\autop^-)$ and further $\ccalL^\phi_E(\autop) \subseteq \ccalL_E^\phi(\autop^-)$. Therefore, $\ccalL_E^\phi(\autop^-) = \ccalL^\phi_E(\autop) $.


First, in Section~\ref{sec:prune} removing infeasible transitions and unreachable vertices will not exclude any realizable words. Therefore, the set of realizable words $\ccalL_E(\autop)$ does not change after this operation. Furthermore, according to condition \hyperref[cond:c]{\it (c)} in Definiction~\ref{defn:run}, any restricted  accepting run  does not contain vertices without self-loops except the initial and accepting vertices, thus, removing such vertices  will not affect the  set of restricted accepting runs of $\autop$. Similarly, because by condition~\hyperref[cond:d]{\it (d)}, any edge whose label does not imply its end vertex label, except that its end vertex is the accepting vertex,  can not appear in any restricted accepting run, removing such edges does not affect the set of restricted accepting runs, either.  Therefore, operations in Section~\ref{sec:prune}  do not affect the set of restricted accepting runs in $\autop$ that can be induced by the realizable words  in $\ccalL^\phi_E(\autop)$. That is, these restricted accepting runs also exist in $\autop^-$ as accepting runs, which implies that $\ccalL^\phi_E(\autop^-) = \ccalL^\phi_E(\autop)$, completing the proof.


%% which leads to that the runs in $\autop^-$ that corrspond to these restricted accepting runs are not affected, either. Hence, $\ccalL^\phi_E(\autop^-)$ does not change. Due to also  that $\ccalL^\phi_E(\autop)$ is irrelevant to any processing, we conclude that $\ccalL^\phi_E(\autop^-) = \ccalL^\phi_E(\autop)$, completing the proof.
\subsection{Proof of Lemma~\ref{prop:inclusion}}\label{app:inclusion}
The inclusion is quite straightforward in that, given a clause $\ccalC$ in $\autop^-$, the clause $\ccalC'$ in $\auto{relax}$ obtained by replacing all negative literals in $\ccalC$ with $\top$ is a subformula of the original clause $\ccalC$, that is, the satisfaction of the original clause $\ccalC$ implies the satisfaction of $\ccalC'$ after replacement, which implies that any realizable word $w$ in $\ccalL_E(\autop^-)$ belongs to $\ccalL_E(\auto{relax})$. Thus, any word $w \in \ccalL^\phi_E(\autop^-)  \subseteq  \ccalL_E(\autop^-)$ belongs to $\ccalL_E(\auto{relax})$. Next, we prove that indeed any word $w \in \ccalL^\phi_E(\autop^-)$ belongs to  $\ccalL^\phi_E(\auto{relax})$ inside $ \ccalL_E(\auto{relax})$.

Since $w \in \ccalL^\phi_E(\autop^-)$, it can induce  a run in $\autop^-$ whose corresponding run in $\autop$ is a restricted accepting run. Since $w$ is also in $\ccalL_E(\auto{relax})$ and clauses in $\auto{relax}$ are the subformulas of the clauses in $\autop^-$, $w$ can induce the same run in $\auto{relax}$ as the run in $\autop^-$ (same sequence of vertices). Additionally, these two runs correspond to the same restricted accepting run in $\autop^-$. Therefore, $w \in \ccalL^\phi_E(\auto{relax})$, i.e.,  $\ccalL^\phi_E(\autop^-)\subseteq \ccalL^\phi_E(\auto{relax})$, completing the proof.

\subsection{Proof of Corollary~\ref{prop:equality}} \label{app:equality}
 We first show that  $\Omega_E^\phi(\autop^-) \subseteq  \Omega_E^\phi(\auto{relax})$. For any run $\rho$ in $\Omega_E^\phi(\autop^-)$, we denote by $w  \in  \ccalL^\phi_E(\autop^-)$ a word that induces it.  Since $\ccalL^\phi_E(\autop^-) \subseteq \ccalL^\phi_E(\auto{relax})$ (see Lemma~\ref{prop:inclusion}), we have that $w \in\ccalL^\phi_E(\auto{relax})$. Furthermore, it can induce the same run in $\auto{relax}$ as $\rho$  in $\autop^-$ since clauses in $\auto{relax}$ are implied by  clauses in $\autop^-$, that is, $\rho \in \Omega_E^\phi(\auto{relax}) $. Therefore, $\Omega_E^\phi(\autop^-) \subseteq  \Omega_E^\phi(\auto{relax})$.

   The inclusion relation $\Omega_E^\phi(\auto{relax}) \subseteq \Omega^\phi(\autop^-)$ is straightfoward considering that  any  run in  $\Omega_E^\phi(\auto{relax})$  belong to  $\Omega^\phi(\autop^-)$ due to $\auto{relax}$ and $\autop^-$ are graphically equivalent and words in $\ccalL^\phi(\autop^-)$ do not consider the realizability, completing the proof.

   \subsection{Proof of Lemma~\ref{prop:nonempty}}\label{app:nonempty}
   \stepcounter{mycounter}
Given a pair of initial and accepting vertices, $v_0$ and $\vertex{accept}$, the correspondsing sub-NBA $\auto{subtask}$ is composed of all vertices and edges in $\auto{relax}$ that are in some paths that connect $v_0$ and $\vertex{accept}$, except that {\it (\Alph{mycounter}$_1$)} all other initial and accepting vertices other than $v_0$ and $\vertex{accept}$ are removed; {\it (\Alph{mycounter}$_2$)} the self-loop of
$v_0$ (if exists) is removed if the initial robot locations do not satisfy its corresponding vertex label in $\autop$ along with the removement of  outgoing edges of the initial vertex if the initial robot locations do not satisfy their corresponding edge labels in $\autop$ (see {\it (B$_1$)} in Section~\ref{sub-NBA:1}); {\it (\Alph{mycounter}$_3$)} if $\vertex{accept}$ has a self-loop, any incoming edge of $\vertex{accept}$ is removed if the corresponding edge label in $\autop$ does not strongly  imply $\gamma_{\phi}(\vertex{accept})$ (see {\it (B$_2$)} in Section~\ref{sub-NBA:1}).

{\it (\Alph{mycounter}$_1$)} First, according to condition \hyperref[cond:b]{\it (b)} in the Definition~\ref{defn:run}, any restricted  accepting run will not include more than one initial vertices and more than one accepting vertices. Since $\ccalL^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{relax})$ are related to the initial and accepting vertices $v_0$ and $\vertex{accept}$, removing other initial and accepting vertices does not affect $\ccalL^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{relax})$.

{\it (\Alph{mycounter}$_2$)} Second, any word $w$ that, at the beginning satisfies the label of the initial vertex $v_0$ whose self-loop is removed or labels of outgoing edges that are removed, can not be generated by feasible paths since initial robot locations violate these labels. Therefore, any such word $w$ does not belong to $\ccalL^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{relax})$.  Thus, the removing of self-loops and outgoing edges  does not affect $\ccalL^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{relax})$.

{\it (\Alph{mycounter}$_3$)} Similarly, if $\vertex{accept}$ has a self-loop, according to condition~\hyperref[cond:e]{\it (e)} in the Definition~\ref{defn:run}, any restricted accepting run with $\vertex{accept}$ constituting the suffix part requires that the incoming edge label of $\vertex{accept}$ strongly implies the label $\gamma_{\phi}(\vertex{accept})$. Therefore, removing the incoming edge whose label does not strongly imply $\gamma_\phi(\vertex{accept})$ does not affect $\ccalL^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{relax})$.


\subsection{Proof of Lemma~\ref{prop:sub-NBA}}\label{app:sub-NBA}
First, the inclusion relation is trivial since $\auto{subtask}^-$ is obtained by removing edges from  $\auto{subtask}$  that is decomposable according to the sequential triangle property (see Definition~\ref{defn:st}). In what follows, we focus on the non-emptyness of $\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-)$.

First, consider 3 different vertices $v_1, v_2, v_3$ that have the ST property. Assume $\auto{subtask}$ is in the vertex $v_1$, we prove that, given robot comfiguration $s$ in a path that completes the subtask $(v_1, v_3)$, that is, driving the transition to vertex $v_3$, we can  simply repeat this robot configuration once so that the sub-NBA $\auto{subtask}^-$ traverses edges $(v_1, v_2)$ and $(v_2, v_3)$.
Specifically, according to the Definition~\ref{defn:st} regarding ST property, since the robot configuration $s$ satisfies the edge label $\gamma(v_1, v_3)$ and $\gamma(v_1, v_3) = \gamma(v_1, v_2) \wedge \gamma(v_2, v_3)$, we have that the robot configuration $s$ satisfies the edge label $\gamma(v_1, v_2)$ and thus, $s$ can drive the transition to vertex $v_2$. At the next time instant, if robots remain idle, the edge label $\gamma(v_2, v_3)$ can be satisfied as well since the robot condiguration $s$ satisfies $\gamma(v_1, v_3)$. Therefore, by repeating this robot configuration, the sub-NBA $\auto{subtask}^-$ traverses edges $(v_1, v_2)$ and $(v_2, v_3)$ consecutively, without satisfying the edge label $\gamma(v_2)$.
%% %% Furthermore, the construction of the path segment $\tau'_{\text{seg}}$ ensures that the Assumption~\ref{asmp:same} is met since the robots remain idle after satisfying the  edge label $\gamma(v_1, v_2)$.

If $\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}) \not= \emptyset$, then there exists a path $\tau$ that meets conditions~\hyperref[asmp:a]{\it (a)}-\hyperref[asmp:b]{\it (b)} in  Assumption~\ref{asmp:same} and generates a word $w$ that induces a run $\rho$ in $\auto{subtask}$ that connects $v_0$ and $\vertex{accept}$. We consider the case where the run $\rho$ traverses an edge $(v_1, v_3)$ corresponding to a composite subtask in $\auto{subtask}$. Otherwise, the run $\rho$ will exist in $\auto{subtask}^-$ and thus, $\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-) \ne \emptyset$. When the run $\rho$ traverses a composite edge, we can locate the robot configuration $s$ in $\tau$ that enables this composite subtask and let robots remain idle for one time instant as discussed above, and then continue along the path $\tau$. Let $\tau'$ denote the new path, which also meets conditions~\hyperref[asmp:a]{\it (a)}-\hyperref[asmp:b]{\it (b)} in Assumption~\ref{asmp:same}. Furthermore, it can  generate a word $w'$ that induces a run $\rho'$ in $\auto{subtask}^-$ that traverses the two elementary edges $(v_1, v_2)$ and $(v_2, v_3)$ that the composite edge corresponds to. Next, we prove that based on the condition that  the corresponding run $\rho_{\phi}$ of $\rho$ is a prefix part of a restricted  accepting run
(due to $w\in \tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask})$, so is the run  $\rho'_{\phi}$ that is the corresponding run of $\rho'$.

These two runs differ only in that $\rho$ traverses edge $(v_1, v_3)$ while $\rho'$ traverses edges $(v_1, v_2)$ and $(v_2, v_3)$ consecutively. Apparently, the run $\rho'_{\phi}$ meets the conditions~\hyperref[cond:a]{\it (a)}-\hyperref[cond:c]{\it (c)} of the restricted accepting run.  Furthermore, $\gamma_{\phi} (v_1, v_2) \simplies_s \gamma_{\phi} (v_2)$ and $\gamma_{\phi}(v_2, v_3) \simplies_s \gamma_{\phi}(v_3)$; otherwise, they are pruned in Section~\ref{sec:prune}. Thus, the run $\rho'_\phi$  satisfies the condition \hyperref[cond:d]{\it (d)} regarding the strong implication in the Definition~\ref{defn:run}.
\stepcounter{mycounter}
Morevoer, (\Alph{mycounter}$_1$) if $v_3 \neq \vertex{accept}$, then $\rho'_{\phi}$ can be the prefix part of a restricted accepting run whose suffix part is the same as the suffix part of the restricted accepting run to which $\rho_\phi$ is the prefix part. Therefore, condition~\hyperref[cond:f]{\it (f)} is met since it is met by the restricted accepting run to which $\rho_{\phi}$ is the prefix part. In this case, $\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-) \neq \emptyset$.
(\Alph{mycounter}$_2$) If $v_3= \vertex{accept}$, according to condition (e) in Definition~\ref{defn:st}, $\gamma_{\phi}(v_3) = \top$ if $(v_1, v_3)$ is removed. In this case, the run  $\rho'_{\phi}$ itself is a restricted accepting run, since its  suffix part only  consists of $\vertex{accept}$ and $\gamma_{\phi}(\vertex{accept})=\top$, which meets the condition~\hyperref[cond:e]{\it (e)}. Thus, we also have $\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-) \neq \emptyset$.
(\Alph{mycounter}$_3$) Finally, if $v_3 = \vertex{accept}$ and $\gamma_{\phi}(v_3)\neq \top$, we do not remove the subtask $(v_1, v_3)$. Therefore, $\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask})$ is not affected, which completes the proof.

\subsection{Proof of Lemma~\ref{prop:sub-NBA2}}\label{app:sub-NBA2}
\stepcounter{mycounter}
The proof is much similar to proofs of Lemma~\ref{prop:nonempty} and~\ref{prop:sub-NBA}. Recall in Section~\ref{sec:suf_prune}, to obtain the sub-NBA $\auto{subtask}$, we remove {\it (\Alph{mycounter}$_1$)} all other accepting vertices from $\auto{relax}$ and all initial vertices without self-loops; {\it (\Alph{mycounter}$_2$)} any outgoing edge of $\vertex{accept}$ if the corresponding label is not implied by the label $\gamma_\phi(\vertex{prior}, \vertex{accept})$, which is the  edge label in the NBA $\autop$ that corresponds to the last completed subtask in the prefix part; {\it (\Alph{mycounter}$_3$)} any incoming edge of $\vertex{accept}$ if the corresponding label is not implied by the label $\gamma_\phi(\vertex{prior}, \vertex{accept})$. According to condition \hyperref[cond:b]{\it (b)} and ~\hyperref[cond:f]{\it (f)} in Definition~\ref{defn:run}, a restricted accepting run does not traverse these vertices and edges. Therefore, removing these vertices and edges does not affect $\ccalL^{\phi,\vertex{accept} \scriptveryshortarrow \vertex{accept}}_E(\auto{relax}; s_{\textup{pre}}, \vertex{prior})$, i.e., $\ccalL^{\phi,\vertex{accept} \scriptveryshortarrow \vertex{accept}}_E(\auto{relax};  s_{\textup{pre}}, \vertex{prior}) = \ccalL^{\phi,\vertex{accept} \scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}; s_{\textup{pre}}, \vertex{prior})$.

To prove that $\ccalL^{\phi,\vertex{accept} \scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-; s_{\textup{pre}},\vertex{prior}) \neq \emptyset$, same as the  proof of Lemma~\ref{prop:sub-NBA}, we can repeat the robot configuration one more time that completes a composite subtask so that the resulting run traverses two elementary edges successively. Since $\vertex{accept}$ does not have a self-loop, we will not remove the composite edge $(v_1, v_3)$ from $\auto{subatsk}^-$ for the  suffix part when $v_3 = \vertex{accept}$. Thus, robots can travel back to their initial locations while driving the transition back to $\vertex{accept}$, which meets the condition~\hyperref[asmp:c]{\it (c)} in the Assumption~\ref{asmp:same}, completing the proof.

\subsection{Proof of Lemma~\ref{thm:nba}}\label{app:nba}
Assumption~\ref{asmp:same} is regarding how a restricted accepting run is implemented by robots. For an accepting  word $w$ belonging to two languages $\ccalL_E^\phi(\ccalA_1)$ and $\ccalL_E^\phi(\ccalA_2)$, if $w$ can be generated by robot paths that meet the Assumption~\ref{asmp:same}, then $w$ should belong to two languages $\tilde{\ccalL}_E^\phi(\ccalA_1)$ and $\tilde{\ccalL}_E^\phi(\ccalA_2)$. Therefore, how an accepting word is implemented does not affect the relationsx between languages. We can get that
$ \tilde{\ccalL}_E^\phi(\ccalA_\phi^-) = \tilde{\ccalL}_E^\phi(\ccalA_\phi)$ by Lemma~\ref{prop:prune},
$\tilde{\ccalL}_E^\phi(\ccalA_\phi^-) \subseteq \tilde{\ccalL}_E^\phi(\auto{relax})$ by Lemma~\ref{prop:inclusion},
$\tilde{\ccalL}_E^{\phi,v_0\scriptveryshortarrow \vertex{accept}}(\auto{relax}) =  \tilde{\ccalL}_E^{\phi,v_0\scriptveryshortarrow \vertex{accept}}(\auto{subtask})$ by Lemma~\ref{prop:nonempty} and  $\tilde{\ccalL}_E^{\phi,v_0\scriptveryshortarrow \vertex{accept}}(\auto{subtask}^-) \subseteq \tilde{\ccalL}_E^{\phi,v_0\scriptveryshortarrow \vertex{accept}}(\auto{subtask})$ by Lemma~\ref{prop:sub-NBA}.


First, we show that $\tilde{\ccalL}_E^{\phi,v_0\scriptveryshortarrow \vertex{accept}}(\auto{subtask}^-) \neq \emptyset$. Consider the accepting  word $w= w^\text{pre} [w^\text{suf}]^\omega$ that is generated by the path $\tau= \tau^\text{pre} [\tau^\text{suf}]^\omega$ that induces a restricted accepting run and meets the Assumption~\ref{asmp:same}, then $w \in \tilde{\ccalL}_E^\phi(\ccalA_\phi)$, thus,  $w \in \tilde{\ccalL}_E^\phi(\ccalA_\phi^-)$ and further  $w^{\text{pre}} \in \tilde{\ccalL}_E^{\phi,v_0\scriptveryshortarrow \vertex{accept}}(\auto{relax})$, where $v_0$ and $\vertex{accept}$ is the pair of vertices  that are involved in the restricted accepting run induced  by the path $\tau$. Consequently, $w^\text{pre} \in  \tilde{\ccalL}_E^{\phi,v_0\scriptveryshortarrow \vertex{accept}}(\auto{subtask})$. By Lemma~\ref{prop:sub-NBA}, $\tilde{\ccalL}_E^{\phi,v_0\scriptveryshortarrow \vertex{accept}}(\auto{subtask}^-) \neq \emptyset$.

Next, we prove that  $\tilde{\ccalL}_E^{\phi, \vertex{accept} \scriptveryshortarrow \vertex{accept}}(\auto{subtask}^-;  \tilde{s}_{\textup{pre}}, \tilde{v}_\textup{prior}) \neq \emptyset$, where $\tilde{s}_{\textup{pre}}= s_{\textup{pre}}$ and $\tilde{v}_\textup{prior} = {v}_\textup{prior}$. As the path $\tau$ induces a restricted accepting run, we have that $w^\text{suf} \in \tilde{\ccalL}_E^{\phi, \vertex{accept} \scriptveryshortarrow \vertex{accept}}(\auto{relax}; s_{\textup{pre}},\vertex{prior})$. To reach the conclusion that $\tilde{\ccalL}_E^{\phi, \vertex{accept} \scriptveryshortarrow \vertex{accept}}(\auto{subtask}^-; s_{\textup{pre}}, \vertex{prior}) \neq \emptyset$, we need to show that the sub-NBA $\auto{subtask}$ for the suffix part is indeed built on the locations $s_{\textup{pre}}$ and the vertex $ \vertex{prior}$, which is equivalent to show that $\vertex{prior}$ is the last vertex traversed before $\vertex{accept}$ in the sub-NBA $\auto{subtask}^-$ for the prefix part and the state  $s_{\textup{pre}}$ enables the edge $(\vertex{prior}, \vertex{accept})$ in $\auto{subtask}^-$. This can not be straightforwardly obtained based on that the  $\vertex{prior}$ is the last vertex traversed in the NBA $\autop$ by the word $w^\text{pre}$, since  $w^\text{pre}$ may not belong to $\tilde{\ccalL}_E^{\phi,v_0\scriptveryshortarrow \vertex{accept}}(\auto{subtask}^-)$ after removing composite subtasks from $\auto{subtask}$ for the prefix part. But there exists another finite word $\overline{w}^\text{pre}$ in $\tilde{\ccalL}_E^{\phi,v_0\scriptveryshortarrow \vertex{accept}}(\auto{subtask}^-)$ that can be obtained from $w^\text{pre}$ by repeating some sets of atomic propositions  due to robots' remaining idle  (see Section~\ref{app:sub-NBA}). Note that by traversing elementary edges,  robots' remaining idle for one time instant drives the transition to the same vertex as that reached by traversing a composite edge. Furthermore, we do not remove any incoming edges of $\vertex{accept}$ when $\gamma_\phi(\vertex{accept}) \neq \top$ ( see condition~(e) in Definition~\ref{defn:st}), thus, the run induced by $\overline{w}^\text{pre}$ traverses the vertex $\vertex{prior}$ right before $\vertex{accept}$ like $w^\text{pre}$ does.  Also, due to that robots remain idle, $\overline{w}^{\text{pre}}$ can be generated by the path share the same final locations as $\tau^{\text{pre}}$. That is, the sub-NBA $\auto{subtask}$ for the suffix part is indeed built on $s^{\text{pre}}$ and $\vertex{prior}$.
By Corollary~\ref{prop:sub-NBA2}, we have that $\tilde{\ccalL}_E^{\phi, \vertex{accept}\scriptveryshortarrow \vertex{accept}}(\auto{subtask}; {s}_{\textup{pre}}, {v}_\textup{prior}) =  \tilde{\ccalL}_E^{\phi,\vertex{accept} \scriptveryshortarrow \vertex{accept}}(\auto{relax}; {s}_{\textup{pre}}, \vertex{prior})$,  thus, $w^\text{suf} \in \tilde{\ccalL}_E^{\phi, \vertex{accept}\scriptveryshortarrow \vertex{accept}}(\auto{subtask}; {s}_{\textup{pre}}, \vertex{prior})$. We conclude that by Corollary~\ref{prop:sub-NBA2}, $\tilde{\ccalL}_E^{\phi, \vertex{accept} \scriptveryshortarrow \vertex{accept}}(\auto{subtask}^-; {s}_{\textup{pre}}, \vertex{prior}) \neq \emptyset$, completing the proof.



%% Furthermore, the path $\overline{\tau}^{\text{pre}}$ that generates $\overline{w}^\text{pre}$ differs from $\tau^\text{pre}$ (which generates $w^\text{pre}$) in that $\overline{\tau}^{\text{pre}}$ contains repetitions of some robot configurations, so the final robot configurations in these two paths are identical.


%% Therefore, the word $\overline{w}^\text{pre} [w^\text{suf}]^\omega$ that are generated by  the concatenated path $\overline{\tau}^{\text{pre}}[\tau^\text{suf}]^\omega$ also belongs to $\tilde{\ccalL}_E^\phi(\ccalA_\phi)$. If follows that $w^\text{suf} \in \tilde{\ccalL}_E^{\phi,\vertex{accept}\scriptveryshortarrow \vertex{accept}}(\auto{subtask})$ where $\auto{subtask}$ for the suffix part is built on the identical  final locations of $\overline{\tau}^\text{pre}$ and ${\tau}^\text{pre}$. By Corollary~\ref{prop:sub-NBA2}, we have that $\tilde{\ccalL}_E^{\phi, \vertex{accept} \scriptveryshortarrow \vertex{accept}}(\auto{subtask}^-; \vertex{prior}) \neq \emptyset$, completing the proof.


\subsection{Proof of Lemma~\ref{prop:feasibility}}\label{app:feasibility}
Given a path $\tau$ that generates a finite word $w \in \tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-)$ that induces a simple path $\theta$ in $\auto{subtask}^-$, we first show that it can give rise to another path so that the starting  vertex label of each subtask in the simple path, if exists, is satisfied at least once. This is because that constraint~\eqref{eq:c} encodes that exactly one clause, respectively,  in the starting vertex label and the edge label of each subtask is satisfied. The construction of new path is straightforward.  Accoridng to condition~\hyperref[cond:d]{\it (d)} in Definition~\ref{defn:run}, for any subtask $e$ in the simple path $\theta$ that is not the first one to be completed, its starting vertex label  is  strongly implied by the edge label of the subtask $e'$ immediately preceding $e$. Therefore, when the  edge label of subtask $e'$ is enabled, robots can remain idle for one time instant to satisfy the starting vertex label of subtask $e$. Also, the satisfied clause in the edge label of $e'$ implies the satisfied clause in the starting vertex label of subtask $e$. On the other hand, if subtask $e$ is the first subtask in the simple path $\theta$, and also the vertex $v_0$ has a self-loop, then the initial robot locations satisfy the label of $v_0$. Thus, similarly robots can remain idle to make the label of $v_0$ true at least once. We still use $\tau$ to denote the new path as the only change is the idleness of robots. The new path $\tau$ still generates a word belonging to $\in \tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-)$ and induces the simple path $\theta$. Note that $\theta$ is a linear extension of the poset $P$ based on which the MILP is formulated. Thus, no two subtasks are completed at the same time in the path $\tau$.

Given the new path $\tau$,  our goal is to show that $\tau$ gives rise to a high-level plan that satisfies the MILP formulation. To this end, we first obtain an {\it essential word} $w^*$ based on the word $w$ that is generated by the path $\tau$, such that the path $\tau$ can also generate the essential word and the essential word $w^*$ is the tightest word that can induce the same run $\rho$ as $w$ does; see Section~\ref{app:word}. Then, we show that the essential word $w^*$ can produce a graph that is a subgraph of the routing graph $\ccalG$ built in Section~\ref{sec:graph}; see Section~\ref{app:graph}. Finally, we show that the subgraph  can be viewed as a graphical solution to the MILP; see Section~\ref{app:milp}.

\subsubsection{Construction of the essential word:}\label{app:word}
Given the path $\tau$ that induces the simple path $\theta$, let $w = \sigma_0 \sigma_1 \sigma_2\ldots \sigma_k$ denote the generated finite  word that belongs to  $\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-)$, and $\rho=v_0 v_1 v_2\ldots \vertex{accept}$  denote the induced run in $\auto{subtask}^-$. Next we obtain  an {\it essential word}, denoted by $w^* =  \sigma^*_0 \sigma^*_1 \sigma^*_2\ldots \sigma^*_k$, such that  $\sigma^*_i \subseteq \sigma_i$ is the tightest subset of atomic propositions that enables one clause of the label $\gamma(v_i, v_{i+1})$ where $v_i$ and $ v_{i+1}$ are consecutive vertices in the run $\rho$, so that  removing any atomic proposition from $\sigma^*_i$ dissatisfies this clause. We identify the satisfied clause in the label $\gamma(v_i, v_{i+1})$  and put all positive literals in this clause  to $\sigma^*_i$. Note that if two sets of atomic propositions $\sigma_i$ and $\sigma_j$ correspond to  the  same vertex label, then $\sigma^*_i = \sigma^*_j$, since by the condition~\hyperref[asmp:a]{\it (a)} in Assumption~\ref{asmp:same}, it is always the same clause that is satisfied in a vertex label. Furthermore, if $\sigma_i$ corresponds to an edge label and $\sigma_{i+1}$ corresponds to the immediate following  vertex label, then $\sigma^*_{i+1} \subseteq \sigma^*_i$, since by the condition~\hyperref[asmp:b]{\it (b)}, the satisfied clauses in the  edge labels implies the satisfied clauses in the immediately following vertex labels. By default, $\sigma_i^* = \{\top\}$ if $\gamma(v_i, v_{i+1})=\top$.  In this way,  we have that $w^* \in \ccalL^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-)$
since it induces the same run $\rho$ as $w$ does, and that the path $\tau$ generating the word $w$ is also a path that can generate the word $w^*$.

\subsubsection{Constrcution of a subgraph of the routing graph:}\label{app:graph}

Given the essential word $w^*$, we can divide it into parts by locating the components where edges in the induced run $\rho$ in $\auto{subtask}^-$ are traversed; see also Fig.~\ref{fig:word}, where green columns represent single time instants when edges  are traversed, that is, subtasks are completed, e.g., $t_{e'}$ and $t_{e}$ where $e'$ is the subtask that is completed immediately preceding $e$, and the white area between any two green columns represents the time intervalss, e.g., $t_{e'}+1, \ldots, t_{e}-1$, when the vertex labels are respected. Note that $t_{e}-1 \geq t_{e'}+1$, since we adjusted the path so that each starting vertex label is satisfied at least one, that is, the accepting run traverses any starting vertex at least twice, leading to that $t_{e} \geq t_{e'}+2$. In this way,  the time interval $t_{e'}+1, \ldots, t_{e}-1$ and the time instant $t_e$ make up the time span of the  subtask $e$ in the simple path $\theta$. Thus, given the path $\tau$, we can obtain an array of time spans of subtasks in the simple path $\theta$ such that every time span is disjoint with each other and subtasks are completed sequentially. In what follows, we build a graph $\ccalG_{w^*}$ based on the essential word $w^*$, which is a subgraph of the routing graph $\ccalG$ in Section~\ref{sec:graph}.
\paragraph{(i) Construction of the vertex set:}\label{app:vertex} To build the graph $\ccalG_{w^*}$ based on the divided  essential word  $w^*$, we begin with the vertex set. First, we create the vertex set $\ccalV_{\text{init}}$ that corresponds to initial robot locations, as in Section~\ref{sec:vertex} for $\ccalG$. For each vertex $v \in \ccalV_{\text{init}}$, we assign visit time $t_{vr}^- = t_{vr}^+ = 0$ to it,  where robot $r$ is the specific robot that is associated with $v$. In what follows, we create vertices associated with clauses in edge or vertex labels that are satisfied by the path $\tau$. Considering a time instant $t_e$ when the edge of a subtask  $e = (v_1, v_2)$ in the simple path $\theta$ is traversed. The set $\sigma_{t_e}^*$ of atomic propositions  contains all literals appearing in the single clause that is satisfied in the edge label $\gamma(v_1, v_2)$. If $\gamma(v_1, v_2) = \top$, then $\sigma_{t_e}^* = \{\top\}$ and we do not create any vertex, as in Section~\ref{sec:vertex}. Otherwise, for each atomic proposition $\ap{i}{j}{k,\chi}$ in $\sigma_{t_e}^*$, we know that there are $i$ robots of type $j$ at region $k$ in the $t_e$-th state of the path $\tau$, and we also know which are within these $i$ robots by checking the path $\tau$. Similar to building the routing graph $\ccalG$ in Section~\ref{sec:vertex}, we construct $i$ vertices pointing to region $k$. Recall that we associate the whole fleet of robots of type $j$ with these $i$ vertices in $\ccalG$. However, for $\ccalG_{w^*}$, we have the information about which specific $i$ robots of type $j$ visit region $\ell_k$ at $t_e$ by checking the path $\tau$. Thus, we can have a one-to-one correspondence between these $i$ robots with these $i$ vertices. In this way, each vertex is visited by one specific robot. These robots are referred to as the essential robots in Section~\ref{sec:run}. Furthermore, the time that the specific  robot $r$ visits its assigned vertex $v$ is $t_e$, which is denoted by $t_{vr}^- = t_{vr}^+ = t_e$. Continuing this way, we create vertices for other atomic propositions in $\sigma_{t_e}^*$, which only correspond to one single clause that is satisfied in $\gamma(v_1, v_2)$. Recall that when building the vertex set of $\ccalG$ in Section~\ref{sec:vertex}, given a label, we build such vertices for each clause. Therefore, the vertex set in $\ccalG_{w^*}$ for the edge label satisfied at $t_e$ is a subset of the vertex set in $\ccalG$ for the same edge label.

\stepcounter{mycounter}
Following the same logic, we can build the vertex set for the satisfied clause in the starting vertex label of $e$. {\it (\Alph{mycounter}$_1$)} If $e$ is not the first completed subtask in the simple path $\theta$,  according to the Assumption~\ref{asmp:same}, the clauses satisfied in this vertex label remain the same, that is, $\sigma^*_t$'s remain the same for all $t= t_{e'}+1, \ldots, t_{e}-1$ where $e'$ is the subtask immediately preceding $e$. Also, it is the same fleet of robots satisfy this clause. Likewise, we can associate each vertex with one single robot, and the visit time interval is set as $[t_{e'}+1, t_{e}-1]$. That is, the robot $r$ remains at its assigned vertex $v$  within this time interval,
%% needs to visit its assigned vertex $v$ at the time instant  no later than  $t_{e-1}+1$ and leave its assigned vertex at the time instant no earlier than $t_{e}-1$,
which are denoted by $t_{vr}^- = t_{e'}+1$ and $t_{vr}^+ = t_{e}-1$. This vertex set will be created in $\ccalG$ since vertices are created for any starting vertex label in Section~\ref{sec:vertex}. {\it (\Alph{mycounter}$_2$)} \label{app:vertex_b} If  $e$ is the first completed subtask in the path $\tau$ and its starting vertex has a self-loop, then,  we create vertices for the satisfied clause as usual and associate them with time interval $[0, t_e-1]$, that is, $t_{vr}^-=0$ and $t_{vr}^+ = t_e-1$. Recall also that, the routing graph $\ccalG$ creates vertices for all clauses in all starting  vertex labels.
Furthermore, we do not create vertices for labels either $\top$ or $\bot$, same as in Section~\ref{sec:vertex}. Therefore, we can conclude that the vertex set of $\ccalG_{w^*}$ is a subset of that of $\ccalG$.



\begin{figure}[!t]
  \centering
  \includegraphics[width=\linewidth]{word.pdf}
  \caption{The divided essential word $w^*$.}
  \label{fig:word}
\end{figure}

\paragraph{(ii) Construction of the edge set:}\label{app:edge_set} Next, we prove that the edge set in $\ccalG_{w^*}$ is also a subset of the edge set in $\ccalG$. Still, consider the edge label that is satisfied at the time instant $t_e$. For a vertex $v$ among those associated with this edge label, we already know the robot $r$ that visits the vertex $v$. Our goal is to determine from which vertex in $\ccalG_{w^*}$ the robot $r$ comes. Let $\tau_{r,j}$ denote by the path of robot $r$ of type $j$. Tracing backward from the $(t_{e}-1)$-th waypoint in $\tau_{r,j}$ (included), we find the most recent time instant $t\leq t_e -1$  when the robot $r$ takes part in the satisfaction of a literal $\ap{i}{j}{k,\chi}$ that appears in the set $\sigma^*_{t}$ of atomic propositions. \stepcounter{mycounter}

{\it (\Alph{mycounter}$_1$)} If such $t$ does not exist, that is, subtask $e$ is the first subtask that robot $r$ participates, then we create an edge starting from the vertex $u$ that points to the initial location of robot $r$ and ending at vertex $v$. We assign the travelling time $T_{uv}=t_e$ to the edge $(u,v)$, which is obtained from  $T_{uv} = t_{vr}^- - t_{ur}^+ = t_e - 0$.
According to step~\hyperref[sec:a]{\it (D$_1$)} in Section~\ref{sec:edge_set}, the edge $(u,v)$ is  also  created in $\ccalG$.

{\it (\Alph{mycounter}$_2$)} If such time instant $t$ exists, let $e'$ denote the subtask this literal $\ap{i}{j}{k,\chi}$ corresponds to. If $e\neq e'$, we have that $e'$ occurs before $e$ in the given path $\tau$, since time spans of subtasks are disjoint and $t < t_e$. Thus, $e' \in X_{<_P}^{e} \cup X_{\|_P}^e$. We locate the vertex $u$ in $\ccalG_{w^*}$ that corresponds to the literal $\ap{i}{j}{k,\chi}$ and is visited by robot $r$, then an edge starting from $u$ and ending at $v$ can be created. Furthermore, we assign the weight $t_{vr}^- - t_{ur}^+$ to this edge (where $t_{vr}^-=t_e$), which is the travelling time the robot $r$ takes between these two consecutive subtasks it undertook. We state that the edge $(u, v)$ also exists in $\ccalG$, since both $u$ and $v$ exist in $\ccalG$, they are associated with the same robot $r$, thus  same robot type, and $u$ is associated with a prior subtask $e'$ of $e$. According to the step~\hyperref[sec:b]{\it (D$_2$)} regarding leaving vertices from prior subtasks in Section~\ref{sec:edge_set}, the edge $(u,v)$ will be created in $\ccalG$.

{\it (\Alph{mycounter}$_3$)} If $e'=e$, in this case, the vertex $u$ that robot $r$ visits is associated with the starting vertex label of the same subtask  $e$. We create the edge $(u,v)$ and assign the travelling time  $T_{uv} = t_{vr}^- - t_{ur}^+$. This edge will be created in $\ccalG$ following the step~\hyperref[sec:c]{\it (D$_3$)} in Section~\ref{sec:edge_set}. Therefore, all edges in $\ccalG_{w^*}$ with the end vertices being associated with edge labels exist in $\ccalG$.

\stepcounter{mycounter}

Following the same way, we create edges that are associated with the starting vertex label of subtask $e$. We deal with vertex labels that are neither $\top$ nor $\bot$. Given a vertex $v$ in $\ccalG_{w^*}$ that is associated with the vertex label $\gamma(v_1)$ of the subtask $e$,  we find  the associated specific  robot $r$ of type $j$.

{\it (\Alph{mycounter}$_1$)} If $e$ is the first completed subtask in the path $\tau$ and its starting vertex $v_0$ has a self-loop, then the initial locations should satisfy the starting vertex label of $e$. We locate the vertex $u$ pointing to the initial location of the robot $r$ of type $j$, create an edge starting from vertex $u$ and ending at $v$ and assign the travelling time $T_{vr}=0$. This edge will be created in steps~\hyperref[edge:vertex1]{\it (E$_1$)} or~\hyperref[edge:vertex2]{\it (E$_3$)} in Section~\ref{sec:edge_set}.

{\it (\Alph{mycounter}$_2$)} If  the subtask $e$ is not the first completed subtask, we start tracing backward from the $t_{e'}$-th waypoint (the subtask $e'$ immediately precedes  $e$) in the path $\tau_{r,j}$ to find the most recent time instant $t$ this robot joins another subtask. Condition~\hyperref[asmp:b]{\it (b)} implies that $t$ should be identical to $t_{e'}$ since the path $\tau$ satisfies the Assumption~\ref{asmp:same}.  We locate the vertex $u$ associated with the edge label of subtask $e'$ that robot $r$ visits, create an edge between $u$ and $v$ and assign the travelling time $T_{uv} = t_{vr}^- - t_{ur}^+$ to the edge. This edge will also be created in step~\hyperref[edge:vertex2]{\it (E$_2$)} in Section~\ref{sec:edge_set}.  Thus, the edge set of in $\ccalG_{w^*}$ is a subset of the edge set of $\ccalG$. Finally, we can conclude that the graph $\ccalG_{w^*}$ based on the essential word $w^*$ is a subgraph of the routing graph $\ccalG$ based on which the MILP is formulated.


The graph $\ccalG_{w^*}$ has the property that there are no cycles and any two paths in $\ccalG_{w^*}$, starting from vertices pointing to initial robot locations  and ending at vertices without outgoing edges, do not share the same vertex, since each path is associated with a specific robot and aligns with the underlying path. Therefore, every vertex except the starting and end vertices in one path has indegree 1 (number of incoming edges) and outdegree 1 (number of outgoing edges). What's more, vertices in $\ccalG_{w^*}$ are associated with the tightest visit time intervals of the specific robot. Consequently, starting from the vertex correponding to the initial location of robot $r$ of type $j$, we can extract a high-level plan $p_{r,j}$ for this robot by traversing along edges, which is a concise description of the underlying path $\tau_{r,j}$. Observe that, given a feasible solution to the MILP, we can build a subgraph of $\ccalG$ by removing any vertices and edges that are not visited by any robots and associating robots and visit time with the remaining vertices. In some sense, such subgraph can be viewed as the graphical depiction of the solution to the MILP. In what follows, we show that the graph $\ccalG_{w^*}$ can be one of such graphs, that is, it can give rise to a feasible solution to the constraints~\eqref{eq:1}-\eqref{eq:same}.

\subsubsection{Satisfaction of MILP constraints:}\label{app:milp}
\paragraph{(1) Routing constraints:} Any vertex in $\ccalG_{w^*}$ is visited by a single robot of certain type, thus, constraint~\eqref{eq:1} that each vertex is visited by at most one robot of certain type can be  satisfied. Specially, given a vertex $v$, its associated robot $r$ and unique vertex $u$ that is connected to $v$, we set $x_{uvr}=1$  and $x_{uvr'}=0$ for other robots $r'$ of the same type as $r$. In what follows, we omit the assignment analysis when it is clear to recognize. Furthermore, each vertex outside $\ccalV_{\text{init}}$  is either a sink veretex (indegree is 1, outdegree is 0) or a vertex with indegree equaling outdegree. Therefore, the flow constraint~\eqref{eq:2} is satisfied. For each vertex in $\ccalV_\text{init}$ of $\ccalG_{w^*}$, its outdegree is either 0 or 1, thus, constraint~\eqref{eq:2.5a} is satisfied. Each vertex in $\ccalV_\text{init}$ is associated with a unique robot, thus, constraint~\eqref{eq:2.5b} is also satisfied.
\paragraph{(2) Scheduling constraints:} Since the visit time of each vertex  is non-negative and the visit time associated with the vertices in $\ccalV_{\text{init}}$ is set as $t_{vr}^- = t_{vr}^+ = 0$ (see Section~\ref{app:vertex}), constraints~\eqref{eq:3} and~\eqref{eq:3.5} are satisfied trivially. Recall that we set the tavelling time $T_{uv}$  between connected vertices $u$ and $v$ in $\ccalG_{w^*}$ as $t_{vr}^- - t_{ur}^+$, which is the acutual time the robot $r$ takes to travel between regions associated with $u$ and $v$. Obviously, $T_{uv}$ is no less than the shortest travelling time $T^*_{uv}$ between these two regions, i.e., $T_{uv}^* \leq T_{uv}$. When $u \in \ccalV_\text{init}$ or $u <_P v$ or $(u,v)\in X_P$ and  when robot $r$ travels the edge $(u, v)$, i.e., $x_{uvr}=1$, constraint~\eqref{eq:4b} holds since $t^+_{ur} + T^*_{uv} \leq t^+_{ur} + T_{uv} = t^-_{vr}$. Next, when $u \|_P v$, constraint~\eqref{eq:4a} can be satisfied if all robots are frozen for one time instant within the time interval $[t_{ur}^+, t_{vr}^-]$. The elongated path can still generate a word belonging to $\tilde{\ccalL}^{\phi,v_0\scriptveryshortarrow \vertex{accept}}_E(\auto{subtask}^-)$.
\stepcounter{mycounter}

{\it (\Alph{mycounter}$_1$)} If the starting vertex $u$ in $\ccalG_{w^*}$ is associated with a vertex label in $\auto{subtask}^-$, recall that we assign $t_e-1$ to $t_{ur}^+$ when constructing the vertex set, that is, the time instant right before a subtask is completed (see Section~\ref{app:vertex}). Thus, at the time instant $t_{ur}^+$, the run $\rho$ has not left the NBA vertex in $\auto{subtask}^-$ that vertex $u$ is associated with. We can repeat one more time the locations of all robots in the path $\tau$ at the time instant $t_{ur}^+$  so that the run visits the same NBA vertex  one more time. In this way, the travelling time assigned to  the edge $(u,v)$ becomes $T_{uv}+1$, where $T_{uv}$ is the time robot $r$ takes in the path $\tau$ and 1 is the extra time it takes when all robots remain idle for one time instant. Therefore, constraint~\eqref{eq:4a} holds.

{\it (\Alph{mycounter}$_2$)} Similarly, if the end vertex $v$ is associated with a vertex label in $\auto{subtask}^-$, recall that we assign $t_{e'}+1$ to $t_{vr}^-$ when constructing the vertex set, that is, the time instant right after a subtask is completed. The vertex label is satisfied at $t_{vr}^-$ since the  label of each vertex in the simple path $\theta$ is satisfied at least once according to the construction of the path $\tau$ at the begining of Section~\ref{app:feasibility}. Thus, we can repeat one more  time the locations of all robots in the path $\tau$ at the time instant $t_{vr}^-$  so that the run visits the same NBA vertex  one  more time. Same as before, the travelling time assigned to  the edge $(u,v)$ becomes $T_{uv}+1$.

{\it (\Alph{mycounter}$_3$)} If both $u$ and $v$ in $\ccalG_{w^*}$ are associated with an edge label in $\auto{subtask}^-$, then these two vertices must correspond to two different subtasks. Furthermore, there must be a NBA vertex with a  self-loop between these two subtasks in the simple path $\theta$, since according to condition~\hyperref[cond:b]{\it (b)} only initial and accepting vertices can have no self-loops but they can not be between two edges in the path $\theta$ if they do not have self-loops. In this case, robots can remain idle for one more time  when this vertex label is true. Same as before, the travelling time assigned to  the edge $(u,v)$ becomes $T_{uv}+1$.


Therefore, constraint~\eqref{eq:4a} are satisfiable in these 3 cases. We highlight that the path $\tau$ after modification still produces a prefix part of a restricted accepting run since the result of idleness is  that a vertex in the run $\rho$ is visited by one more time.  Thus, robots remaining idle for a period of time does not affect the satisfaction of other constraints. In what follows, we still focus on the path $\tau$, since if it satisfies the others constraints, so does the modified path.

\paragraph{(3) Logical constraints:} Each set $\sigma^*_i$ of atomic propositions in the essential word $w^*$ collects all literals inside one clause, and all $\sigma^*_i$'s that are associated with the same vertex label collect literals of the same clause. Therefore, constraint~\eqref{eq:c} that one and only one clause is true is satisfied. Although the path $\tau$ can simultaneously satisfy more than one clauses in a label, we construct the essential word $w^*$ by selecting only one clause, and build the graph $\ccalG_{w^*}$ and select the essential robots based on $w^*$. In this sense, we can state that only one clause is true on the graph $\ccalG_{w^*}$. Moreover, because every vertex in $\ccalG_{w^*}$ corresponding to the same clause is visited by one robot, constraint~\eqref{eq:6} regarding one robot per vertex is satisfied. Recall that when constructing the vertex set of $\ccalG_{w^*}$, we associate each vertex $v$ corresponding to the same edge label with time $t_{vr}^- = t_{vr}^+ = t_e$, therefore, the simultaneous visitation constraint~\eqref{eq:7} is satisfied.

\paragraph{(4) Temporal constraints:}
\paragraph{(i) Temporal constraints on one subtask:} As said before, each vertex $v$ in $\ccalG_{w^*}$ corresponding to the same edge label is associated with time $t_{vr}^- = t_{vr}^+ = t_e$, and only one clause is true, therefore, constraint~\eqref{eq:edgetime} regarding the computation of the completion time is satisfied. When constructing the vertex set of $\ccalG_{w^*}$, we assocaite each vertex $v$ corresponding to the same vertex label (neither $\bot$ nor $\top$) with the same arriving time $t_{vr}^- = t_{e'}+1$ and the same leaving time $t_{vr}^+ = t_{e}-1$, where $t_e$ is the completion time of the subtask that the vertex label corresponds to and $t_{e'}$ is the completion time of the subtask immediatedly preceding it in the simple path $\theta$. As subtasks in  the simple path $\theta$ are sequentially completed, we have that $t_{vr}^- = t_{e'}+1\leq t_e$, which shows that the left side of constraint~\eqref{eq:17} holds. The right side holds trivially since $t_e = t_e-1+1 = t_{vr}^+ +1$. Next, if the initial vertex does not have a self-loop, and if the outgoing edge in the simple path $\theta$ is labeled with $\top$, there is no vertex in $\ccalG_{w^*}$ that corresponds to this edge. We can just define the completion time of this edge label as 0, as stated by~\eqref{eq:tis0}. Otherwise, if the label of the outgoing edge is not $\top$, then the initial robot locations will satisfy it, that is, the set $\sigma^*_0$ of atomic propositions include literals that appear in the satisfied clause in the edge label.
Therefore, vertices are created in $\ccalG_{w^*}$ for these literals and the assigned visit time corresponds to the index of $\sigma_0^*$, i.e., 0. Thus, in this case~\eqref{eq:tis0} also holds.

\paragraph{(ii) Temporal constraints on the completion of two sequential subtasks:}
Since the simple path $\theta$ in $\auto{subtask}^-$, induced by the path $\tau$, is a linear extension of the poset $P$, so the linear order of subtasks in $\theta$ respects the partial order in the poset $P$. Thus, given a subtask $e$ in the simple path $\theta$, any subtask $e'\in \theta$ with $e' \prec_P e$ is completed before $e$ in the path $\tau$. Therefore, $t_{e'} +1 \leq t_e$, which satisfies constraint~\eqref{eq:12}.
\paragraph{(iii) Temporal constraints on the completion of the
current substask and the activation of subsequent
substasks:}
For each subtask $e$ except the last one in the simple path $\theta$, the subtask $e'$ immediately following it in $\theta$ belongs to the set $X_{\succ_P}^e \cup X_{\|_P}^e$. If $e' \in X_{\succ_P}^e \neq \emptyset$ as in \hyperref[activation:a]{\it (F$_1$)}, since there is only the subtask $e'$ in the simple path $\theta$ that immediately follows $e$, constraint~\eqref{eq:bafter} holds. The completion time  of subtasks $e'$ immediately following  $e$ in the simple path is larger than that of $e$ by at least 1, therefore, constraint~\eqref{eq:after} is satisfied. %% As discussed in the temporal constraints on the completion of two sequential subtasks, robots can remain idle to satisfy the vertex label, making constraint~\eqref{eq:after} satisfiable no that what positive integer that $M_{\text{min}}$ takes.
Furthermore, for each vertex $v$ associated with the edge label of subtask $e'$, we associate it with the arriving time $t_{vr}^- = t_{e}+1$, which satisfies the constraint~\eqref{eq:20}. Since the simple path $\theta$ is a linear extension of the poet $\theta$, no subtasks are completed at the same time, which satisfies constraint~\eqref{eq:diff}. If $X_{\succ_P}^e = \emptyset$ as in \hyperref[activation:b]{\it (F$_2$)}, then $e' \in X_{\|_P}^e$. As subtask $e'$ follows $e$, $b_e^{e'}=0$ and  subtask $e$ is not the last completed one, constraints~\eqref{eq:afterparallel_a}-\eqref{eq:afterparallel_c} are satisfied by setting $b_{ee'}=1$.  As for the last subtask in the simple path, $b_{ee'}=0$  in~constraints~\eqref{eq:afterparallel_a}-\eqref{eq:afterparallel_c}.

On the other hand, for any subtask $e$ in the simple path $\theta$ except the first one, it immediately follows a subtask, denoted by $e'$, which should be in $X_{\prec_P}^e \cup X_{\|_P}^e$. If $e'\in  X_{\prec_P}^e \neq \emptyset$, since there is only the subtask $e'$ in the simple path $\theta$ that immediately precedes $e$, constraint~\eqref{eq:follow1} holds. Otherwise, if $X_{\prec_P}^e = \emptyset$, then $e \in X_{\|_P}^e$. As subtask $e'$ precedes $e$, $b_e^{e'}=1$ and subtask $e$ is not the first completed one, constraints~\eqref{eq:follow_a}-\eqref{eq:follow_c} are satisfied by setting $b_{e'e}=1$.  As for the last subtask in the simple path, $b_{e'e}=0$ in~constraints~\eqref{eq:follow_a}-\eqref{eq:follow_c}.

\paragraph{(iv) Temporal constraints on the activation of the first subtask:}
Consider the first completed subtask $e$ in the path $\tau$. If its starting vertex has a self-loop, and also the vertex label is not $\top$,
then this vertex label is satisfied at least once by the construction of the path $\tau$, and  there are vertices in $\ccalG_{w^*}$ associated with the satisfied clause in this vertex label. Since the assigned time $t_{vr}^-$ to these vertices is 0, constraint~\eqref{eq:zeroactivation} is satisfied. For the first subtask $e$, since there is no subtask before it, the robots  visiting vertices associated with the starting vertex label of $e$ comes from the vertices in $\ccalV_{\text{init}}$, thus, constraint~\eqref{eq:routingforactivation_a} is satisfied for subtask $e$. For subtasks in $P_{\text{max}}$ other than $e$, the vertices associated with their vertex labels are connected to vertices associated with the edge labels of subtasks that are completed immediately preceding them; see Section~\ref{app:edge_set}. Therefore, constraint~\eqref{eq:routingforactivation_b} is satisfied.


\paragraph{(5) Same-$\ag{i}{j}$ constraints:}
Give any two vertex subsets in $\ccalG_{w^*}$ that are assocaited with two literals that share the same non-zero connector, they are visited by the same fleet of robots since the essential word $w^*$ belong to $\title{\ccalL}_E^{v_0 \scriptveryshortarrow \vertex{accept}}(\auto{subtask}^-)$. We enumerate these two vertex subsets such that there is a one-to-one correspondence between vertices in these two subsets and the matched pair of vertices are visited by the same robot. In this way, constraint~\eqref{eq:same} are satisfied, which completes the proof.




%%  (b) If its starting vertex has a self-loop whereas the starting vertex only appears once in the run $\rho$, which means the edge label is satisfied at time 0. In this case, as in step (b) in Section~\ref{app:vertex} when constructing the vertex set, there are no vertices created in $\ccalG_{w^*}$ associated with this vertex label. However, there are vertices in $\ccalG$ for this vertex label since we create vertices in $\ccalG$ for each vertex label that is neither $\top$ nor $\bot$. Therefore, constraint~\eqref{eq:zeroactivation} should be still satisfied regarding these vertices in $\ccalG$. That is, those vertices associated with the clause that is set as true by constraint~\eqref{eq:c} should be visited at time 0, which is achievable. First, since the starting vertex has a self-loop, the initial robot locations satisfy its vertex label, otherwise, its self-loop will be removed in Section~\ref{sub-NBA:1} when extracting the sub-NBA $\auto{subtask}$. Second, in $\ccalG$ edges exist that end at these vertices and start from  vertices pointing to initial robot locations (see steps~\hyperref[edge:vertex1]{\it (a)} and~\hyperref[edge:vertex2]{\it (b)} when constructing the edge set). The shortest travelling time is 0 since initial robot locations satisy the starting vertex label. Furthermore, the leaving time from vertices in $\ccalV_{\text{init}}$ that point to initial robot locations are set as 0 when constructing the graph $\ccalG_{w^*}$. Thus, according to scheduling constraint~\eqref{eq:4b}, $t_{vr}^-$ can be 0. In this way, constraint~\eqref{eq:zeroactivation} is satisfied. Note that additionally,  the subtask $e$ is completed  by the path $\tau$ at time 0, thus the vertices in $\ccalG$ associated with the satisfied clause in the edge label of $e$ should be visited at time 0, which is also achievable.
%% First, edges in $\ccalG$ exist ending at these vertices and starting from vertices pointing to initial robot locations and vertices associated with the starting vertex label of $e$. The shortest travelling time is 0 since the both the clause in the starting vertex label and the clause in the edge label are   satisfied by initial robot locations. Furthermore, the leaving time from vertices pointing to initial robot locations and vertices associated with the starting vertex label of $e$ can be 0, therfore, scheduling constraint~\eqref{eq:4b} allows these vertices associated with the satisfied clause in the edge label to be visited at time 0. In other words, when the starting vertex labell of the first complete subtask $e$ in the path $\tau$ is not satisfied for once, in $\ccalG_{w^*}$ robots leave from vertices pointing to their initial locations and reach the vertices associated with the edge label of $e$ at time 0; while in $\ccalG$, robots first reach the vertices associated with the starting vertex label and then reach the vertices associated with the edge label of $e$. Because the travelling time is 0, robots can reach these two kinds of vertices both at time 0, so that achieve the goal of respecting the path $\tau$ and satisfying  the constraint~\eqref{eq:zeroactivation} at the same time.

%% \subsection{Proof of Lemma~\ref{prop:adjustment}}\label{app:adjustment}
%% We note that if two subtasks are completed at the same time, then these two subtasks are temporally independent since otherwise, the completion time of two temporally dependent subtasks are different according to constraint~\eqref{eq:12}. Cosider such two independent subtasks $(v_1, v_4)$ and $(v_4, v_3)$ in Fig.~\ref{fig:id}.  Given a path segment $\tau_{\text{seg}}$ that completes these two independent subtasks at the same time, as shown in the proof of Lemma~\ref{prop:sub-NBA},  we can construct another path segment $\tau'_{\text{seg}}$ by freezing the movement of all robots for two more time instants, so that subtask $(v_4, v_3)$ are completed right after $(v_1, v_4)$. Based on this, given a solution to the MILP formulation, we construct another solution in the following way. First, we keep the values of all routing variables $x_{uvr}$ unchanged since we only adjusted time. Next, let $t$ denote by the time in the solution when two subtasks are completed simultaneously. We select one between these two subtasks and fixed
%% We increase all scheduling variables $t_{vr}^-, t_{vr}^+$ and $t_e$ in the solution whose values are

\subsection{Proof of Lemma~\ref{prop:run}}\label{app:run}
We first show that the solution to the MILP gives rise to a simple path $\theta$ in the set of simple path $\Theta$ from which the poset $\theta$ is inferred. In the MILP formulation, we define a variable for each subtask in $X_P$ which indicates its completion time (see Section~\ref{sec:temporal}) and require that completion time of two subtasks are different (see constraint~\eqref{eq:diff}).  Thus, we can sort the subtasks in $X_P$  in an ascending order with respect to their completion time. Then, the sorted subtasks respect the partial order in $\theta$ since precedence relations among subtasks are captured by constraint~\eqref{eq:12}, which means the sorted subtask is a linear extension of the poset $P$. Furthermore, the set of simple paths $\Theta$ is equivalent to the set of  linear extensions of the poset $P$, which is ensured in Section~\ref{sec:poset}. Therefore, the sorted subtasks belong to a simple path in $\Theta$. Finally, since the  backtracking search algorithm is complete, it is ensured that such simple path will be found in $\auto{subtask}^-$. In what follows, we prove the properties this simple path $\theta$ has:

First, for the first subtask in the simple path $\theta$, if the initial vertex $v_0$ does not have a self-loop, then according to constraint~\eqref{eq:tis0}, it must be completed at time 0, thus, the activation time is also 0. Otherwise, if $v_0$ has a self-loop and also the vertex label in $\auto{subtask}^-$ is $\top$, then we can view that it is activated at anytime, including 0; else if $v_0$ has a self-loop of which the  label  not $\top$, according to constraint~\eqref{eq:zeroactivation}, the activation of the vertex label is 0. Therefore, property~\ref{property:a} holds.

Second, for any subtask $e$ in the simple path $\theta$, if its starting vertex label has a self-loop and the vertex label is $\top$, the property~\ref{property:b} holds trivially, else if the vertex label is not $\top$,  constraint~\eqref{eq:17} ensures that  property~\ref{property:b} holds.

Finally,  for  property~\ref{property:c}, given any two consecutive subtasks $e$ and $e'$ in the simple path $\theta$, we show that it is exactly $e' \in S_3^e = X^e_{\succ_{P}} \cup X^e_{\|_{P}}$ that makes $b_{ee'}=1$ in constraint~\eqref{eq:bafter}. If so, according to constraint~\eqref{eq:20}, subtask $e'$ is activated at most one time instant later than the completion of $e$, which implies the property~\ref{property:c}. We prove by induction.

Consider $e_0$ and $e_1$ that are the first two subtasks in the simple path $\theta$. As $e_1$ is completed immediately after $e_0$, we have that $e_1\in X^{e_0}_{\succ_{P}} \cup X^{e_0}_{\|_{P}} $, thus, ${e_0} \in X^{e_1}_{\prec_{P}} \cup X^{e_1}_{\|_{P}}$. As subtask $e_1$ is not the first one in $\theta$, according to constraints~\eqref{eq:follow1}-\eqref{eq:follow}, there must exist  a subtask $e \in X^{e_1}_{\prec_{P}} \cup X^{e_1}_{\|_{P}} $ such that $b_{e e_1}=1$. Assume that $e \neq e_0$. According to constraint~\eqref{eq:after}, subtask $e$ must be completed before $e_1$, but it is only subtask $e_0$ that occurs before $e_1$ in the simple path $\theta$, a contradiction. Therefore, $e  = e_0$. i.e., it is exactly subtask $e_1$ that makes $b_{e_0 e_1}=1$. Next, we assume that for any two consecutive subtasks $e_{i-1}$ and $e_{i}$ in $\theta$ that $b_{e_{i-1} e_i} = 1$. Given the next two subtasks $e_{i}$ and $e_{i+1}$, assume that $e' \in X^{e_{i+1}}_{\prec_{P}} \cup X^{e_{i+1}}_{\|_{P}}$ and $e' \neq e_i$. According to constraint~\eqref{eq:after}, $e'$ is completed before $e_{i+1}$. However, $e'$ can not be any subtask in $e_0, \ldots, e_{i-1}$, since it will contradict constraint~\eqref{eq:bafter} that the immediatedly following subtask of any subtask in $e_0, \ldots, e_{i-1}$ is unique. Therefore, $e' = e_i$, completing the proof.




%% we first show that we can build a one-to-one correspondence between any subtask and the subtask that immediately follows it. Recall that $b_{ee'}=1$ if subtask $e'$ is immediately after $e$. The one-to-one correspondence is that for any two different subtasks $e$ and $e'$, if $b_{ee'}=1$,  there does not exist a third different  subtask $e''$ in $X_P$ such that  $b_{ee''}=1$ or $b_{e''e'}=1$.




\subsection{Proof of Lemma~\ref{prop:valid}}\label{app:valid}
Given a subtask $e = (v_1, v_2)$ in the simple path $\theta$, the goal of the formulated  GMRPP is to design paths for robots to reach locations that satisfy the complete clause $\gamma_{1,2}^+ \wedge \gamma_{1,2}^-$ in the edge label $\gamma(v_1, v_2)$ to complete the current subtask and activate the next subtask while respecting the complete clause $\gamma_1^+ \wedge \gamma_1^-$ in the starting vertex label $\gamma(v_1)$. By starting from the first subtask in the simpe path $\theta$, we proceed along the simple path to prove that each instance of GMRPP with initial locations generated by the previous instance is feasible.


Consider the first subtask $(v_1, v_2)$ with $v_1 = v_0$. We first discuss the case where  the initial vertex $v_0$ has a self-loop in the sub-NBA $\auto{subtask}^-$, which implies that the initial robot locations satisfies the label $\gamma_{\phi}(v_0)$ in the NBA $\autop$, otherwise we will remove its self-loop; see Section~\ref{sec:sort} and \ref{sub-NBA:1}. Next, we continue based on whether the sets of essential robots $\ccalR_1$ and $\ccalR_{1,2}$ are disjoint.
\stepcounter{mycounter}
\paragraph{ (\Alph{mycounter}$_1$) $\ccalR_1 \cap \ccalR_{1,2} = \emptyset$}\label{app:gmrpp_a}: According to property~\ref{property:b} in Lemma~\ref{prop:run}, in the solution to the MILP, the complete clause $\gamma_1^+ \wedge \gamma_1^-$ can only become false at the same time $\gamma_{1,2}^+ \wedge \gamma_{1,2}^-$ becomes true. At the initial time 0, according  to property~\ref{property:a} in Lemma~\ref{prop:run}, the robot locations satisfy $\gamma_1^+ \wedge \gamma_1^-$, including those robots in $\ccalR_{1,2}$, so  they can move around safely  within their respective regions without violating $\gamma_1^-$. By assumption that there is a label-free path between any two regions, these robots in $\ccalR_{1,2}$ can move to label-free cells without traversing other regions, and take this label-free path to  some label-free cells that are adjacent to their target regions. This process does not  violate  the negative clause $\gamma_1^-$. Also, $\gamma_1^+$ is satisfied due to $\ccalR_1 \cap \ccalR_{1,2} = \emptyset$. At this point, the essential clause $\gamma_{1,2}^+$ can be satisfied in one  time instant. If, at this time, some robots in $\ccalR^-\setminus \ccalR_{1,2}$ violate $\gamma_{1,2}^-$ (robots in $\ccalR_{1,2}$ stay at label-free cells now), then without traversing other regions, these robots  move to somewhere within their respective regions from which they can reach the label-free cells in one time instant. This process also respects the complete clause $\gamma_1^+ \wedge \gamma_1^-$. Finally, at the same time, robots in $\ccalR_{1,2}$ move to their target regions and these robots in $\ccalR^-\setminus \ccalR_{1,2}$ that violate $\gamma_{1,2}^-$   move out their regions to label-free cells, then the complete label $\gamma_{1,2}^+ \wedge \gamma_{1,2}^-$ is satisfied. Note that robots moving to target regions to satisfy $\gamma_{1,2}^+$, will not contradict the negative clause $\gamma_{1,2}^-$, since infeasible clauses are removed in step~\hyperref[prune:exclusion2]{\it (2)} in Section~\ref{sec:nba}.


\paragraph{(\Alph{mycounter}$_2$) $\ccalR_1 \cap \ccalR_{1,2} \neq \emptyset$:} In this case, for a robot $r \in  \ccalR_1 \cap \ccalR_{1,2}$, the shortest travelling time between its source region and target region is less than or equal to 1, since by constraint~\eqref{eq:17}, the completion time of the subtask is at most one time instant later than the completion time of its starting vetex label. That is, its source  region and target region are identical or adjacent (we view overlapping regions as adjacent). As in case~\hyperref
          [app:gmrpp_a]{\it (\Alph{mycounter}$_1$)}, robots in $\ccalR_{1,2} \setminus \ccalR_1$ move to label-free cells from which their target regions can be reached in one time instant, while robots in $\ccalR_{1,2} \cap \ccalR_1$ move to somewhere within their respective source regions from which they can reach the target regions and leave the source regions in one time instant. Without traversing other regions, the complete clause $\gamma_1^+ \wedge \gamma_1^-$ remains satisfied. Next, similar to case case~\hyperref [app:gmrpp_a]{\it (\Alph{mycounter}$_1$)}, robots in $\ccalR^-\setminus \ccalR_{1,2}$ move to somewhere within their respective regions from which they can reach the label-free cells in one time instant. In this way, $\gamma_{1,2}^+ \wedge \gamma_{1,2}^-$ can be satisfied at the next time instant.

We have shown the feasiblity of GMRPP when the intial vertex $v_0$ in $\auto{subtask}^-$ has a self-loop. In the case where $v_0$ does not have a self-loop in $\auto{subtask}^-$, we have that the initial robot locations satify the complete clause  $\gamma_{1,2}^+ \wedge \gamma_{1,2}^-$ in the  edge label; otherwise, the edge will be  removed; see Section~\ref{sec:sort} and \ref{sub-NBA:1}. We will not formulate the GMRPP in this case; see line~\ref{seq:terminate_1}, Alg.~\ref{alg:sequentialMAPP}.


Whether or not $v_0$ has a self-loop, the complete clause $\gamma_{1,2}^+ \wedge \gamma_{1,2}^-$ is satisfied at last. According to condition~\hyperref[cond:d]{\it (d)} in the Definition~\ref{defn:run} and conditions~\hyperref[asmp:b]{\it (b)} in the Assmption~\ref{asmp:same}, the complete clause in the end vertex label $\gamma_\phi(v_2)$ can be satisfied automatically, which activates the next subtask, which aligns with theproperty~\ref{property:c} in Lemma~\ref{prop:run} that  the next subtask will be activated at most one time instant later than the current one.  We can apply the same logic in \hyperref [app:gmrpp_a]{\it (\Alph{mycounter}$_1$)} and \hyperref [app:gmrpp_a]{\it (\Alph{mycounter}$_2$)} to the remaining subtasks in the simple path $\theta$, since each subtask is activated by the previous subtask like the first subtask is activated by the initial robot locations, completing the proof.

%% We differentiate the last subtask since, when the end vertex $\vertex{accept}$ has a self-loop in $\auto{subtask}^-$, it may be the case where the edge label does not strongly imply the label of $\vertex{accept}$. In this case, after satisfying the complete clause in the edge label, robots need to move  to satisfy the label of $\vertex{accept}$ in the next time instant. We claim that the correponding GMRPP falls into one of the following 3 categories: (a) the complete clause in the end vertex label $\gamma(v_2)$ is a subformula of the compositve clause in the edge label $\gamma(v_1, v_2)$, so that it suffices to satisfying the edge label at last. Most instances of GMRPP belong to this category due to condition~\hyperref[cond:d]{\it (d)} in the Definition~\ref{defn:run} and conditions~\hyperref[asmp:b]{\it (b)}~\hyperref[asmp:c]{\it (c)} in the Assmption~\ref{asmp:same}; (b) the complete clause in the end vertex is $\bot$, which occurs when the end vertex is the accepting vertex $\vertex{accept}$ without a self-loop. In this case, it suffices to satisfy the edge label as well; (c) the complete clause in the end vertex $v_2$ is not the subformula of the complete clause in the edge label, which occurs when the end vertex is the accepting vertex with a self-loop. In what follows, we first discuss the first two categories and then the last category. For categories (a) and (b), we first consider the case where the sets of  essential robots $\ccalR_1$ and $\ccalR_{1,2}$ do not overlap. The robot location As two free cells in the environment are connected, $\ccalR$

\subsection{Proof of Theorem~\ref{thm:prefix}}\label{app:prefix}
As stated in Theorem~\ref{thm:nba}, if Problem~\ref{prob:1} is feasible, then there exists a pair of initial and accepting vertices, denoted by $v_0$ and $\vertex{accept}$, such that $\tilde{\ccalL}_E^{\phi, v_0 \scriptveryshortarrow \vertex{accept}}(\auto{subtask}^-) \neq \emptyset$. Since in Section~\ref{sec:sort}, we iterate all pairs of initial and accepting vertices whose total length is not infinite, we will deal with the NBA $\auto{subtask}^-$ that are associated with this pair. In Section~\ref{sec:poset}, we collect all simple paths that connect $v_0$ and $\vertex{accept}$, infer the poset from each subset of equivalent simple paths and treat each simple path as a poset if no such poset exists, so we will formulate the MILP on the poset that includes the simple path that a feasible path to Problem~\ref{prob:1} induces. According to Lemma~\ref{prop:feasibility}, the MILP has a solution. Then, following Lemma~\ref{prop:valid}, we get that a path $\tau$ can be obtained by concatenating paths from each instance of GMRPP.


Next, we show that the run $\rho$ induced by this path $\tau$ satisfies~conditions~\hyperref[cond:a]{\it (a)}-\hyperref[cond:d]{\it (d)} in Definition~\ref{defn:run}. The run  follows along the simple path extracted according to the solution to the MILP, thus condition~\hyperref[cond:a]{\it (a)} is met. This simple path only has one initial vertex and one accepting veretex since we remove other initial and accepting vertices in Section~\ref{sub-NBA:1}, thus condition~\hyperref[cond:b]{\it (b)} is met. In Section~\ref{sec:prune} we remove edges that do not strongly imply their end vertex labels. hence conditions~\hyperref[cond:c]{\it (c)} and \hyperref[cond:d]{\it (d)} are  met.

Finally, the path $\tau$ satisfies the condition~\hyperref[asmp:a]{\it (a)} in Assumption~\ref{asmp:same} due to constraint~\eqref{eq:c} that only one clause is true.  Condition \hyperref[asmp:b]{\it (b)} is the direct conseqeunce of the construction of the edge set of vertices in the routing graph $\ccalG$ that are associated with vertex labels in $\auto{subtask}^-$ (see step~\hyperref[edge:vertex2]{\it (E$_2$)} in Section~\ref{sec:edge_set}) and constraint~\eqref{eq:routingforactivation_b} that requires that robots visiting vertices in $\ccalG$  associated with vertex labels of subtasks that are not the first one, should come from vertices that are associated with edge labels of  subtasks that immediatedly preceding them. Note that the generation of low-level paths will not change the allocation made in the high-level plan.

\subsection{Proof of Lemma~\ref{prop:suffix_feasibility}}\label{app:suffix_feasibility}
The proof is much similar to the proof for the prefix part, so we go through procedures in~\ref{app:feasibility}.

First, we construct an essential word $w^*$ based on the given path $\tau$, as in Section~\ref{app:word}.  Note that the essential word is constructed with respect to the sub-NBA $\auto{subtask}^-$ in Fig.~\ref{fig:suffix} where we add a new clause $\pi_{\text{init}}$ to each edge label of subtasks that can be the last one to be completed. By condition~\hyperref[asmp:c]{\it (c)} in the Assumption~\ref{asmp:same}, all robots return to their initial locations for the suffix part at the  time when the NBA $\auto{subtask}^-$ returns to the accepting vertex $\vertex{accept}$, therefore, the last waypoint in $\tau$ must satisfies one such $\pi_{\text{init}}$ and further the last set of atomic propositions in $w^*$ is $\{\pi_{\text{init}}\}$. By taking the steps in Section~\ref{app:graph}, we can build a graph $\ccalG_{w^*}$ that is also a subgraph of the routing graph $\ccalG$.

Next, as the MILP formulation for the suffix part includes all constraints in Section~\ref{sec:milp} that appear in the prefix part, our analysis about these constraints is the same as that in Section~\ref{app:milp}. Thus, we focus on constraints~\eqref{eq:same_suffix}-\eqref{eq:return_suffix} in Section~\ref{sec:suf}. First, after solving  the prefix part, a fleet of robots are assocaited with literals that are  satisfied in the prefix part and share the same non-zero connector. In the subgraph $\ccalG_{w^*}$,  vertices  that are associated with a literal with a non-zero connector are visited by  robots belonging to the obtained fleet of robots in the prefix part. We enumerate these vertices to  have a one-to-one-correspondence between robots visiting them and robots in the obtained fleet in the prefix part, so that  two  robots that are matched  are the same robot. Therefore, constraint~\eqref{eq:same_suffix} is satisfied. Robots return to their initial locations when completing the last subtask, which satisfies the clause $\pi_{\text{init}}$. Furthermore, no two subtasks are satisfied at the same time in the path $\tau$, thus, constraints~\eqref{eq:one_suffix} and~\eqref{eq:lastsubtask} are  satisfied. Every vertex in $\ccalG_{w^*}$ that is associated with the clause $\pi_{\text{init}}$ of the last subtask is visited by the specific  robot, therefore, constraint~\eqref{eq:return_suffix} is satisfied.
\subsection{Proof of Lemma~\ref{prop:suffix_valid}}\label{app:suffix_valid}
The proof is similar to proof of Lemma~\ref{prop:valid} for the prefix part. The exception is the GMRPP that corresponds to the last subtask in the simple cycle $\theta$. In the last subtask, robots need to return to their initial locations. Since the initial locations satisfy the complete clause $\gamma_{1,2}^+ \wedge \gamma_{1,2}^-$,  we seek to show that, without violating the complete clause $\gamma_1^+ \wedge \gamma_1^-$ of the last subtask,  robots can move somewhere  adjacent to their respective initial locations so that  together they can move to their initial locations at the next time instant.

First, for those robots in $\ccalR_{1}$ that satisfy $\gamma_1^+$, they can move somewhere adjacent to their initial locations without violating $\gamma_{1}^+$ since according to constraint~\eqref{eq:17}, the completion time of the subtask  is at most one time instant later than the completion time of its starting vetex label, that is,  robots in $\ccalR_1$ remain at their respective regions until moving to their initial locations to complete the subtask. Next, for other robots not in $\ccalR_{1}$, they need to move somewhere adjacent to their initial locations while respecting the negative clause $\gamma_1^-$. According to the assumption, the simple cycle $\theta$ is in $\Theta_{\text{safe}}$, thus each negative literal in $\gamma_1^-$ belongs to $\Pi_{\text{safe}}$. We get that the initial locations of those robots in $\ccalR_1$
 do not violate $\gamma_1^-$ since the safe constraints should be satisfied all the time. Therefore, those robots not in $\ccalR_1$ can start from where they are at the end of the previous subtask (satisfying $\gamma_1^-$ as well due to strongly implication), travel to label-free paths without passing other regions, go to regions where their initial locations are and move somewhere in these regions thare are adjacent to their initial locations. Robots travelling within their respective regions will not violate $\gamma_1^-$ since the observaions do not change. In this way, at the next time instant, all robots move together to return to initial locations and complete the last subtask, completing the proof.

\subsection{Proof of Theorem~\ref{thm:completeness}}\label{app:completeness}


\theendnotes



%%Harvard (name/date)
\bibliographystyle{SageH}
\bibliography{xl_bib}
\end{document}
